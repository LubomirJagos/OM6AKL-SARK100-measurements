0000: 7D 74 00 LJMP  0x7400
0003: 30       HALT  

FILE: .\boot.asm
                                   (0116) ; Generated by PSoC Designer 5.0.972.0
                                   (0117) ;
                                   (0118) ;@Id: boot.tpl#895 @
                                   (0119) ;=============================================================================
0004: 30       HALT                (0120) ;  FILENAME:   boot.asm
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0121) ;  VERSION:    4.18
                                   (0122) ;  DATE:       28 June 2007
0008: 7D 00 68 LJMP  0x0068        (0123) ;
000B: 7E       RETI                (0124) ;  DESCRIPTION:
                                   (0125) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                   (0126) ;
000C: 7D 00 6C LJMP  0x006C        (0127) ;  Copyright (C) Cypress Semiconductor 2000-2005. All rights reserved.
000F: 7E       RETI                (0128) ;
                                   (0129) ; NOTES:
                                   (0130) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
0010: 7D 00 70 LJMP  0x0070        (0131) ; the project's root directory to create BOOT.ASM. Any changes made to
0013: 7E       RETI                (0132) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0133) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0134) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
0014: 7D 00 74 LJMP  0x0074        (0135) ; are not accidentally modified.
0017: 7E       RETI                (0136) ;
                                   (0137) ;=============================================================================
                                   (0138) 
0018: 7D 00 78 LJMP  0x0078        (0139) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
001B: 7E       RETI                (0140) include "m8c.inc"			;Part specific file
                                   (0141) include "m8ssc.inc"			;Part specific file
                                   (0142) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
001C: 7D 00 7C LJMP  0x007C        (0143) 
001F: 7E       RETI                (0144) ;--------------------------------------
                                   (0145) ; Export Declarations
                                   (0146) ;--------------------------------------
0020: 7D 00 80 LJMP  0x0080        (0147) 
0023: 7E       RETI                (0148) export __Start
                                   (0149) IF	(TOOLCHAIN & HITECH)
                                   (0150) ELSE
0024: 7D 00 84 LJMP  0x0084        (0151) export __bss_start
0027: 7E       RETI                (0152) export __data_start
                                   (0153) export __idata_start
                                   (0154) export __func_lit_start
0028: 7D 00 88 LJMP  0x0088        (0155) export __text_start
002B: 7E       RETI                (0156) ENDIF
                                   (0157) export  _bGetPowerSetting
                                   (0158) export   bGetPowerSetting
002C: 7D 00 8C LJMP  0x008C        (0159) 
002F: 7E       RETI                (0160) 
                                   (0161) ;--------------------------------------
                                   (0162) ; Optimization flags
0030: 7D 00 90 LJMP  0x0090        (0163) ;--------------------------------------
0033: 7E       RETI                (0164) ;
                                   (0165) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0166) ; boot.asm. See the notes in the banner comment at the beginning of
0034: 7D 00 94 LJMP  0x0094        (0167) ; this file.
0037: 7E       RETI                (0168) 
                                   (0169) ; Optimization for Assembly language (only) projects and C-language projects
                                   (0170) ; that do not depend on the C compiler to initialize the values of RAM variables.
0038: 7D 00 98 LJMP  0x0098        (0171) ;   Set to 1: Support for C Run-time Environment initialization
003B: 7E       RETI                (0172) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0173) ;
                                   (0174) IF	(TOOLCHAIN & HITECH)
003C: 7D 00 9C LJMP  0x009C        (0175) ; The C compiler will customize the startup code - it's not required here
003F: 7E       RETI                (0176) 
                                   (0177) C_LANGUAGE_SUPPORT:              equ 0
                                   (0178) ELSE
                                   (0179) C_LANGUAGE_SUPPORT:              equ 1
0040: 7E       RETI                (0180) ENDIF
0041: 30       HALT  
0042: 30       HALT  
0043: 30       HALT  
                                   (0181) 
                                   (0182) 
                                   (0183) ; The following equate is required for proper operation. Reseting its value
0044: 7E       RETI                (0184) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
0045: 30       HALT  
0046: 30       HALT  
0047: 30       HALT  
                                   (0185) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                   (0186) ; and PLL_Lock must take place within user code. See the family data sheet for
0048: 7D 09 11 LJMP  0x0911        (0187) ; the requirements of starting the ECO and PLL lock mode.
004B: 7E       RETI                (0188) ;
                                   (0189) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                   (0190) ;                invoking main
004C: 7D 09 12 LJMP  0x0912        (0191) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
004F: 7E       RETI                (0192) ;               the time code in main starts executing.
                                   (0193) ;
                                   (0194) WAIT_FOR_32K:                    equ 1
                                   (0195) 
0050: 7E       RETI                (0196) 
0051: 30       HALT  
0052: 30       HALT  
0053: 30       HALT  
                                   (0197) ; For historical reasons, by default the boot code uses an lcall instruction
                                   (0198) ; to invoke the user's _main code. If _main executes a return instruction,
                                   (0199) ; boot provides an infinite loop. By changing the following equate from zero
0054: 7E       RETI                (0200) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
0055: 30       HALT  
0056: 30       HALT  
0057: 30       HALT  
                                   (0201) ; bytes on the stack which are otherwise required for the return address. If
                                   (0202) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                   (0203) ; release, the C compiler automatically places an infinite loop at the end
0058: 7E       RETI                (0204) ; of main, rather than a return instruction.)
0059: 30       HALT  
005A: 30       HALT  
005B: 30       HALT  
                                   (0205) ;
                                   (0206) ENABLE_LJMP_TO_MAIN:             equ 0
                                   (0207) 
005C: 7E       RETI                (0208) 
005D: 30       HALT  
005E: 30       HALT  
005F: 30       HALT  
                                   (0209) ;-----------------------------------------------------------------------------
                                   (0210) ; Interrupt Vector Table
                                   (0211) ;-----------------------------------------------------------------------------
0060: 7E       RETI                (0212) ;
0061: 30       HALT  
0062: 30       HALT  
0063: 30       HALT  
                                   (0213) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                   (0214) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                   (0215) ; very short ISRs could be encoded within the table itself. Normally,
0064: 7D 50 AD LJMP  _SleepTimerINT(0216) ; vector jump targets are modified automatically according to the user
0067: 7E       RETI                (0217) ; modules selected. This occurs when the 'Generate Application' opera-
                                   (0218) ; tion is run causing PSoC Designer to create boot.asm and the other
                                   (0219) ; configuration files. If you need to hard code a vector, update the
                                   (0220) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0221) ; of this file.
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) 
                                   (0224)     AREA TOP (ROM, ABS, CON)
0068: 7E       RETI                (0225) 
0069: 30       HALT  
006A: 30       HALT  
006B: 30       HALT  
                                   (0226)     org   0                        ;Reset Interrupt Vector
                                   (0227) IF	(TOOLCHAIN & HITECH)
                                   (0228) ;   jmp   __Start                  ;C compiler fills in this vector
006C: 7E       RETI                (0229) ELSE
006D: 30       HALT  
006E: 30       HALT  
006F: 30       HALT  
                                   (0230)     ljmp   __Boot_Start                  ;First instruction executed following a Reset
                                   (0231) ;    jmp   __Start                  ;First instruction executed following a Reset
                                   (0232) ENDIF
0070: 7E       RETI                (0233) 
0071: 30       HALT  
0072: 30       HALT  
0073: 30       HALT  
                                   (0234)     org   04h                      ;Supply Monitor Interrupt Vector
                                   (0235)     halt                           ;Stop execution if power falls too low
                                   (0236) 
0074: 7E       RETI                (0237)     org   08h                      ;Analog Column 0 Interrupt Vector
0075: 30       HALT  
0076: 30       HALT  
0077: 30       HALT  
                                   (0238)     ljmp  0x0068
                                   (0239)     reti
                                   (0240) 
0078: 7E       RETI                (0241)     org   0Ch                      ;Analog Column 1 Interrupt Vector
0079: 30       HALT  
007A: 30       HALT  
007B: 30       HALT  
                                   (0242)     ljmp  0x006C
                                   (0243)     reti
                                   (0244) 
007C: 7E       RETI                (0245)     org   10h                      ;Analog Column 2 Interrupt Vector
007D: 30       HALT  
007E: 30       HALT  
007F: 30       HALT  
                                   (0246)     ljmp  0x0070
                                   (0247)     reti
0080: 7D 0F A1 LJMP  0x0FA1        (0248) 
0083: 7E       RETI                (0249)     org   14h                      ;Analog Column 3 Interrupt Vector
                                   (0250)     ljmp  0x0074
                                   (0251)     reti
0084: 7D 0F 9E LJMP  0x0F9E        (0252) 
0087: 7E       RETI                (0253)     org   18h                      ;VC3 Interrupt Vector
                                   (0254)     ljmp  0x0078
                                   (0255)     reti
                                   (0256) 
0088: 7E       RETI                (0257)     org   1Ch                      ;GPIO Interrupt Vector
0089: 30       HALT  
008A: 30       HALT  
008B: 30       HALT  
                                   (0258)     ljmp  0x007C
                                   (0259)     reti
                                   (0260) 
008C: 7E       RETI                (0261)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
008D: 30       HALT  
008E: 30       HALT  
008F: 30       HALT  
                                   (0262)     ljmp  0x0080
                                   (0263)     reti
0090: 7D 0B 71 LJMP  0x0B71        (0264) 
0093: 7E       RETI                (0265)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                   (0266)     ljmp  0x0084
                                   (0267)     reti
0094: 7D 0B D2 LJMP  0x0BD2        (0268) 
0097: 7E       RETI                (0269)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                   (0270)     ljmp  0x0088
                                   (0271)     reti
                                   (0272) 
0098: 7E       RETI                (0273)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
0099: 30       HALT  
009A: 30       HALT  
009B: 30       HALT  
                                   (0274)     ljmp  0x008C
                                   (0275)     reti
                                   (0276) 
009C: 7E       RETI                (0277)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
009D: 30       HALT  
009E: 30       HALT  
009F: 30       HALT  
00A0: 02 03    ADD   A,[3]
00A2: 04 05    ADD   [5],A
00A4: 06 07 71 ADD   [7],113
                                   (0278)     ljmp  0x0090
                                   (0279)     reti
                                   (0280) 
                                   (0281)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
                                   (0282)     ljmp  0x0094
                                   (0283)     reti
                                   (0284) 
                                   (0285)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
                                   (0286)     ljmp  0x0098
                                   (0287)     reti
                                   (0288) 
                                   (0289)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
                                   (0290)     ljmp  0x009C
                                   (0291)     reti
                                   (0292) 
                                   (0293)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
                                   (0294)     // call	void_handler
                                   (0295)     reti
                                   (0296) 
                                   (0297)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
                                   (0298)     // call	void_handler
                                   (0299)     reti
00A7: 10       PUSH  X             (0300) 
                                   (0301)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
00A8: 62 E3 87 MOV   REG[227],135  (0302)     ljmp	_UART_TX_ISR
00AB: 70 EF    AND   F,239         (0303)     reti
                                   (0304) 
                                   (0305)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
00AD: 50 20    MOV   A,32          (0306)     ljmp	_UART_RX_ISR
00AF: 28       ROMX                (0307)     reti
00B0: 50 40    MOV   A,64          (0308) 
00B2: 28       ROMX                (0309)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
00B3: 50 60    MOV   A,96          (0310)     // call	void_handler
00B5: 28       ROMX                (0311)     reti
                                   (0312) 
                                   (0313)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
                                   (0314)     // call	void_handler
                                   (0315)     reti
                                   (0316) 
                                   (0317)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
                                   (0318)     // call	void_handler
                                   (0319)     reti
                                   (0320) 
00B6: 41 FE FB AND   REG[254],251  (0321)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
                                   (0322)     // call	void_handler
                                   (0323)     reti
                                   (0324) 
                                   (0325)     org   60h                      ;PSoC I2C Interrupt Vector
                                   (0326)     // call	void_handler
                                   (0327)     reti
                                   (0328) 
                                   (0329)     org   64h                      ;Sleep Timer Interrupt Vector
                                   (0330) ;    // call	void_handler
00B9: 50 80    MOV   A,128         (0331) 	ljmp	_SleepTimerINT
00BB: 4E       SWAP  SP,A          (0332)     reti
                                   (0333) 
                                   (0334) /////////////////////////////////////////////////
                                   (0335) // New Relocatable Vector Table
                                   (0336) /////////////////////////////////////////////////
                                   (0337) 
                                   (0338)     org   68h                      ;Analog Column 0 Interrupt Vector
                                   (0339)     // call	void_handler
                                   (0340)     reti
                                   (0341) 
                                   (0342)     org   6Ch                      ;Analog Column 1 Interrupt Vector
                                   (0343)     // call	void_handler
                                   (0344)     reti
                                   (0345) 
                                   (0346)     org   70h                      ;Analog Column 2 Interrupt Vector
                                   (0347)     // call	void_handler
                                   (0348)     reti
                                   (0349) 
                                   (0350)     org   74h                      ;Analog Column 3 Interrupt Vector
                                   (0351)     // call	void_handler
                                   (0352)     reti
                                   (0353) 
                                   (0354)     org   78h                      ;VC3 Interrupt Vector
                                   (0355)     // call	void_handler
                                   (0356)     reti
                                   (0357) 
                                   (0358)     org   7Ch                      ;GPIO Interrupt Vector
                                   (0359)     // call	void_handler
                                   (0360)     reti
                                   (0361) 
                                   (0362)     org   80h                      ;PSoC Block DBB00 Interrupt Vector
00BC: 55 F8 00 MOV   [gTickCount+1],0(0363)     ljmp	_ADCINC12_TMR_ISR
00BF: 55 F9 00 MOV   [gTickCount+2],0(0364)     reti
                                   (0365) 
                                   (0366)     org   84h                      ;PSoC Block DBB01 Interrupt Vector
                                   (0367)     ljmp	_ADCINC12_CNT_ISR
                                   (0368)     reti
                                   (0369) 
                                   (0370)     org   88h                      ;PSoC Block DCB02 Interrupt Vector
                                   (0371)     // call	void_handler
                                   (0372)     reti
                                   (0373) 
                                   (0374)     org   8Ch                      ;PSoC Block DCB03 Interrupt Vector
                                   (0375)     // call	void_handler
                                   (0376)     reti
                                   (0377) 
                                   (0378)     org   90h                      ;PSoC Block DBB10 Interrupt Vector
                                   (0379)     ljmp	_Timer16_Delay_ISR
                                   (0380)     reti
                                   (0381) 
                                   (0382)     org   94h                      ;PSoC Block DBB11 Interrupt Vector
                                   (0383)     ljmp	_PWM8_BUZZ_ISR
                                   (0384)     reti
                                   (0385) 
                                   (0386)     org   98h                      ;PSoC Block DCB12 Interrupt Vector
                                   (0387)     // call	void_handler
00C2: 71 10    OR    F,16          (0388)     reti
00C4: 62 E0 12 MOV   REG[224],18   (0389) 
00C7: 70 EF    AND   F,239         (0390)     org   9Ch                      ;PSoC Block DCB13 Interrupt Vector
00C9: 62 E3 38 MOV   REG[227],56   (0391)     // call	void_handler
                                   (0392)     reti
                                   (0393) 
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;  Start of Execution.
                                   (0396) ;-----------------------------------------------------------------------------
                                   (0397) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0398) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0399) ;
                                   (0400)   org A0h
                                   (0401) __Boot_Check_Program:
                                   (0402)     db 2,3,4,5,6,7	// Control bytes sequence for BootLoader based Projects
                                   (0403) 
                                   (0404) ;IF	(TOOLCHAIN & HITECH)
                                   (0405) ; 	AREA PD_startup(CODE, REL, CON)
                                   (0406) ;ELSE
                                   (0407) ;    org 68h
                                   (0408) ;ENDIF
                                   (0409) __Start:
                                   (0410) 
                                   (0411)     ; initialize SMP values for voltage stabilization, if required,
                                   (0412)     ; leaving power-on reset (POR) level at the default (low) level, at
                                   (0413)     ; least for now. 
                                   (0414)     ;
                                   (0415)     M8C_SetBank1
                                   (0416) ;    mov reg[0FAh], 0				;Reset flash location
                                   (0417)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
                                   (0418)     M8C_SetBank0
                                   (0419) 
                                   (0420)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
                                   (0421)     mov   A, 20h
00CC: 62 71 05 MOV   REG[113],5    (0422)     romx
00CF: 62 75 05 MOV   REG[117],5    (0423)     mov   A, 40h
00D2: 62 79 05 MOV   REG[121],5    (0424)     romx
00D5: 62 7D 05 MOV   REG[125],5    (0425)     mov   A, 60h
                                   (0426)     romx
                                   (0427)     ; %45%20%46%46% End workaround
                                   (0428) 
                                   (0429) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0430)     M8C_EnableWatchDog
                                   (0431) ENDIF
                                   (0432) 
                                   (0433) IF ( SELECT_32K )
                                   (0434)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                   (0435) ELSE
                                   (0436)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0437) ENDIF
                                   (0438) 
                                   (0439)     ;---------------------------
                                   (0440)     ; Set up the Temporary stack
                                   (0441)     ;---------------------------
                                   (0442)     ; A temporary stack is set up for the SSC instructions.
                                   (0443)     ; The real stack start will be assigned later.
                                   (0444)     ;
                                   (0445) _stack_start:          equ 80h
                                   (0446)     mov   A, _stack_start          ; Set top of stack to end of used RAM
                                   (0447)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0448) 
                                   (0449)     ;-----------------------------------------------
                                   (0450)     ; Set Power-related Trim & the AGND Bypass bit.
                                   (0451)     ;-----------------------------------------------
00D8: 62 D1 07 MOV   REG[209],7    (0452) 
00DB: 50 00    MOV   A,0           (0453) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
00DD: 4E       SWAP  SP,A          (0454)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
00DE: 62 D3 07 MOV   REG[211],7    (0455)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
00E1: 62 D0 00 MOV   REG[208],0    (0456)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
00E4: 62 D5 00 MOV   REG[213],0    (0457)  ELSE                                          ; *** 12MHZ Main Oscillator ***
00E7: 62 D4 00 MOV   REG[212],0    (0458)   IF ( AGND_BYPASS )
                                   (0459)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0460)     ; The 5V trim has already been set, but we need to update the AGNDBYP
00EA: 71 C0    OR    F,192         (0461)     ; bit in the write-only BDG_TR register. Recalculate the register
                                   (0462)     ; value using the proper trim values.
                                   (0463)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0464)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0465)   ENDIF
                                   (0466)  ENDIF
                                   (0467) ENDIF ; 5.0 V Operation
                                   (0468) 
                                   (0469) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                   (0470)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                   (0471)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                   (0472)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0473)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                   (0474)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0475)  ENDIF
                                   (0476) ENDIF ; 3.3 Volt Operation
                                   (0477) 
                                   (0478)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
00EC: 7C 08 A6 LCALL 0x08A6        (0479)     mov  [bSSC_KEYSP], 0
                                   (0480) 
                                   (0481)     ;---------------------------------------
                                   (0482)     ; Initialize Crystal Oscillator and PLL
                                   (0483)     ;---------------------------------------
                                   (0484) 
                                   (0485) IF ( SELECT_32K & WAIT_FOR_32K )
                                   (0486)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                   (0487)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                   (0488)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                   (0489)     ; the ECO to stabilize.
                                   (0490)     ;
                                   (0491)     M8C_SetBank1
                                   (0492)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                   (0493)     M8C_SetBank0
                                   (0494)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                   (0495)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                   (0496)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                   (0497) .WaitFor1s:
                                   (0498)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                   (0499)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                   (0500)                                           ;   since interrupts are not globally enabled
                                   (0501) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                   (0502)     ; Either no ECO, or waiting for stable clock is to be done in main
                                   (0503)     M8C_SetBank1
                                   (0504)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
                                   (0505)     M8C_SetBank0
                                   (0506)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0507) 
                                   (0508) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                   (0509) 
                                   (0510) IF ( PLL_MODE )
00EF: 62 D0 02 MOV   REG[208],2    (0511)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                   (0512)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                   (0513)     ;
                                   (0514)     M8C_SetBank1
                                   (0515)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                   (0516)     M8C_SetBank0
                                   (0517)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
00F2: 50 08    MOV   A,8           (0518)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
00F4: 57 A4    MOV   X,164         (0519) 
00F6: 08       PUSH  A             (0520) .WaitFor16ms:
00F7: 28       ROMX                (0521)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
00F8: 53 B6    MOV   [__r0],A      (0522)     jz   .WaitFor16ms
00FA: 18       POP   A             (0523)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
00FB: 75       INC   X             (0524)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
00FC: 09 00    ADC   A,0           (0525)     M8C_SetBank0
00FE: 28       ROMX                (0526) 
00FF: 4B       SWAP  A,X           (0527) IF      ( WAIT_FOR_32K )
0100: 51 B6    MOV   A,[182]       (0528) ELSE ; !( WAIT_FOR_32K )
                                   (0529)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
0102: 80 04    JMP   0x0107        (0530)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                   (0531) ENDIF ;(WAIT_FOR_32K)
                                   (0532) ENDIF ;(PLL_MODE)
                                   (0533) 
                                   (0534)     ;------------------------
                                   (0535)     ; Close CT leakage path.
                                   (0536)     ;------------------------
                                   (0537)     mov   reg[ACB00CR0], 05h
                                   (0538)     mov   reg[ACB01CR0], 05h
                                   (0539)     mov   reg[ACB02CR0], 05h
                                   (0540)     mov   reg[ACB03CR0], 05h
                                   (0541) 
                                   (0542) 
                                   (0543) IF	(TOOLCHAIN & HITECH)
                                   (0544)     ;---------------------------------------------
                                   (0545)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                   (0546)     ;---------------------------------------------
                                   (0547) 	global		__Lstackps
0104: 75       INC   X             (0548) 	mov     a,low __Lstackps
0105: 09 00    ADC   A,0           (0549) 	swap    a,sp
                                   (0550) 
                                   (0551) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0552)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                   (0553)     RAM_SETPAGE_CUR 0
0107: 62 E3 00 MOV   REG[227],0    (0554)     RAM_SETPAGE_MVW 0
010A: 08       PUSH  A             (0555)     RAM_SETPAGE_MVR 0
010B: 28       ROMX                (0556)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
010C: 60 D5    MOV   REG[213],A    (0557)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
010E: 74       INC   A             (0558)     ELSE
010F: A0 4B    JZ    0x015B        (0559)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
0111: 18       POP   A             (0560)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
0112: 75       INC   X             (0561) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
0113: 09 00    ADC   A,0           (0562) ELSE
0115: 08       PUSH  A             (0563)     ;---------------------------------------------
0116: 28       ROMX                (0564)     ; ImageCraft Enter the Large Memory Model, if applicable
0117: 53 B6    MOV   [__r0],A      (0565)     ;---------------------------------------------
0119: 18       POP   A             (0566) IF ( SYSTEM_LARGE_MEMORY_MODEL )
011A: 75       INC   X             (0567)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
011B: 09 00    ADC   A,0           (0568)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
011D: 08       PUSH  A             (0569)     swap  A, SP
011E: 28       ROMX                (0570)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
011F: A0 1C    JZ    0x013C        (0571)     RAM_SETPAGE_CUR 0
0121: 53 B5    MOV   [__r1],A      (0572)     RAM_SETPAGE_MVW 0
0123: 18       POP   A             (0573)     RAM_SETPAGE_MVR 0
                                   (0574) 
                                   (0575)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                   (0576)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0577)   ELSE
                                   (0578)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0579)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0580) ELSE
0124: 75       INC   X             (0581)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
0125: 09 00    ADC   A,0           (0582)     swap  SP, A
0127: 08       PUSH  A             (0583) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
0128: 28       ROMX                (0584) ENDIF ;	TOOLCHAIN
0129: 3F B6    MVI   [__r0],A      (0585) 
012B: 47 B6 FF TST   [182],255     (0586)     ;-------------------------
012E: B0 06    JNZ   0x0135        (0587)     ; Load Base Configuration
0130: 5D D5    MOV   A,REG[213]    (0588)     ;-------------------------
0132: 74       INC   A             (0589)     ; Load global parameter settings and load the user modules in the
0133: 60 D5    MOV   REG[213],A    (0590)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0591)     ; to minimize start up time; (2) We may still need to play with the
0135: 18       POP   A             (0592)     ; Sleep Timer.
0136: 7A B5    DEC   [__r1]        (0593)     ;
0138: BF EB    JNZ   0x0124        (0594)     lcall LoadConfigInit
013A: 8F C9    JMP   0x0104        (0595) 
                                   (0596)     ;-----------------------------------
                                   (0597)     ; Initialize C Run-Time Environment
013C: 18       POP   A             (0598)     ;-----------------------------------
013D: 75       INC   X             (0599) IF ( C_LANGUAGE_SUPPORT )
013E: 09 00    ADC   A,0           (0600) IF ( SYSTEM_SMALL_MEMORY_MODEL )
0140: 08       PUSH  A             (0601)     mov  A,0                           ; clear the 'bss' segment to zero
0141: 28       ROMX                (0602)     mov  [__r0],<__bss_start
0142: 53 B5    MOV   [__r1],A      (0603) BssLoop:
0144: 50 00    MOV   A,0           (0604)     cmp  [__r0],<__bss_end
                                   (0605)     jz   BssDone
                                   (0606)     mvi  [__r0],A
                                   (0607)     jmp  BssLoop
                                   (0608) BssDone:
                                   (0609)     mov  A,>__idata_start              ; copy idata to data segment
0146: 3F B6    MVI   [__r0],A      (0610)     mov  X,<__idata_start
0148: 47 B6 FF TST   [182],255     (0611)     mov  [__r0],<__data_start
014B: B0 08    JNZ   0x0154        (0612) IDataLoop:
014D: 5D D5    MOV   A,REG[213]    (0613)     cmp  [__r0],<__data_end
014F: 74       INC   A             (0614)     jz   C_RTE_Done
0150: 60 D5    MOV   REG[213],A    (0615)     push A
0152: 50 00    MOV   A,0           (0616)     romx
                                   (0617)     mvi  [__r0],A
0154: 7A B5    DEC   [__r1]        (0618)     pop  A
0156: BF EF    JNZ   0x0146        (0619)     inc  X
0158: 18       POP   A             (0620)     adc  A,0
0159: 8F AA    JMP   0x0104        (0621)     jmp  IDataLoop
                                   (0622) 
                                   (0623) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
015B: 18       POP   A             (0624) 
                                   (0625) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0626)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0627)                                        ; to use the Virtual Register page.
                                   (0628) 
                                   (0629)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0630)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0631)     ; text segment and may have been relocated by the Code Compressor.
                                   (0632)     ;
                                   (0633)     mov   A, >__pXIData                ; Get the address of the flash
                                   (0634)     mov   X, <__pXIData                ;   pointer to the xidata area.
                                   (0635)     push  A
                                   (0636)     romx                               ; get the MSB of xidata's address
                                   (0637)     mov   [__r0], A
                                   (0638)     pop   A
                                   (0639)     inc   X
                                   (0640)     adc   A, 0
                                   (0641)     romx                               ; get the LSB of xidata's address
                                   (0642)     swap  A, X
                                   (0643)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0644)                                        ;   XIData structure list in flash
                                   (0645)     jmp   .AccessStruct
                                   (0646) 
                                   (0647)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0648)     ; values of C variables. Each structure contains 3 member elements.
                                   (0649)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0650)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0651)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0652)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0653)     ; value in the second member element, an unsigned byte:
                                   (0654)     ; (1) If the value of the second element is non-zero, it represents
                                   (0655)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0656)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0657)     ; the bytes are copied to the block of RAM.
                                   (0658)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0659)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0660)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0661) 
                                   (0662) .AccessNextStructLoop:
                                   (0663)     inc   X                            ; pXIData++
                                   (0664)     adc   A, 0
015C: 71 10    OR    F,16          (0665) .AccessStruct:                         ; Entry point for first block
                                   (0666)     ;
                                   (0667)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0668)     ;
                                   (0669)     M8C_ClearWDT                       ; Clear the watchdog for long inits
                                   (0670)     push  A
                                   (0671)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
                                   (0672)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
015E: 43 E3 20 OR    REG[227],32   (0673)     inc   A                            ; End of Struct List? (MSB==0xFF?)
                                   (0674)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
                                   (0675)     pop   A                            ; restore pXIData to [A,X]
                                   (0676)     inc   X                            ; pXIData++
                                   (0677)     adc   A, 0
0161: 70 EF    AND   F,239         (0678)     push  A
                                   (0679)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
                                   (0680)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
                                   (0681)     pop   A                            ; restore pXIData to [A,X]
                                   (0682)     inc   X                            ; pXIData++ (point to size)
                                   (0683)     adc   A, 0
                                   (0684)     push  A
                                   (0685)     romx                               ; Get the size (CPU.A <- *pXIData)
                                   (0686)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
0163: 62 E0 00 MOV   REG[224],0    (0687)     mov   [__r1], A                    ;             else downcount in __r1
                                   (0688)     pop   A                            ; restore pXIData to [A,X]
                                   (0689) 
                                   (0690) .CopyNextByteLoop:
                                   (0691)     ; For each byte in the structure's array member, copy from flash to RAM.
0166: 71 10    OR    F,16          (0692)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
0168: 62 E0 13 MOV   REG[224],19   (0693)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
016B: 43 E7 80 OR    REG[231],128  (0694)     ;         __r1 holds a non-zero count of the number of bytes remaining.
016E: 70 EF    AND   F,239         (0695)     ;
                                   (0696)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0697)     adc   A, 0
                                   (0698)     push  A
                                   (0699)     romx                               ; Get the data value (CPU.A <- *pXIData)
                                   (0700)     mvi   [__r0], A                    ; Transfer the data to RAM
0170: 62 E2 00 MOV   REG[226],0    (0701)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0702)     jnz   .CopyLoopTail                ;   No crossing, keep going
                                   (0703)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                   (0704)     inc   A
                                   (0705)     mov   reg[ MVW_PP], A
                                   (0706) .CopyLoopTail:
                                   (0707)     pop   A                            ; restore pXIData to [A,X]
                                   (0708)     dec   [__r1]                       ; End of this array in flash?
0173: 7C 34 3C LCALL _main         (0709)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
                                   (0710)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
0176: 8F FF    JMP   0x0176        (0711) 
                                   (0712) .ClearRAMBlockToZero:
                                   (0713)     pop   A                            ; restore pXIData to [A,X]
                                   (0714)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0715)     adc   A, 0
                                   (0716)     push  A
                                   (0717)     romx                               ; Get the run length (CPU.A <- *pXIData)
                                   (0718)     mov   [__r1], A                    ; Initialize downcounter
                                   (0719)     mov   A, 0                         ; Initialize source data
                                   (0720) 
                                   (0721) .ClearRAMBlockLoop:
                                   (0722)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                   (0723)     ;         __r1 holds a non-zero count of the number of bytes remaining.
0178: 50 10    MOV   A,16          (0724)     ;
06BA: 71 10    OR    F,16          (0725)     mvi   [__r0], A                    ; Clear a byte

FILE: lib\psocconfigtbl.asm
06BC: 62 00 51 MOV   REG[0],81     (0175) ; Generated by PSoC Designer 5.0.972.0
06BF: 62 01 AE MOV   REG[1],174    (0176) ;
06C2: 70 EF    AND   F,239         (0177) include "m8c.inc"
06C4: 62 03 AE MOV   REG[3],174    (0178) ;  Personalization tables 
06C7: 62 02 11 MOV   REG[2],17     (0179) export LoadConfigTBL_sark100_swranalyzer_bl_Bank1
06CA: 71 10    OR    F,16          (0180) export LoadConfigTBL_sark100_swranalyzer_bl_Bank0
06CC: 62 02 00 MOV   REG[2],0      (0181) export LoadConfigTBL_sark100_swranalyzer_bl_Ordered
06CF: 62 03 00 MOV   REG[3],0      (0182) AREA lit(rom, rel)
06D2: 70 EF    AND   F,239         (0183) LoadConfigTBL_sark100_swranalyzer_bl_Bank0:
06D4: 62 01 00 MOV   REG[1],0      (0184) ;  Instance name ADCINC12, User Module ADCINC12
06D7: 71 10    OR    F,16          (0185) ;       Instance name ADCINC12, Block Name ADC(ASC10)
06D9: 62 04 F4 MOV   REG[4],244    (0186) 	db		80h, 90h		;ADCINC12_AtoDcr0(ASC10CR0)
06DC: 62 05 0B MOV   REG[5],11     (0187) 	db		81h, 00h		;ADCINC12_AtoDcr1(ASC10CR1)
06DF: 70 EF    AND   F,239         (0188) 	db		82h, 60h		;ADCINC12_AtoDcr2(ASC10CR2)
06E1: 62 07 00 MOV   REG[7],0      (0189) 	db		83h, f0h		;ADCINC12_AtoDcr3(ASC10CR3)
06E4: 62 06 08 MOV   REG[6],8      (0190) ;       Instance name ADCINC12, Block Name CNT(DBB01)
06E7: 71 10    OR    F,16          (0191) 	db		27h, 00h		;ADCINC12_CounterCR0(DBB01CR0)
06E9: 62 06 00 MOV   REG[6],0      (0192) 	db		25h, 00h		;ADCINC12_CounterDR1(DBB01DR1)
06EC: 62 07 00 MOV   REG[7],0      (0193) 	db		26h, 00h		;ADCINC12_CounterDR2(DBB01DR2)
06EF: 70 EF    AND   F,239         (0194) ;       Instance name ADCINC12, Block Name TMR(DBB00)
06F1: 62 05 00 MOV   REG[5],0      (0195) 	db		23h, 00h		;ADCINC12_TimerCR0(DBB00CR0)
06F4: 71 10    OR    F,16          (0196) 	db		21h, 00h		;ADCINC12_TimerDR1(DBB00DR1)
06F6: 62 08 FF MOV   REG[8],255    (0197) 	db		22h, 00h		;ADCINC12_TimerDR2(DBB00DR2)
06F9: 62 09 00 MOV   REG[9],0      (0198) ;  Instance name AMUX4_ADC, User Module AMUX4
06FC: 70 EF    AND   F,239         (0199) ;  Instance name E2PROM, User Module E2PROM
06FE: 62 0B 00 MOV   REG[11],0     (0200) ;  Instance name LCD, User Module LCD
0701: 62 0A 00 MOV   REG[10],0     (0201) ;  Instance name PGA_ADC, User Module PGA
0704: 71 10    OR    F,16          (0202) ;       Instance name PGA_ADC, Block Name GAIN(ACB00)
0706: 62 0A 00 MOV   REG[10],0     (0203) 	db		71h, feh		;PGA_ADC_GAIN_CR0(ACB00CR0)
0709: 62 0B 00 MOV   REG[11],0     (0204) 	db		72h, 21h		;PGA_ADC_GAIN_CR1(ACB00CR1)
070C: 70 EF    AND   F,239         (0205) 	db		73h, 20h		;PGA_ADC_GAIN_CR2(ACB00CR2)
070E: 62 09 00 MOV   REG[9],0      (0206) 	db		70h, 00h		;PGA_ADC_GAIN_CR3(ACB00CR3)
0711: 71 10    OR    F,16          (0207) ;  Instance name PGA_DDS_1, User Module PGA
0713: 62 0C 00 MOV   REG[12],0     (0208) ;       Instance name PGA_DDS_1, Block Name GAIN(ACB03)
0716: 62 0D 00 MOV   REG[13],0     (0209) 	db		7dh, 66h		;PGA_DDS_1_GAIN_CR0(ACB03CR0)
0719: 70 EF    AND   F,239         (0210) 	db		7eh, a2h		;PGA_DDS_1_GAIN_CR1(ACB03CR1)
071B: 62 0F 00 MOV   REG[15],0     (0211) 	db		7fh, 20h		;PGA_DDS_1_GAIN_CR2(ACB03CR2)
071E: 62 0E 00 MOV   REG[14],0     (0212) 	db		7ch, 00h		;PGA_DDS_1_GAIN_CR3(ACB03CR3)
0721: 71 10    OR    F,16          (0213) ;  Instance name PGA_DDS_2, User Module PGA
0723: 62 0E 00 MOV   REG[14],0     (0214) ;       Instance name PGA_DDS_2, Block Name GAIN(ACB02)
0726: 62 0F 00 MOV   REG[15],0     (0215) 	db		79h, 76h		;PGA_DDS_2_GAIN_CR0(ACB02CR0)
0729: 70 EF    AND   F,239         (0216) 	db		7ah, 23h		;PGA_DDS_2_GAIN_CR1(ACB02CR1)
072B: 62 0D 00 MOV   REG[13],0     (0217) 	db		7bh, 20h		;PGA_DDS_2_GAIN_CR2(ACB02CR2)
072E: 71 10    OR    F,16          (0218) 	db		78h, 00h		;PGA_DDS_2_GAIN_CR3(ACB02CR3)
0730: 62 10 00 MOV   REG[16],0     (0219) ;  Instance name PWM8_BUZZ, User Module PWM8
0733: 62 11 00 MOV   REG[17],0     (0220) ;       Instance name PWM8_BUZZ, Block Name PWM8(DBB11)
0736: 70 EF    AND   F,239         (0221) 	db		37h, 00h		;PWM8_BUZZ_CONTROL_REG(DBB11CR0)
0738: 62 13 00 MOV   REG[19],0     (0222) 	db		35h, 00h		;PWM8_BUZZ_PERIOD_REG(DBB11DR1)
073B: 62 12 00 MOV   REG[18],0     (0223) 	db		36h, 00h		;PWM8_BUZZ_COMPARE_REG(DBB11DR2)
073E: 71 10    OR    F,16          (0224) ;  Instance name Timer16_Delay, User Module Timer16
0740: 62 12 00 MOV   REG[18],0     (0225) ;       Instance name Timer16_Delay, Block Name TIMER16_LSB(DCB03)
0743: 62 13 00 MOV   REG[19],0     (0226) 	db		2fh, 00h		;Timer16_Delay_CONTROL_LSB_REG(DCB03CR0)
0746: 70 EF    AND   F,239         (0227) 	db		2dh, 00h		;Timer16_Delay_PERIOD_LSB_REG(DCB03DR1)
0748: 62 11 00 MOV   REG[17],0     (0228) 	db		2eh, 00h		;Timer16_Delay_COMPARE_LSB_REG(DCB03DR2)
074B: 71 10    OR    F,16          (0229) ;       Instance name Timer16_Delay, Block Name TIMER16_MSB(DBB10)
074D: 62 14 00 MOV   REG[20],0     (0230) 	db		33h, 04h		;Timer16_Delay_CONTROL_MSB_REG(DBB10CR0)
0750: 62 15 00 MOV   REG[21],0     (0231) 	db		31h, 00h		;Timer16_Delay_PERIOD_MSB_REG(DBB10DR1)
0753: 70 EF    AND   F,239         (0232) 	db		32h, 00h		;Timer16_Delay_COMPARE_MSB_REG(DBB10DR2)
0755: 62 17 00 MOV   REG[23],0     (0233) ;  Instance name UART, User Module UART
0758: 62 16 00 MOV   REG[22],0     (0234) ;       Instance name UART, Block Name RX(DCB23)
075B: 71 10    OR    F,16          (0235) 	db		4fh, 00h		;UART_RX_CONTROL_REG(DCB23CR0)
075D: 62 16 00 MOV   REG[22],0     (0236) 	db		4dh, 00h		;UART_(DCB23DR1)
0760: 62 17 00 MOV   REG[23],0     (0237) 	db		4eh, 00h		;UART_RX_BUFFER_REG (DCB23DR2)
0763: 70 EF    AND   F,239         (0238) ;       Instance name UART, Block Name TX(DCB22)
0765: 62 15 00 MOV   REG[21],0     (0239) 	db		4bh, 00h		;UART_TX_CONTROL_REG(DCB22CR0)
0768: 71 10    OR    F,16          (0240) 	db		49h, 00h		;UART_TX_BUFFER_REG (DCB22DR1)
076A: 62 18 00 MOV   REG[24],0     (0241) 	db		4ah, 00h		;UART_(DCB22DR2)
076D: 62 19 00 MOV   REG[25],0     (0242) ;  Global Register values Bank 0
0770: 70 EF    AND   F,239         (0243) 	db		60h, 28h		; AnalogColumnInputSelect register (AMX_IN)
0772: 62 1B 00 MOV   REG[27],0     (0244) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
0775: 62 1A 00 MOV   REG[26],0     (0245) 	db		63h, 57h		; AnalogReferenceControl register (ARF_CR)
0778: 71 10    OR    F,16          (0246) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
077A: 62 1A 00 MOV   REG[26],0     (0247) 	db		e6h, 00h		; DecimatorControl_0 register (DEC_CR0)
077D: 62 1B 00 MOV   REG[27],0     (0248) 	db		e7h, 00h		; DecimatorControl_1 register (DEC_CR1)
0780: 70 EF    AND   F,239         (0249) 	db		d6h, 00h		; I2CConfig register (I2C_CFG)
0782: 62 19 00 MOV   REG[25],0     (0250) 	db		b0h, 00h		; Row_0_InputMux register (RDI0RI)
0785: 71 10    OR    F,16          (0251) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
0787: 62 1C 00 MOV   REG[28],0     (0252) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
078A: 62 1D 00 MOV   REG[29],0     (0253) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
078D: 70 EF    AND   F,239         (0254) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
078F: 62 1F 00 MOV   REG[31],0     (0255) 	db		b5h, 00h		; Row_0_OutputDrive_0 register (RDI0SRO0)
0792: 62 1E 00 MOV   REG[30],0     (0256) 	db		b6h, 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
0795: 71 10    OR    F,16          (0257) 	db		b8h, 55h		; Row_1_InputMux register (RDI1RI)
0797: 62 1E 00 MOV   REG[30],0     (0258) 	db		b9h, 00h		; Row_1_InputSync register (RDI1SYN)
079A: 62 1F 00 MOV   REG[31],0     (0259) 	db		bah, 10h		; Row_1_LogicInputAMux register (RDI1IS)
079D: 70 EF    AND   F,239         (0260) 	db		bbh, 33h		; Row_1_LogicSelect_0 register (RDI1LT0)
079F: 62 1D 00 MOV   REG[29],0     (0261) 	db		bch, 33h		; Row_1_LogicSelect_1 register (RDI1LT1)
08A6: 55 02 00 MOV   [xCalVr+2],0  (0262) 	db		bdh, 01h		; Row_1_OutputDrive_0 register (RDI1SRO0)

FILE: lib\psocconfig.asm
08A9: 55 03 FF MOV   [xCalVr+3],255(0066) ; Generated by PSoC Designer 5.0.972.0
08AC: 55 04 00 MOV   [4],0         (0067) ;
                                   (0068) ;==========================================================================
08AF: 7C 08 B6 LCALL 0x08B6        (0069) ;  PSoCConfig.asm
08B2: 7C 06 BA LCALL 0x06BA        (0070) ;  @PSOC_VERSION
                                   (0071) ;
                                   (0072) ;  Version: 0.85
                                   (0073) ;  Revised: June 22, 2004
08B5: 7F       RET                 (0074) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0075) ;
                                   (0076) ;  This file is generated by the Device Editor on Application Generation.
                                   (0077) ;  It contains code which loads the configuration data table generated in
                                   (0078) ;  the file PSoCConfigTBL.asm
                                   (0079) ;
                                   (0080) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0081) ;  Edits to this file will not be preserved.
                                   (0082) ;==========================================================================
                                   (0083) ;
                                   (0084) include "m8c.inc"
                                   (0085) include "memory.inc"
                                   (0086) include "GlobalParams.inc"
                                   (0087) 
                                   (0088) export LoadConfigInit
                                   (0089) export _LoadConfigInit
                                   (0090) export LoadConfig_sark100_swranalyzer_bl
                                   (0091) export _LoadConfig_sark100_swranalyzer_bl
                                   (0092) export Port_2_Data_SHADE
                                   (0093) export _Port_2_Data_SHADE
                                   (0094) export Port_2_DriveMode_0_SHADE
                                   (0095) export _Port_2_DriveMode_0_SHADE
                                   (0096) export Port_2_DriveMode_1_SHADE
                                   (0097) export _Port_2_DriveMode_1_SHADE
                                   (0098) 
08B6: 10       PUSH  X             (0099) 
08B7: 70 EF    AND   F,239         (0100) export NO_SHADOW
08B9: 50 00    MOV   A,0           (0101) export _NO_SHADOW
08BB: 67       ASR   A             (0102) 
                                   (0103) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
08BC: 50 05    MOV   A,5           (0104) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
08BE: 57 D2    MOV   X,210         (0105) 
08C0: 7C 08 D1 LCALL 0x08D1        (0106) AREA psoc_config(rom, rel)
                                   (0107) 
08C3: 50 01    MOV   A,1           (0108) ;---------------------------------------------------------------------------
08C5: 67       ASR   A             (0109) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                   (0110) ;                  parameters handled by boot code, like CPU speed). This
08C6: 50 06    MOV   A,6           (0111) ;                  function can be called from user code, but typically it
08C8: 57 6B    MOV   X,107         (0112) ;                  is only called from boot.
08CA: 7C 08 D1 LCALL 0x08D1        (0113) ;
                                   (0114) ;       INPUTS: None.
08CD: 70 EF    AND   F,239         (0115) ;      RETURNS: Nothing.
08CF: 20       POP   X             (0116) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                   (0117) ;               In the large memory model currently only the page
                                   (0118) ;               pointer registers listed below are modified.  This does
08D0: 7F       RET                 (0119) ;               not guarantee that in future implementations of this
                                   (0120) ;               function other page pointer registers will not be
                                   (0121) ;               modified.
                                   (0122) ;          
                                   (0123) ;               Page Pointer Registers Modified: 
                                   (0124) ;               CUR_PP
                                   (0125) ;
                                   (0126) _LoadConfigInit:
                                   (0127)  LoadConfigInit:
                                   (0128)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0129)     
                                   (0130) 	mov		[Port_2_Data_SHADE], 0h
                                   (0131) 	mov		[Port_2_DriveMode_0_SHADE], ffh
                                   (0132) 	mov		[Port_2_DriveMode_1_SHADE], 0h
                                   (0133) 
                                   (0134) 	lcall	LoadConfig_sark100_swranalyzer_bl
                                   (0135) 	lcall	LoadConfigTBL_sark100_swranalyzer_bl_Ordered
                                   (0136) 
                                   (0137) 
                                   (0138)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0139)     ret
                                   (0140) 
08D1: 38 02    ADD   SP,2          (0141) ;---------------------------------------------------------------------------
08D3: 10       PUSH  X             (0142) ; Load Configuration sark100_swranalyzer_bl
08D4: 08       PUSH  A             (0143) ;
08D5: 4F       MOV   X,SP          (0144) ;    Load configuration registers for sark100_swranalyzer_bl.
08D6: 56 FC 00 MOV   [X-4],0       (0145) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
08D9: D0 04    JNC   0x08DE        (0146) ;
08DB: 56 FC 01 MOV   [X-4],1       (0147) ;       INPUTS: None.
                                   (0148) ;      RETURNS: Nothing.
08DE: 18       POP   A             (0149) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
08DF: 20       POP   X             (0150) ;               modified as may the Page Pointer registers!
                                   (0151) ;               In the large memory model currently only the page
                                   (0152) ;               pointer registers listed below are modified.  This does
08E0: 70 EF    AND   F,239         (0153) ;               not guarantee that in future implementations of this
08E2: 62 E3 00 MOV   REG[227],0    (0154) ;               function other page pointer registers will not be
08E5: 10       PUSH  X             (0155) ;               modified.
08E6: 08       PUSH  A             (0156) ;          
08E7: 28       ROMX                (0157) ;               Page Pointer Registers Modified: 
08E8: 39 FF    CMP   A,255         (0158) ;               CUR_PP
08EA: A0 1F    JZ    0x090A        (0159) ;
08EC: 4F       MOV   X,SP          (0160) _LoadConfig_sark100_swranalyzer_bl:
08ED: 48 FC 01 TST   [X-4],1       (0161)  LoadConfig_sark100_swranalyzer_bl:
08F0: A0 03    JZ    0x08F4        (0162)     RAM_PROLOGUE RAM_USE_CLASS_4
08F2: 71 10    OR    F,16          (0163) 
                                   (0164) 	push	x
08F4: 54 FD    MOV   [X-3],A       (0165)     M8C_SetBank0                    ; Force bank 0
08F6: 18       POP   A             (0166)     mov     a, 0                    ; Specify bank 0
08F7: 20       POP   X             (0167)     asr     a                       ; Store in carry flag
08F8: 75       INC   X             (0168)                                     ; Load bank 0 table:
08F9: 09 00    ADC   A,0           (0169)     mov     A, >LoadConfigTBL_sark100_swranalyzer_bl_Bank0
08FB: 10       PUSH  X             (0170)     mov     X, <LoadConfigTBL_sark100_swranalyzer_bl_Bank0
08FC: 08       PUSH  A             (0171)     lcall   LoadConfig              ; Load the bank 0 values
08FD: 28       ROMX                (0172) 
08FE: 4F       MOV   X,SP          (0173)     mov     a, 1                    ; Specify bank 1
08FF: 59 FD    MOV   X,[X-3]       (0174)     asr     a                       ; Store in carry flag
0901: 61 00    MOV   REG[X+0],A    (0175)                                     ; Load bank 1 table:
0903: 18       POP   A             (0176)     mov     A, >LoadConfigTBL_sark100_swranalyzer_bl_Bank1
0904: 20       POP   X             (0177)     mov     X, <LoadConfigTBL_sark100_swranalyzer_bl_Bank1
0905: 75       INC   X             (0178)     lcall   LoadConfig              ; Load the bank 1 values
0906: 09 00    ADC   A,0           (0179) 
0908: 8F D7    JMP   0x08E0        (0180)     M8C_SetBank0                    ; Force return to bank 0
                                   (0181) 	pop		x
090A: 38 FC    ADD   SP,252        (0182) 
090C: 70 3F    AND   F,63
090E: 71 C0    OR    F,192         (0183)     RAM_EPILOGUE RAM_USE_CLASS_4
0911: 7E       RETI                (0184)     ret

FILE: lib\uartint.asm
                                   (0102) ;;*****************************************************************************
                                   (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME:   UARTINT.asm
                                   (0105) ;;  Version: 5.2, Updated on 2009/6/23 at 19:35:36
                                   (0106) ;;  Generated by PSoC Designer 5.0.972.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION:  UART Interrupt Service Routine.
                                   (0109) ;;-----------------------------------------------------------------------------
                                   (0110) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0111) ;;*****************************************************************************
                                   (0112) ;;*****************************************************************************
                                   (0113) 
                                   (0114) 
                                   (0115) include "UART.inc"
                                   (0116) include "memory.inc"
                                   (0117) include "m8c.inc"
                                   (0118) 
                                   (0119) ;-----------------------------------------------
                                   (0120) ;  Global Symbols
                                   (0121) ;-----------------------------------------------
                                   (0122) export  _UART_TX_ISR
                                   (0123) export  _UART_RX_ISR
                                   (0124) 
                                   (0125) IF (UART_RXBUF_ENABLE)
                                   (0126) export  UART_aRxBuffer
                                   (0127) export _UART_aRxBuffer
                                   (0128) export  UART_bRxCnt
                                   (0129) export _UART_bRxCnt
                                   (0130) export  UART_fStatus
                                   (0131) export _UART_fStatus
                                   (0132) ENDIF
                                   (0133) 
                                   (0134) 
                                   (0135) ;-----------------------------------------------
                                   (0136) ; Variable Allocation
                                   (0137) ;-----------------------------------------------
                                   (0138) AREA InterruptRAM (RAM, REL, CON)
                                   (0139) 
                                   (0140) IF (UART_RXBUF_ENABLE)
                                   (0141)  UART_fStatus:
                                   (0142) _UART_fStatus:      BLK  1
                                   (0143)  UART_bRxCnt:
                                   (0144) _UART_bRxCnt:       BLK  1
                                   (0145) AREA UART_RAM (RAM, REL, CON)
                                   (0146)  UART_aRxBuffer:
                                   (0147) _UART_aRxBuffer:    BLK UART_RX_BUFFER_SIZE
                                   (0148) ENDIF
                                   (0149) 
                                   (0150) AREA InterruptRAM (RAM, REL, CON)
                                   (0151) 
0912: 08       PUSH  A             (0152) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0913: 10       PUSH  X             (0153) ;---------------------------------------------------
0914: 5D D3    MOV   A,REG[211]
                                   (0154) ; Insert your custom declarations below this banner
                                   (0155) ;---------------------------------------------------
0916: 08       PUSH  A             (0156) 
                                   (0157) ;------------------------
                                   (0158) ;  Includes
0917: 58 01    MOV   X,[xCalVr+1]  (0159) ;------------------------
0919: 5D 4F    MOV   A,REG[79]     (0160) 
091B: 08       PUSH  A             (0161) 
                                   (0162) ;------------------------
091C: 21 08    AND   A,8           (0163) ;  Constant Definitions
091E: B0 04    JNZ   0x0923        (0164) ;------------------------
0920: 18       POP   A             (0165) 
0921: 80 5E    JMP   0x0980        (0166) 
                                   (0167) ;------------------------
                                   (0168) ; Variable Allocation
0923: 18       POP   A             (0169) ;------------------------
                                   (0170) 
                                   (0171) 
0924: 21 E0    AND   A,224         (0172) ;---------------------------------------------------
0926: A0 12    JZ    0x0939        (0173) ; Insert your custom declarations above this banner
                                   (0174) ;---------------------------------------------------
0928: 2C 00    OR    [xCalVr],A    (0175) ;@PSoC_UserCode_END@ (Do not change this line.)
092A: 49 4E 00 TST   REG[78],0     (0176) 
092D: 21 20    AND   A,32          (0177) 
092F: A0 50    JZ    0x0980        (0178) AREA UserModules (ROM, REL, CON)
                                   (0179) 
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: _UART_TX_ISR
0931: 41 4F FE AND   REG[79],254   (0182) ;
0934: 43 4F 01 OR    REG[79],1     (0183) ;  DESCRIPTION:
0937: 80 48    JMP   0x0980        (0184) ;     UART TX interrupt handler for instance UART.
                                   (0185) ;
                                   (0186) ;     This is a place holder function.  If the user requires use of an interrupt
                                   (0187) ;     handler for this function, then place code where specified.
0939: 5D 4E    MOV   A,REG[78]     (0188) ;-----------------------------------------------------------------------------
                                   (0189) 
                                   (0190) _UART_TX_ISR:
093B: 47 00 01 TST   [xCalVr],1    (0191)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
093E: B0 41    JNZ   0x0980        (0192)    ;---------------------------------------------------
                                   (0193)    ; Insert your custom code below this banner
0940: 39 0D    CMP   A,13          (0194)    ;---------------------------------------------------
0942: B0 14    JNZ   0x0957        (0195)    ;   NOTE: interrupt service routines must preserve
0944: 2E 00 01 OR    [xCalVr],1    (0196)    ;   the values of the A and X CPU registers.
                                   (0197)    
                                   (0198)    ;---------------------------------------------------
                                   (0199)    ; Insert your custom code above this banner
0947: 62 D3 01 MOV   REG[211],1    (0200)    ;---------------------------------------------------
094A: 70 3F    AND   F,63
094C: 71 80    OR    F,128         (0201)    ;@PSoC_UserCode_END@ (Do not change this line.)
094E: 56 E0 00 MOV   [X-32],0      (0202)    reti
0951: 70 3F    AND   F,63
0953: 71 00    OR    F,0           (0203) 
0955: 80 2A    JMP   0x0980        (0204) 
                                   (0205) ;-----------------------------------------------------------------------------
                                   (0206) ;  FUNCTION NAME: _UART_RX_ISR
                                   (0207) ;
                                   (0208) ;  DESCRIPTION:
                                   (0209) ;     UART RX interrupt handler for instance UART.
                                   (0210) ;     This ISR handles the background processing of received characters if
                                   (0211) ;     the buffer is enabled.
                                   (0212) ;
                                   (0213) ;
                                   (0214) ;  The following assumes that the RX buffer feature has been enabled.
                                   (0215) ;
                                   (0216) ;  SIDE EFFECTS:
                                   (0217) ;     There are 3 posible errors that may occur with the serial port.
0957: 39 20    CMP   A,32          (0218) ;      1) Parity Error
0959: C0 26    JC    0x0980        (0219) ;      2) Framing Error
                                   (0220) ;      3) OverRun Error
                                   (0221) ;
                                   (0222) ;  This user module check for parity and framing error.  If either of these
                                   (0223) ;  two errors are detected, the data is read and ignored.  When an overRun
095B: 62 D3 01 MOV   REG[211],1    (0224) ;  error occurs, the last byte was lost, but the current byte is valid.  For
095E: 3C 01 1F CMP   [xCalVr+1],31 (0225) ;  this reason this error is ignored at this time.  Code could be added to
0961: C0 11    JC    0x0973        (0226) ;  this ISR to set a flag if an error condition occurs.
0963: 70 3F    AND   F,63
0965: 71 80    OR    F,128         (0227) ;
0967: 56 E0 00 MOV   [X-32],0      (0228) ;  THEORY of OPERATION:
096A: 70 3F    AND   F,63
096C: 71 00    OR    F,0           (0229) ;     When using the RX buffer feature, the ISR collects received characters
096E: 2E 00 10 OR    [xCalVr],16   (0230) ;     in a buffer until the user defined command terminator is detected.  After
0971: 80 0E    JMP   0x0980        (0231) ;     the command terminator is detected, the command bit is set and all other
0973: 70 3F    AND   F,63
                                   (0232) ;     characters will be ignored until the command bit is reset.  Up to
                                   (0233) ;     buffer_size - 1 characters will be collected waiting for a command
                                   (0234) ;     terminator.  After that, the characters will be discarded, although
0975: 71 80    OR    F,128         (0235) ;     a command determinator will still cause the command bit to be set.
0977: 54 E0    MOV   [X-32],A      (0236) ;
0979: 70 3F    AND   F,63
097B: 71 00    OR    F,0           (0237) ;-----------------------------------------------------------------------------
097D: 75       INC   X             (0238) _UART_RX_ISR:
097E: 5A 01    MOV   [xCalVr+1],X  (0239) 
0980: 18       POP   A
                                   (0240)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                   (0241)    ;---------------------------------------------------
                                   (0242)    ; Insert your custom code below this banner
0981: 60 D3    MOV   REG[211],A    (0243)    ;---------------------------------------------------
                                   (0244)    ;   NOTE: interrupt service routines must preserve
                                   (0245)    ;   the values of the A and X CPU registers.
                                   (0246) 
0983: 20       POP   X             (0247)    ;---------------------------------------------------
0984: 18       POP   A             (0248)    ; Insert your custom code above this banner
                                   (0249)    ;---------------------------------------------------
                                   (0250)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0251) 
                                   (0252) IF (UART_RXBUF_ENABLE)
0986: 43 DF 04 OR    REG[223],4    (0253)    push A

FILE: lib\uart.asm
0989: 43 DF 08 OR    REG[223],8    (0180) ;;*****************************************************************************
                                   (0181) ;;*****************************************************************************
098C: 7F       RET                 (0182) ;;  Filename:   UART.asm
                                   (0183) ;;  Version: 5.2, Updated on 2009/6/23 at 19:35:36
                                   (0184) ;;  Generated by PSoC Designer 5.0.972.0
                                   (0185) ;;
                                   (0186) ;;  DESCRIPTION:  UART User Module software implementation file for the
                                   (0187) ;;                22/24/25/26/27xxx families.
                                   (0188) ;;
                                   (0189) ;;
                                   (0190) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0191) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0192) ;;        This means it is the caller's responsibility to preserve any values
                                   (0193) ;;        in the X and A registers that are still needed after the API functions
                                   (0194) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0195) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0196) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0197) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0198) ;;-----------------------------------------------------------------------------
                                   (0199) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0200) ;;*****************************************************************************
                                   (0201) ;;*****************************************************************************
                                   (0202) 
                                   (0203) 
                                   (0204) include "m8c.inc"
                                   (0205) include "memory.inc"
                                   (0206) include "UART.inc"
                                   (0207) 
                                   (0208) ;-----------------------------------------------
                                   (0209) ;  Global Symbols
                                   (0210) ;-----------------------------------------------
098D: 41 DF FB AND   REG[223],251  (0211) ;-------------------------------------------------------------------
0990: 41 DF F7 AND   REG[223],247  (0212) ;  Declare the functions global for both assembler and C compiler.
                                   (0213) ;
0993: 7F       RET                 (0214) ;  Note that there are two names for each API. First name is
                                   (0215) ;  assembler reference. Name with underscore is name refence for
                                   (0216) ;  C compiler.  Calling function in C source code does not require
                                   (0217) ;  the underscore.
                                   (0218) ;-------------------------------------------------------------------
                                   (0219) export  UART_SetTxIntMode
                                   (0220) export _UART_SetTxIntMode
                                   (0221) export  UART_EnableInt
                                   (0222) export _UART_EnableInt
                                   (0223) export  UART_DisableInt
                                   (0224) export _UART_DisableInt
                                   (0225) 
                                   (0226) export  UART_Start
                                   (0227) export _UART_Start
                                   (0228) export  UART_Stop
                                   (0229) export _UART_Stop
                                   (0230) export  UART_SendData
                                   (0231) export _UART_SendData
                                   (0232) export  UART_bReadTxStatus
                                   (0233) export _UART_bReadTxStatus
                                   (0234) export  UART_bReadRxData
                                   (0235) export _UART_bReadRxData
                                   (0236) export  UART_bReadRxStatus
                                   (0237) export _UART_bReadRxStatus
                                   (0238) 
                                   (0239) export  UART_IntCntl
                                   (0240) export _UART_IntCntl
                                   (0241) 
                                   (0242) export  UART_TxIntMode
                                   (0243) export _UART_TxIntMode
                                   (0244) 
                                   (0245) export  UART_PutSHexByte
                                   (0246) export _UART_PutSHexByte
0994: 71 10    OR    F,16          (0247) export  UART_PutSHexInt
0996: 21 01    AND   A,1           (0248) export _UART_PutSHexInt
0998: A0 07    JZ    0x09A0        (0249) 
099A: 43 48 10 OR    REG[72],16    (0250) export  UART_CPutString
099D: 70 EF    AND   F,239         (0251) export _UART_CPutString
                                   (0252) export  UART_PutString
099F: 7F       RET                 (0253) export _UART_PutString
                                   (0254) export  UART_PutChar
                                   (0255) export _UART_PutChar
09A0: 41 48 EF AND   REG[72],239   (0256) export  UART_Write
09A3: 70 EF    AND   F,239         (0257) export _UART_Write
                                   (0258) export  UART_CWrite
09A5: 7F       RET                 (0259) export _UART_CWrite
                                   (0260) 
                                   (0261) export  UART_cGetChar
                                   (0262) export _UART_cGetChar
                                   (0263) export  UART_cReadChar
                                   (0264) export _UART_cReadChar
                                   (0265) export  UART_iReadChar
                                   (0266) export _UART_iReadChar
                                   (0267) export  UART_PutCRLF
                                   (0268) export _UART_PutCRLF
                                   (0269) 
                                   (0270) IF (UART_RXBUF_ENABLE)
                                   (0271) export  UART_CmdReset
                                   (0272) export _UART_CmdReset
                                   (0273) export  UART_bCmdCheck
                                   (0274) export _UART_bCmdCheck
                                   (0275) export  UART_bCmdLength
                                   (0276) export _UART_bCmdLength
                                   (0277) export  UART_bErrCheck
                                   (0278) export _UART_bErrCheck
                                   (0279) 
                                   (0280) export  UART_szGetParam
                                   (0281) export _UART_szGetParam
                                   (0282) export  UART_szGetRestOfParams
                                   (0283) export _UART_szGetRestOfParams
                                   (0284) ENDIF
                                   (0285) 
                                   (0286) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0287) ; WARNING WARNING WARNING
                                   (0288) ; The following exports are for backwards compatibility only and should
                                   (0289) ; not be used for new designs. They may be eliminated in a future release.
09A6: 29 01    OR    A,1           (0290) ; Their status is "NO FURTHER MAINTENANCE". 
09A8: 60 4B    MOV   REG[75],A     (0291) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
09AA: 60 4F    MOV   REG[79],A     (0292) export  bUART_ReadTxStatus
                                   (0293) export _bUART_ReadTxStatus
09AC: 91 2A    CALL  0x0AD8        (0294) export  bUART_ReadRxData
                                   (0295) export _bUART_ReadRxData
                                   (0296) export  bUART_ReadRxStatus
09AE: 7F       RET                 (0297) export _bUART_ReadRxStatus
                                   (0298) 	
                                   (0299) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0300) ;             END WARNING
                                   (0301) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0302) 
                                   (0303) ;-----------------------------------------------
                                   (0304) ; Variable Allocation
                                   (0305) ;-----------------------------------------------
                                   (0306) IF (UART_RXBUF_ENABLE)
                                   (0307)     
                                   (0308) area UART_RAM (RAM, REL, CON)
                                   (0309)     
                                   (0310)  ptrParam:   BLK  1
                                   (0311) 
                                   (0312) ENDIF
                                   (0313) 
                                   (0314) area text (ROM,REL)
                                   (0315) 
                                   (0316) ;-----------------------------------------------
                                   (0317) ;  EQUATES
                                   (0318) ;-----------------------------------------------
                                   (0319) bfCONTROL_REG_START_BIT:        equ    1    ; Control register start bit
                                   (0320) bfFUNCTION_REG_TX_INT_MODE_BIT: equ 0x10    ; the TX Int Mode bit
                                   (0321) 
                                   (0322) area UserModules (ROM, REL, CON)
                                   (0323) 
                                   (0324) ;=============================================================================
09AF: 41 4B FE AND   REG[75],254   (0325) ;=============================================================================
09B2: 41 4F FE AND   REG[79],254   (0326) ;
                                   (0327) ;     Low-Level Commands
09B5: 7F       RET                 (0328) ;
                                   (0329) ;=============================================================================
                                   (0330) ;=============================================================================
                                   (0331) 
                                   (0332) .SECTION
                                   (0333) ;-----------------------------------------------------------------------------
                                   (0334) ;  FUNCTION NAME: UART_EnableInt
                                   (0335) ;
                                   (0336) ;  DESCRIPTION:
                                   (0337) ;     Enables this UART's interrupt by setting the interrupt enable mask
                                   (0338) ;     bit associated with this User Module. Remember to call the global
                                   (0339) ;     interrupt enable function by using the macro: M8C_EnableGInt.
                                   (0340) ;-----------------------------------------------------------------------------
                                   (0341) ;
                                   (0342) ;  ARGUMENTS:
                                   (0343) ;     none.
                                   (0344) ;
                                   (0345) ;  RETURNS:
                                   (0346) ;     none.
                                   (0347) ;
                                   (0348) ;  SIDE EFFECTS:
                                   (0349) ;    The A and X registers may be modified by this or future implementations
                                   (0350) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
                                   (0354) ;
                                   (0355)  UART_EnableInt:
09B6: 60 49    MOV   REG[73],A     (0356) _UART_EnableInt:
                                   (0357)    RAM_PROLOGUE RAM_USE_CLASS_1
09B8: 7F       RET                 (0358)    M8C_EnableIntMask UART_TX_INT_REG, UART_TX_INT_MASK
                                   (0359)    M8C_EnableIntMask UART_RX_INT_REG, UART_RX_INT_MASK
                                   (0360)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0361)    ret
                                   (0362) .ENDSECTION
                                   (0363) 
                                   (0364)     
                                   (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: UART_DisableInt
                                   (0368) ;
                                   (0369) ;  DESCRIPTION:
                                   (0370) ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
                                   (0371) ;     associated with this User Module.
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:
                                   (0375) ;     none.
                                   (0376) ;
                                   (0377) ;  RETURNS:
                                   (0378) ;     none.
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  UART_DisableInt:
                                   (0388) _UART_DisableInt:
09B9: 5D 4B    MOV   A,REG[75]     (0389)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0390)    M8C_DisableIntMask UART_TX_INT_REG, UART_TX_INT_MASK
09BB: 7F       RET                 (0391)    M8C_DisableIntMask UART_RX_INT_REG, UART_RX_INT_MASK
                                   (0392)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0393)    ret
                                   (0394) .ENDSECTION
                                   (0395) 
                                   (0396) 
                                   (0397) .SECTION
                                   (0398) ;-----------------------------------------------------------------------------
                                   (0399) ;  FUNCTION NAME: UART_SetTxIntMode(BYTE bTxIntMode)
                                   (0400) ;
                                   (0401) ;  DESCRIPTION:
                                   (0402) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0403) ;-----------------------------------------------------------------------------
                                   (0404) ;
                                   (0405) ;  ARGUMENTS:
                                   (0406) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0407) ;        Passed in the A register
                                   (0408) ;
                                   (0409) ;  RETURNS:
                                   (0410) ;     none.
                                   (0411) ;
                                   (0412) ;  SIDE EFFECTS:
                                   (0413) ;    The A and X registers may be modified by this or future implementations
                                   (0414) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0415) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0416) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0417) ;    functions.
                                   (0418) ;
                                   (0419) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0420) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0421) ;     on TX register empty or TX transmit complete
09BC: 5D 4E    MOV   A,REG[78]     (0422) ;
                                   (0423)  UART_SetTxIntMode:
09BE: 7F       RET                 (0424) _UART_SetTxIntMode:
                                   (0425)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0426)    M8C_SetBank1
                                   (0427)    and   A, UART_INT_MODE_TX_COMPLETE
                                   (0428)    jz    .SetModeRegEmpty
                                   (0429)    or    REG[UART_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0430)    M8C_SetBank0
                                   (0431)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0432)    ret
                                   (0433) 
                                   (0434) .SetModeRegEmpty:
                                   (0435)    and   REG[UART_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0436)    M8C_SetBank0
                                   (0437)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0438)    ret
                                   (0439) .ENDSECTION
                                   (0440) 
                                   (0441) 
                                   (0442) .SECTION
                                   (0443) ;-----------------------------------------------------------------------------
                                   (0444) ;  FUNCTION NAME: UART_Start(BYTE bParity)
                                   (0445) ;
                                   (0446) ;  DESCRIPTION:
                                   (0447) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0448) ;-----------------------------------------------------------------------------
                                   (0449) ;
                                   (0450) ;  ARGUMENTS:
                                   (0451) ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
                                   (0452) ;        Passed in the A register.
                                   (0453) ;
                                   (0454) ;  RETURNS:
                                   (0455) ;     none.
09BF: 5D 4F    MOV   A,REG[79]     (0456) ;
                                   (0457) ;  SIDE EFFECTS:
09C1: 7F       RET                 (0458) ;    The A and X registers may be modified by this or future implementations
                                   (0459) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0460) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0461) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0462) ;    functions.
                                   (0463) ;
                                   (0464)  UART_Start:
                                   (0465) _UART_Start:
                                   (0466)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0467)    ; Note, Proxy Class 4 only if receive buffer used; otherwise Proxy Class 1.
                                   (0468) 
                                   (0469)    or    A, bfCONTROL_REG_START_BIT
                                   (0470)    mov   REG[UART_TX_CONTROL_REG], A
                                   (0471)    mov   REG[UART_RX_CONTROL_REG], A
                                   (0472) IF ( UART_RXBUF_ENABLE )
                                   (0473)    call  _UART_CmdReset
                                   (0474) ENDIF
                                   (0475)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0476)    ret
                                   (0477) .ENDSECTION
                                   (0478) 
                                   (0479) 
                                   (0480) .SECTION
                                   (0481) ;-----------------------------------------------------------------------------
                                   (0482) ;  FUNCTION NAME: UART_Stop
                                   (0483) ;
                                   (0484) ;  DESCRIPTION:
                                   (0485) ;     Disables UART operation.
                                   (0486) ;-----------------------------------------------------------------------------
                                   (0487) ;
                                   (0488) ;  ARGUMENTS:
09C2: 21 01    AND   A,1           (0489) ;     none.
09C4: 71 10    OR    F,16          (0490) ;
09C6: 39 01    CMP   A,1           (0491) ;  RETURNS:
09C8: A0 06    JZ    0x09CF        (0492) ;     none.
                                   (0493) ;
09CA: 41 48 EF AND   REG[72],239   (0494) ;  SIDE EFFECTS:
09CD: 80 04    JMP   0x09D2        (0495) ;    The A and X registers may be modified by this or future implementations
                                   (0496) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0497) ;    the Large Memory Model.  When necessary, it is the calling function's
09CF: 43 48 10 OR    REG[72],16    (0498) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0499) ;    functions.
                                   (0500) ;
09D2: 70 EF    AND   F,239         (0501)  UART_Stop:
                                   (0502) _UART_Stop:
09D4: 7F       RET                 (0503)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0504)    and   REG[UART_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0505)    and   REG[UART_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0506)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0507)    ret
                                   (0508) .ENDSECTION
                                   (0509) 
                                   (0510) 
                                   (0511) .SECTION
                                   (0512) ;-----------------------------------------------------------------------------
                                   (0513) ;  FUNCTION NAME: UART_SendData
                                   (0514) ;
                                   (0515) ;  DESCRIPTION:
                                   (0516) ;     Initiates a transmission of data.
                                   (0517) ;-----------------------------------------------------------------------------
                                   (0518) ;
                                   (0519) ;  ARGUMENTS:
                                   (0520) ;     BYTE  TxData - data to transmit. PASSED in A register.
                                   (0521) ;
                                   (0522) ;  RETURNS:
                                   (0523) ;     none.
                                   (0524) ;
                                   (0525) ;  SIDE EFFECTS:
                                   (0526) ;    The A and X registers may be modified by this or future implementations
                                   (0527) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0528) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0529) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0530) ;    functions.
                                   (0531) ;
                                   (0532)  UART_SendData:
                                   (0533) _UART_SendData:
                                   (0534)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0535)    mov REG[UART_TX_BUFFER_REG], A
09D5: 08       PUSH  A             (0536)    RAM_EPILOGUE RAM_USE_CLASS_1
09D6: 21 01    AND   A,1           (0537)    ret
09D8: A0 06    JZ    0x09DF        (0538) .ENDSECTION
                                   (0539) 
09DA: 43 DF 08 OR    REG[223],8    (0540) 
09DD: 80 04    JMP   0x09E2        (0541) .SECTION
                                   (0542) ;-----------------------------------------------------------------------------
                                   (0543) ;  FUNCTION NAME: UART_bReadTxStatus
09DF: 41 DF F7 AND   REG[223],247  (0544) ;
                                   (0545) ;  DESCRIPTION:
                                   (0546) ;     Reads the Tx Status bits in the Control/Status register.
09E2: 18       POP   A             (0547) ;-----------------------------------------------------------------------------
09E3: 21 02    AND   A,2           (0548) ;
09E5: A0 06    JZ    0x09EC        (0549) ;  ARGUMENTS:
                                   (0550) ;     none.
09E7: 43 DF 04 OR    REG[223],4    (0551) ;
09EA: 80 04    JMP   0x09EF        (0552) ;  RETURNS:
                                   (0553) ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
                                   (0554) ;           status bits (returned in A)
09EC: 41 DF FB AND   REG[223],251  (0555) ;
                                   (0556) ;  SIDE EFFECTS:
                                   (0557) ;    The A and X registers may be modified by this or future implementations
                                   (0558) ;    of this function.  The same is true for all RAM page pointer registers in
09EF: 7F       RET                 (0559) ;    the Large Memory Model.  When necessary, it is the calling function's
09F0: 30       HALT  
09F1: 31 32    XOR   A,50
09F3: 33 34    XOR   A,[X+52]
09F5: 35 36    XOR   [X+54],A
09F7: 37 38 39 XOR   [X+56],57
09FA: 41 42 43 AND   REG[66],67
09FD: 44 45 46 OR    REG[X+69],70
                                   (0560) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0561) ;    functions.
                                   (0562) ;
                                   (0563)  UART_bReadTxStatus:
                                   (0564) _UART_bReadTxStatus:
                                   (0565)  bUART_ReadTxStatus:                             ; For backwards compatibility only
                                   (0566) _bUART_ReadTxStatus:                             ; For backwards compatibility only
                                   (0567)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0568)    mov A,  REG[UART_TX_CONTROL_REG]
                                   (0569)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0570)    ret
                                   (0571) .ENDSECTION
                                   (0572) 
                                   (0573) 
                                   (0574) .SECTION
                                   (0575) ;-----------------------------------------------------------------------------
                                   (0576) ;  FUNCTION NAME: UART_bReadRxData
                                   (0577) ;
                                   (0578) ;  DESCRIPTION:
                                   (0579) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0580) ;     sure data is valid.
                                   (0581) ;-----------------------------------------------------------------------------
                                   (0582) ;
                                   (0583) ;  ARGUMENTS:
                                   (0584) ;     none.
                                   (0585) ;
                                   (0586) ;  RETURNS:
                                   (0587) ;     bRxData - returned in A.
                                   (0588) ;
                                   (0589) ;  SIDE EFFECTS:
                                   (0590) ;    The A and X registers may be modified by this or future implementations
                                   (0591) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0592) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0593) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0594) ;    functions.
                                   (0595) ;
                                   (0596)  UART_bReadRxData:
                                   (0597) _UART_bReadRxData:
                                   (0598)  bUART_ReadRxData:                               ; For backwards compatibility only
                                   (0599) _bUART_ReadRxData:                               ; For backwards compatibility only
                                   (0600)    RAM_PROLOGUE RAM_USE_CLASS_1
0A00: 08       PUSH  A             (0601)    mov A, REG[UART_RX_BUFFER_REG]
0A01: 67       ASR   A             (0602)    RAM_EPILOGUE RAM_USE_CLASS_1
0A02: 67       ASR   A             (0603)    ret
0A03: 67       ASR   A             (0604) .ENDSECTION
0A04: 67       ASR   A             (0605) 
0A05: 21 0F    AND   A,15          (0606) 
0A07: FF E7    INDEX 0x09F0        (0607) .SECTION
0A09: 90 0F    CALL  0x0A1A        (0608) ;-----------------------------------------------------------------------------
0A0B: 18       POP   A             (0609) ;  FUNCTION NAME: UART_bReadRxStatus
0A0C: 21 0F    AND   A,15          (0610) ;
0A0E: FF E0    INDEX 0x09F0        (0611) ;  DESCRIPTION:
0A10: 90 08    CALL  0x0A1A        (0612) ;     Reads the RX Status bits in the Control/Status register.
                                   (0613) ;-----------------------------------------------------------------------------
0A12: 7F       RET                 (0614) ;
                                   (0615) ;  ARGUMENTS:
                                   (0616) ;     none.
                                   (0617) ;
                                   (0618) ;  RETURNS:
                                   (0619) ;     BYTE  bRXStatus - receive status data.  Use the following defined bits
                                   (0620) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0621) ;           returned in A.
                                   (0622) ;
                                   (0623) ;  SIDE EFFECTS:
                                   (0624) ;    The A and X registers may be modified by this or future implementations
                                   (0625) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0626) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0627) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0628) ;    functions.
                                   (0629) ;
                                   (0630)  UART_bReadRxStatus:
                                   (0631) _UART_bReadRxStatus:
                                   (0632)  bUART_ReadRxStatus:                             ; For backwards compatibility only
                                   (0633) _bUART_ReadRxStatus:                             ; For backwards compatibility only
                                   (0634)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0635)    mov A,  REG[UART_RX_CONTROL_REG]
                                   (0636)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0637)    ret
                                   (0638) .ENDSECTION
                                   (0639) 
                                   (0640) 
                                   (0641) .SECTION
                                   (0642) ;-----------------------------------------------------------------------------
                                   (0643) ;  FUNCTION NAME: UART_TxIntMode
                                   (0644) ;
0A13: 4B       SWAP  A,X           (0645) ;  DESCRIPTION:
0A14: 9F EA    CALL  0x0A00        (0646) ;     This function is used to change the TX Interrupt mode.
0A16: 5B       MOV   A,X           (0647) ;-----------------------------------------------------------------------------
0A17: 9F E7    CALL  0x0A00        (0648) ;
                                   (0649) ;  ARGUMENTS:
0A19: 7F       RET                 (0650) ;     A => Tx Interrupt mode
0A1A: 49 4B 10 TST   REG[75],16
                                   (0651) ;             0 => Interrupt on TX_Reg_Empty  (Default)
                                   (0652) ;             1 => Interrupt on TX Complete
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none.
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
                                   (0663) ;
                                   (0664)  UART_TxIntMode:
                                   (0665) _UART_TxIntMode:
                                   (0666)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0667) 
                                   (0668)    and  A,UART_INT_MODE_TX_COMPLETE
                                   (0669)    M8C_SetBank1
                                   (0670)    cmp  A,UART_INT_MODE_TX_COMPLETE
                                   (0671)    jz   .SetTxCmpMode
                                   (0672) 
                                   (0673)    and  reg[UART_TX_FUNC_REG],0xEF               ; Set Interrupt on Tx_Reg_Empty
                                   (0674)    jmp  .TxIntMode_End
                                   (0675) 
                                   (0676) .SetTxCmpMode:                                       ; Set Interrupt on TX Complete
                                   (0677)    or   reg[UART_TX_FUNC_REG],0x10
                                   (0678) 
                                   (0679) .TxIntMode_End:
                                   (0680)    M8C_SetBank0
                                   (0681)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0682)    ret
                                   (0683) .ENDSECTION
                                   (0684) 
                                   (0685)     
0A1D: AF FC    JZ    0x0A1A        (0686) .SECTION
0A1F: 60 49    MOV   REG[73],A
                                   (0687) ;-----------------------------------------------------------------------------
0A21: 7F       RET                 (0688) ;  FUNCTION NAME: UART_IntCntl
                                   (0689) ;
                                   (0690) ;  DESCRIPTION:
                                   (0691) ;     This function is used to enable/disable the Rx and Tx interrupt.
                                   (0692) ;-----------------------------------------------------------------------------
                                   (0693) ;
                                   (0694) ;  ARGUMENTS:
                                   (0695) ;     A => Interrupt mask
                                   (0696) ;
                                   (0697) ;  RETURNS:
                                   (0698) ;     none.
                                   (0699) ;
                                   (0700) ;  SIDE EFFECTS:
                                   (0701) ;    The A and X registers may be modified by this or future implementations
                                   (0702) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0703) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0704) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0705) ;    functions.
                                   (0706) ;
                                   (0707) ;  THEORY of OPERATION or PROCEDURE:
                                   (0708) ;     Set or Clears the Tx/Rx user module interrupt enable mask bit in the TX
                                   (0709) ;     and RX block.
                                   (0710) ;
                                   (0711)  UART_IntCntl:
                                   (0712) _UART_IntCntl:
                                   (0713)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0714) 
                                   (0715)    push A
                                   (0716)    and  A,UART_ENABLE_RX_INT
                                   (0717)    jz   .DisRxInt
                                   (0718)      ; Enable Rx Interrupt
                                   (0719)    M8C_EnableIntMask UART_RX_INT_REG, UART_RX_INT_MASK
0A22: 49 4F 08 TST   REG[79],8     (0720)    jmp  .CheckTxInt
0A25: AF FC    JZ    0x0A22        (0721) .DisRxInt:
0A27: 5D 4E    MOV   A,REG[78]     (0722)      ; Disable Rx Interrupt
                                   (0723)    M8C_DisableIntMask UART_RX_INT_REG, UART_RX_INT_MASK
0A29: 7F       RET                 (0724) 
                                   (0725) .CheckTxInt:
                                   (0726)    pop  A
                                   (0727)    and  A,UART_ENABLE_TX_INT
                                   (0728)    jz   .DisTxInt
                                   (0729)      ; Enable Tx Interrupt
                                   (0730)    M8C_EnableIntMask UART_TX_INT_REG, UART_TX_INT_MASK
                                   (0731)    jmp  .End_IntCntl
                                   (0732) .DisTxInt:
                                   (0733)      ; Disable Tx Interrupt
                                   (0734)    M8C_DisableIntMask UART_TX_INT_REG, UART_TX_INT_MASK
                                   (0735) 
                                   (0736) .End_IntCntl:
                                   (0737)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0738)    ret
                                   (0739) .ENDSECTION
                                   (0740) 
                                   (0741) 
                                   (0742) ;=============================================================================
                                   (0743) ;=============================================================================
                                   (0744) ;
                                   (0745) ;     High-Level Commands
                                   (0746) ;
                                   (0747) ;=============================================================================
                                   (0748) ;=============================================================================
                                   (0749) 
                                   (0750) 
                                   (0751) ;-----------------------------------------------------------------------------
                                   (0752) ;  FUNCTION NAME: UART_PutSHexByte
                                   (0753) ;
                                   (0754) ;  DESCRIPTION:
0A2A: 5D 4F    MOV   A,REG[79]     (0755) ;     Print a byte in Hex (two characters) to the UART Tx
0A2C: 08       PUSH  A             (0756) ;-----------------------------------------------------------------------------
0A2D: 21 08    AND   A,8           (0757) ;
0A2F: B0 04    JNZ   0x0A34        (0758) ;  ARGUMENTS:
0A31: 18       POP   A             (0759) ;     A  => (BYTE) Data/char to be printed
0A32: 80 0B    JMP   0x0A3E        (0760) ;
                                   (0761) ;  RETURNS:
                                   (0762) ;     none.
0A34: 5D 4E    MOV   A,REG[78]     (0763) ;
0A36: 4B       SWAP  A,X           (0764) ;  SIDE EFFECTS:
                                   (0765) ;    The A and X registers may be modified by this or future implementations
0A37: 18       POP   A             (0766) ;    of this function.  The same is true for all RAM page pointer registers in
0A38: 21 A0    AND   A,160         (0767) ;    the Large Memory Model.  When necessary, it is the calling function's
0A3A: B0 03    JNZ   0x0A3E        (0768) ;    responsibility to perserve their values across calls to fastcall16 
0A3C: 4B       SWAP  A,X           (0769) ;    functions.
                                   (0770) ;
0A3D: 7F       RET                 (0771) .LITERAL
                                   (0772) UART_HEX_STR:
                                   (0773)      DS    "0123456789ABCDEF"
0A3E: 50 00    MOV   A,0           (0774) .ENDLITERAL
                                   (0775) 
                                   (0776) .SECTION
                                   (0777)  UART_PutSHexByte:
0A40: 7F       RET                 (0778) _UART_PutSHexByte:
                                   (0779)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0780)    push  A                             ; Save lower nibble
                                   (0781)    asr   A                             ; Shift high nibble to right
                                   (0782)    asr   A
                                   (0783)    asr   A
                                   (0784)    asr   A
                                   (0785)    and   A,0Fh                         ; Mask off nibble
                                   (0786)    index UART_HEX_STR                  ; Get Hex value
                                   (0787)    call  UART_PutChar                  ; Write data to screen
                                   (0788)    pop   A                             ; Restore value
                                   (0789)    and   A,0Fh                         ; Mask off lower nibble
                                   (0790)    index UART_HEX_STR                  ; Get Hex value
                                   (0791)    call  UART_PutChar                  ; Write data to screen
                                   (0792)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0793)    ret
                                   (0794) .ENDSECTION
                                   (0795) 
                                   (0796) 
                                   (0797) .SECTION
                                   (0798) ;-----------------------------------------------------------------------------
                                   (0799) ;  FUNCTION NAME: UART_PutSHexInt
                                   (0800) ;
                                   (0801) ;  DESCRIPTION:
                                   (0802) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0803) ;-----------------------------------------------------------------------------
                                   (0804) ;
                                   (0805) ;  ARGUMENTS:
                                   (0806) ;     Pointer to string
                                   (0807) ;     A  => ASB of Int
                                   (0808) ;     X  => MSB of Int
                                   (0809) ;
                                   (0810) ;  RETURNS:
                                   (0811) ;     none.
                                   (0812) ;
                                   (0813) ;  SIDE EFFECTS:
                                   (0814) ;    The A and X registers may be modified by this or future implementations
                                   (0815) ;    of this function.  The same is true for all RAM page pointer registers in
0A41: 5D 4F    MOV   A,REG[79]     (0816) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0817) ;    responsibility to perserve their values across calls to fastcall16 
0A43: 21 E8    AND   A,232         (0818) ;    functions.
0A45: 08       PUSH  A             (0819) ;
0A46: 21 08    AND   A,8           (0820) 
0A48: B0 07    JNZ   0x0A50        (0821)  UART_PutSHexInt:
0A4A: 18       POP   A             (0822) _UART_PutSHexInt:
0A4B: 29 01    OR    A,1           (0823)    RAM_PROLOGUE RAM_USE_CLASS_1
0A4D: 4B       SWAP  A,X           (0824)    swap  A,X
0A4E: 80 07    JMP   0x0A56        (0825)    call  UART_PutSHexByte              ; Print MSB
                                   (0826)    mov   A,X                           ; Move LSB into position
                                   (0827)    call  UART_PutSHexByte              ; Print LSB
0A50: 18       POP   A             (0828)    RAM_EPILOGUE RAM_USE_CLASS_1
0A51: 21 E0    AND   A,224         (0829)    ret
0A53: 4B       SWAP  A,X           (0830) .ENDSECTION
0A54: 5D 4E    MOV   A,REG[78]     (0831) 
                                   (0832) 
                                   (0833) .SECTION
                                   (0834) ;-----------------------------------------------------------------------------
                                   (0835) ;  FUNCTION NAME: UART_PutChar
0A56: 7F       RET                 (0836) ;
                                   (0837) ;  DESCRIPTION:
                                   (0838) ;     Send character out through UART TX port.
                                   (0839) ;-----------------------------------------------------------------------------
                                   (0840) ;
                                   (0841) ;  ARGUMENTS:
                                   (0842) ;     A has Character to send to UART Tx Port
                                   (0843) ;
                                   (0844) ;  RETURNS:
                                   (0845) ;     none
                                   (0846) ;
                                   (0847) ;  SIDE EFFECTS:
                                   (0848) ;    The A and X registers may be modified by this or future implementations
                                   (0849) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0850) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0851) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0852) ;    functions.
                                   (0853) ;
                                   (0854) 
                                   (0855)    macro InLinePutChar( Source )
                                   (0856) .BufEmptyWaitLoop:
                                   (0857)    tst REG[UART_TX_CONTROL_REG], UART_TX_BUFFER_EMPTY     ; Check Tx Status
                                   (0858)    jz  .BufEmptyWaitLoop
                                   (0859)    mov REG[UART_TX_BUFFER_REG], @Source          ; Write data to Tx Port
                                   (0860)    endm
                                   (0861) 
                                   (0862)  UART_PutChar:
                                   (0863) _UART_PutChar:
                                   (0864)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0865)    InLinePutChar A
                                   (0866)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0867)    ret
0A57: 70 BF    AND   F,191         (0868) .ENDSECTION
0A59: 60 D3    MOV   REG[211],A    (0869) 
                                   (0870) 
0A5B: 52 00    MOV   A,[X+0]       (0871) .SECTION
0A5D: A0 06    JZ    0x0A64        (0872) ;-----------------------------------------------------------------------------
0A5F: 9F B9    CALL  0x0A1A        (0873) ;  FUNCTION NAME: UART_cGetChar
0A61: 75       INC   X             (0874) ;
0A62: 8F F8    JMP   0x0A5B        (0875) ;  DESCRIPTION:
0A64: 70 3F    AND   F,63
                                   (0876) ;     Read character from UART RX port.
                                   (0877) ;-----------------------------------------------------------------------------
0A66: 71 C0    OR    F,192         (0878) ;
0A68: 7F       RET                 (0879) ;  ARGUMENTS:
                                   (0880) ;      none
                                   (0881) ;
                                   (0882) ;  RETURNS:
                                   (0883) ;     char that is returned from UART
                                   (0884) ;
                                   (0885) ;  SIDE EFFECTS:
                                   (0886) ;    The A and X registers may be modified by this or future implementations
                                   (0887) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0888) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0889) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0890) ;    functions.
                                   (0891) ;
                                   (0892) ;    Program flow will stay in this function until a character is received.
                                   (0893) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0894) ;    the delay between characters is less than the watchdog timeout.
                                   (0895) ;
                                   (0896)  UART_cGetChar:
                                   (0897) _UART_cGetChar:
                                   (0898)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0899)    tst REG[UART_RX_CONTROL_REG],UART_RX_REG_FULL    ; Check if a character is ready
                                   (0900)    jz  UART_cGetChar                             ; If not loop
                                   (0901)    mov A, REG[UART_RX_BUFFER_REG]                ; Get character
                                   (0902)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0903)    ret
                                   (0904) .ENDSECTION
                                   (0905) 
                                   (0906) 
                                   (0907) .SECTION
                                   (0908) ;-----------------------------------------------------------------------------
                                   (0909) ;  FUNCTION NAME: UART_cReadChar
                                   (0910) ;
                                   (0911) ;  DESCRIPTION:
                                   (0912) ;     Read character from UART RX port.
                                   (0913) ;-----------------------------------------------------------------------------
                                   (0914) ;
0A69: 70 BF    AND   F,191         (0915) ;  ARGUMENTS:
0A6B: 62 D3 07 MOV   REG[211],7    (0916) ;      none
0A6E: 4F       MOV   X,SP          (0917) ;
                                   (0918) ;  RETURNS:
                                   (0919) ;     char that is returned from UART
0A6F: 52 FB    MOV   A,[X-5]       (0920) ;
0A71: A0 1A    JZ    0x0A8C        (0921) ;  SIDE EFFECTS:
0A73: 7B FB    DEC   [X-5]         (0922) ;    The A and X registers may be modified by this or future implementations
                                   (0923) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0924) ;    the Large Memory Model.  When necessary, it is the calling function's
0A75: 52 FC    MOV   A,[X-4]       (0925) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0926) ;    functions.
                                   (0927) ;
0A77: 59 FD    MOV   X,[X-3]       (0928) ;    A valid 0x00 character will be ignored, since a 0x00 return value
0A79: 60 D3    MOV   REG[211],A    (0929) ;    implies a valid character or an error condition occured.
0A7B: 52 00    MOV   A,[X+0]       (0930) ;
0A7D: 49 4B 10 TST   REG[75],16
0A80: AF FC    JZ    0x0A7D        (0931)  UART_cReadChar:
0A82: 60 49    MOV   REG[73],A
0A84: 4F       MOV   X,SP          (0932) _UART_cReadChar:
0A85: 62 D3 07 MOV   REG[211],7    (0933)    RAM_PROLOGUE RAM_USE_CLASS_1
0A88: 77 FD    INC   [X-3]         (0934)    mov  A,REG[UART_RX_CONTROL_REG]                         ; Get Status of RX
0A8A: 8F E4    JMP   0x0A6F        (0935)    push A
0A8C: 70 3F    AND   F,63
                                   (0936)    and  A,UART_RX_COMPLETE                                 ; Check if a character is ready
                                   (0937)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0A8E: 71 C0    OR    F,192         (0938)    pop  A
0A90: 7F       RET                 (0939)    jmp  .RX_NO_VALID_CHAR
                                   (0940) 
                                   (0941) .RX_DATA_RDY:
                                   (0942)    mov  A,REG[UART_RX_BUFFER_REG ]          
                                   (0943)    swap A,X                                                ; determine if data is valid
                                   (0944) 
                                   (0945)    pop  A                                                  ; Check for errors
                                   (0946)    and  A,(UART_RX_PARITY_ERROR | UART_RX_FRAMING_ERROR)
                                   (0947)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0948)    swap A,X                                                ; Put data in A and exit
                                   (0949)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0950)    ret
                                   (0951) 
                                   (0952) .RX_NO_VALID_CHAR:
                                   (0953)    mov A,0x00                                              ; Zero out character
                                   (0954) 
                                   (0955)  End_UART_cReadChar:
                                   (0956)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0957)    ret
                                   (0958) .ENDSECTION
                                   (0959) 
                                   (0960) 
                                   (0961) .SECTION
                                   (0962) ;-----------------------------------------------------------------------------
                                   (0963) ;  FUNCTION NAME: UART_iReadChar
                                   (0964) ;
                                   (0965) ;  WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0966) ;  to just set a value in the upper byte if error conditions exists.
                                   (0967) ;
                                   (0968) ;  DESCRIPTION:
                                   (0969) ;     Read character from UART RX port.
                                   (0970) ;-----------------------------------------------------------------------------
                                   (0971) ;
                                   (0972) ;  ARGUMENTS:
                                   (0973) ;      none
                                   (0974) ;
                                   (0975) ;  RETURNS:
                                   (0976) ;     An integer value is returned.  A negative value inplies and error
0A91: 4F       MOV   X,SP          (0977) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0978) ;
0A92: 3D FA 00 CMP   [X-6],0       (0979) ;     Error Codes:
0A95: B0 06    JNZ   0x0A9C        (0980) ;        0x80CC    Parity Error
0A97: 3D FB 00 CMP   [X-5],0       (0981) ;        0x40CC    Overrun Error
0A9A: A0 1D    JZ    0x0AB8        (0982) ;        0x20CC    Framing Error
                                   (0983) ;        0x01CC    No Data available
                                   (0984) ;
0A9C: 10       PUSH  X             (0985) ;  SIDE EFFECTS:
0A9D: 52 FC    MOV   A,[X-4]       (0986) ;    The A and X registers may be modified by this or future implementations
0A9F: 59 FD    MOV   X,[X-3]       (0987) ;    of this function.  The same is true for all RAM page pointer registers in
0AA1: 28       ROMX                (0988) ;    the Large Memory Model.  When necessary, it is the calling function's
0AA2: 49 4B 10 TST   REG[75],16
0AA5: AF FC    JZ    0x0AA2        (0989) ;    responsibility to perserve their values across calls to fastcall16 
0AA7: 60 49    MOV   REG[73],A
0AA9: 20       POP   X             (0990) ;    functions.
0AAA: 07 FD 01 ADD   [X-3],1       (0991) ;
0AAD: 0F FC 00 ADC   [X-4],0       (0992)  UART_iReadChar:
0AB0: 17 FB 01 SUB   [X-5],1       (0993) _UART_iReadChar:
0AB3: 1F FA 00 SBB   [X-6],0       (0994)    RAM_PROLOGUE RAM_USE_CLASS_1
0AB6: 8F DB    JMP   0x0A92        (0995)    mov  A,REG[UART_RX_CONTROL_REG]                         ; Get Status of RX
0AB8: 70 3F    AND   F,63
                                   (0996)                                                            ; Mask only errors and data ready
                                   (0997)    and  A,(UART_RX_ERROR|UART_RX_REG_FULL)
0ABA: 71 C0    OR    F,192         (0998)    push A
0ABC: 7F       RET                 (0999)    and  A,UART_RX_COMPLETE                                 ; Check if a character is ready
                                   (1000)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (1001)    pop  A
                                   (1002)    or   A,UART_RX_NO_DATA                                  ; Add no data flag
                                   (1003)    swap A,X
                                   (1004)    jmp  End_UART_iReadChar
                                   (1005) 
                                   (1006) .RX_GET_DATA:
                                   (1007)    pop  A
                                   (1008)    and  A,UART_RX_ERROR
                                   (1009)    swap A,X
                                   (1010)    mov  A,REG[UART_RX_BUFFER_REG ]                         ; Read data first, then
                                   (1011)                                                            ; determine if data is valid
                                   (1012) 
                                   (1013)  End_UART_iReadChar:
                                   (1014)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1015)    ret
                                   (1016) .ENDSECTION
                                   (1017) 
                                   (1018) 
                                   (1019) .SECTION
                                   (1020) ;-----------------------------------------------------------------------------
                                   (1021) ;  FUNCTION NAME: UART_PutString
                                   (1022) ;
                                   (1023) ;  DESCRIPTION:
                                   (1024) ;     Send String out through UART TX port.
                                   (1025) ;-----------------------------------------------------------------------------
                                   (1026) ;
                                   (1027) ;  ARGUMENTS:
                                   (1028) ;     Pointer to String
0ABD: 08       PUSH  A             (1029) ;     A has MSB of string address
0ABE: 10       PUSH  X             (1030) ;     X has LSB of string address
0ABF: 28       ROMX                (1031) ;
0AC0: A0 0B    JZ    0x0ACC        (1032) ;  RETURNS:
0AC2: 9F 56    CALL  0x0A1A        (1033) ;     none
0AC4: 20       POP   X             (1034) ;
0AC5: 18       POP   A             (1035) ;  SIDE EFFECTS:
0AC6: 75       INC   X             (1036) ;    The A and X registers may be modified by this or future implementations
0AC7: DF F5    JNC   0x0ABD        (1037) ;    of this function.  The same is true for all RAM page pointer registers in
0AC9: 74       INC   A             (1038) ;    the Large Memory Model.  When necessary, it is the calling function's
0ACA: 8F F2    JMP   0x0ABD        (1039) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1040) ;    functions.
                                   (1041) ;          
                                   (1042) ;    Currently only the page pointer registers listed below are modified: 
0ACC: 38 FE    ADD   SP,254        (1043) ;          IDX_PP
                                   (1044) ;
0ACE: 7F       RET                 (1045)  UART_PutString:
                                   (1046) _UART_PutString:
                                   (1047)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (1048)    RAM_SETPAGE_IDX A
                                   (1049) .PutStringLoop:
                                   (1050)    mov   A,[X]                                   ; Get value pointed to by X
                                   (1051)    jz    End_PutString                           ; Check for end of string
                                   (1052)    call  UART_PutChar                            ; Send character to Tx port
                                   (1053)    inc   X                                       ; Advance pointer to next character
                                   (1054)    jmp   .PutStringLoop                          ; Get next character
                                   (1055) 
                                   (1056) End_PutString:
                                   (1057)    RAM_EPILOGUE RAM_USE_CLASS_3
                                   (1058)    ret
                                   (1059) .ENDSECTION
                                   (1060)     
                                   (1061) .SECTION
                                   (1062) ;-----------------------------------------------------------------------------
                                   (1063) ;  FUNCTION NAME: UART_Write
                                   (1064) ;
                                   (1065) ;  DESCRIPTION:
                                   (1066) ;     Send String of length X to serial port
                                   (1067) ;-----------------------------------------------------------------------------
                                   (1068) ;
                                   (1069) ;  ARGUMENTS:
                                   (1070) ;     Pointer to String
                                   (1071) ;     [SP-5] Count of characters to send
                                   (1072) ;     [SP-4] has MSB of string address
0ACF: 50 0D    MOV   A,13          (1073) ;     [SP-3] has LSB of string address
0AD1: 9F 47    CALL  0x0A1A        (1074) ;
0AD3: 50 0A    MOV   A,10          (1075) ;  RETURNS:
0AD5: 9F 43    CALL  0x0A1A        (1076) ;     none
                                   (1077) ;
0AD7: 7F       RET                 (1078) ;  SIDE EFFECTS:
                                   (1079) ;    The A and X registers may be modified by this or future implementations
                                   (1080) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1081) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1082) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1083) ;    functions.
                                   (1084) ;          
                                   (1085) ;    Currently only the page pointer registers listed below are modified: 
                                   (1086) ;          IDX_PP
                                   (1087) ;
                                   (1088) CNT_LEN:    equ -5                               ; Length of data to send
                                   (1089) STR_MSB:    equ -4                               ; MSB pointer of string 
                                   (1090) STR_LSB:    equ -3                               ; LSB pointer of string 
                                   (1091) 
                                   (1092)  UART_Write:
                                   (1093) _UART_Write:
                                   (1094)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (1095)    RAM_SETPAGE_IDX2STK                           ; Refer indexed addrs to the stack
                                   (1096)    mov   X, SP                                   ; Establish the frame pointer 
                                   (1097) 
                                   (1098) .NextByteLoop:
                                   (1099)    mov   A, [X+CNT_LEN]                          ; End of the string?
                                   (1100)    jz    .End_Write                              ;   Yes, prepare to exit
                                   (1101)    dec   [X+CNT_LEN]                             ; Decrement counter
                                   (1102) 
                                   (1103)    IF SYSTEM_LARGE_MEMORY_MODEL
                                   (1104)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
                                   (1105)    ENDIF
                                   (1106) 
                                   (1107)    mov   X, [X+STR_LSB]                          ; Load pointer to char to send
                                   (1108)    RAM_SETPAGE_IDX A                             ; switch index pages
                                   (1109)    mov   A, [X]                                  ; Grab the data
                                   (1110)    InLinePutChar A                               ; Put data in empty TX buf reg
                                   (1111)    mov   X, SP                                   ; Recover frame pointer
                                   (1112)    RAM_SETPAGE_IDX2STK                           ; Prepare for stack access
                                   (1113)    inc   [X+STR_LSB]                             ; Point to next byte, but do not
                                   (1114)    jmp   .NextByteLoop                           ;    cross RAM page boundary!
                                   (1115) 
                                   (1116) .End_Write:
                                   (1117)    RAM_EPILOGUE RAM_USE_CLASS_3
                                   (1118)    ret
                                   (1119) .ENDSECTION
                                   (1120)     
0AD8: 62 D0 01 MOV   REG[208],1    (1121) 
0ADB: 55 E0 00 MOV   [224],0       (1122) .SECTION
0ADE: 62 D0 00 MOV   REG[208],0    (1123) ;-----------------------------------------------------------------------------
0AE1: 55 01 00 MOV   [1],0         (1124) ;  FUNCTION NAME: UART_CWrite
0AE4: 26 00 00 AND   [0],0         (1125) ;
0AE7: 62 D0 02 MOV   REG[208],2    (1126) ;             WARNING WARNING NOT COMPLETE
0AEA: 55 EF 00 MOV   [g_xConf+2],0 (1127) ;
                                   (1128) ;  DESCRIPTION:
0AED: 7F       RET                 (1129) ;     Send String of length X to serial port
                                   (1130) ;-----------------------------------------------------------------------------
                                   (1131) ;
                                   (1132) ;  ARGUMENTS:
                                   (1133) ;     [SP-4] MSB of Count of character to send
                                   (1134) ;     [SP-3] LSB of Count of character to send
                                   (1135) ;     [SP-2] has MSB of string address
                                   (1136) ;     [SP-1] has LSB of string address
                                   (1137) ;
                                   (1138) ;  RETURNS:
                                   (1139) ;     none
                                   (1140) ;
                                   (1141) ;  SIDE EFFECTS:
                                   (1142) ;    The A and X registers may be modified by this or future implementations
                                   (1143) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1144) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1145) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1146) ;    functions.
                                   (1147) ;
                                   (1148) CLEN_MSB:   equ -6           ; MSB Length of data to send
                                   (1149) CLEN_LSB:   equ -5           ; LSB Length of data to send
                                   (1150) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (1151) CSTR_LSB:   equ -3           ; LSB pointer of string
                                   (1152) 
                                   (1153)  UART_CWrite:
                                   (1154) _UART_CWrite:
                                   (1155)    RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1156)    mov   X,SP
                                   (1157) .CW_Loop:
                                   (1158)    cmp   [X+CLEN_MSB],0x00                  ; Check for zero counter
                                   (1159)    jnz   .CW_WRITEIT
                                   (1160)    cmp   [X+CLEN_LSB],0x00
                                   (1161)    jz    .End_CWrite                        ; Leave if done
                                   (1162) 
                                   (1163) .CW_WRITEIT:                                
0AEE: 62 D0 00 MOV   REG[208],0    (1164)    push  X                                  ; Save frame pointer
0AF1: 51 00    MOV   A,[0]         (1165)    mov   A,[X+CSTR_MSB]
0AF3: 21 01    AND   A,1           (1166)    mov   X,[X+CSTR_LSB]
                                   (1167)    romx                                     ; Get character from ROM
0AF5: 7F       RET                 (1168)    InLinePutChar A                          ; Put data in empty TX buf reg
                                   (1169)    pop   X                                  ; Restore frame pointer
                                   (1170)    add   [X+CSTR_LSB],1                     ; Increment the string pointer
                                   (1171)    adc   [X+CSTR_MSB],0
                                   (1172)    sub   [X+CLEN_LSB],0x01                  ; Dec the counter
                                   (1173)    sbb   [X+CLEN_MSB],0x00
                                   (1174)    jmp   .CW_Loop
                                   (1175) 
                                   (1176) .End_CWrite:
                                   (1177)    RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1178)    ret
                                   (1179) .ENDSECTION
                                   (1180) 
                                   (1181) 
                                   (1182) .SECTION
                                   (1183) ;-----------------------------------------------------------------------------
                                   (1184) ;  FUNCTION NAME: UART_CPutString
                                   (1185) ;
                                   (1186) ;  DESCRIPTION:
                                   (1187) ;     Send String out through UART TX port.
                                   (1188) ;-----------------------------------------------------------------------------
                                   (1189) ;
                                   (1190) ;  ARGUMENTS:
                                   (1191) ;     Pointer to String
                                   (1192) ;     A has MSB of string address
                                   (1193) ;     X has LSB of string address
                                   (1194) ;
                                   (1195) ;  RETURNS:
                                   (1196) ;     none
                                   (1197) ;
                                   (1198) ;  SIDE EFFECTS:
                                   (1199) ;    The A and X registers may be modified by this or future implementations
                                   (1200) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1202) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1203) ;    functions.
                                   (1204) ;
                                   (1205)  UART_CPutString:
                                   (1206) _UART_CPutString:
                                   (1207)    RAM_PROLOGUE RAM_USE_CLASS_1
0AF6: 62 D0 00 MOV   REG[208],0    (1208)    push  A                                       ; Store ROM pointer
0AF9: 51 00    MOV   A,[0]         (1209)    push  X
0AFB: 21 F0    AND   A,240         (1210)    romx                                          ; Get character from ROM
0AFD: 26 00 0F AND   [0],15        (1211)    jz    .End_CPutString
                                   (1212)    call  UART_PutChar                            ; Print character
0B00: 7F       RET                 (1213)    pop   X
                                   (1214)    pop   A
                                   (1215)    inc   X                                       ; Inc LSB of pointer
                                   (1216)    jnc   UART_CPutString                         ; Check for carry
                                   (1217)    inc   A                                       ; Inc MSB of pointer
                                   (1218)    jmp   UART_CPutString
                                   (1219) 
                                   (1220) 
                                   (1221) .End_CPutString:
                                   (1222)    add   SP, -2
                                   (1223)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1224)    ret
                                   (1225) .ENDSECTION
                                   (1226) 
                                   (1227) 
                                   (1228) .SECTION
                                   (1229) ;-----------------------------------------------------------------------------
                                   (1230) ;  FUNCTION NAME: UART_PutCRLF
                                   (1231) ;
                                   (1232) ;  DESCRIPTION:
                                   (1233) ;     Send a CR and LF
                                   (1234) ;-----------------------------------------------------------------------------
                                   (1235) ;
                                   (1236) ;  ARGUMENTS:
                                   (1237) ;     none.
                                   (1238) ;
                                   (1239) ;  RETURNS:
                                   (1240) ;     none.
                                   (1241) ;
                                   (1242) ;  SIDE EFFECTS:
0B01: 62 D0 00 MOV   REG[208],0    (1243) ;    The A and X registers may be modified by this or future implementations
0B04: 51 01    MOV   A,[1]         (1244) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1245) ;    the Large Memory Model.  When necessary, it is the calling function's
0B06: 7F       RET                 (1246) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1247) ;    functions.
                                   (1248) ;
                                   (1249)  UART_PutCRLF:
                                   (1250) _UART_PutCRLF:
                                   (1251)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (1252)    mov  A,0x0D                        ; Send CR
                                   (1253)    call UART_PutChar
                                   (1254)    mov  A,0x0A                        ; Send LF
                                   (1255)    call UART_PutChar
                                   (1256)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1257)    ret
                                   (1258) .ENDSECTION
                                   (1259) 
                                   (1260) 
                                   (1261) IF (UART_RXBUF_ENABLE)
                                   (1262) ;=============================================================================
                                   (1263) ;=============================================================================
                                   (1264) ;
                                   (1265) ;     Command Buffer commands
                                   (1266) ;
                                   (1267) ;=============================================================================
                                   (1268) ;=============================================================================
                                   (1269) 
                                   (1270) .SECTION
                                   (1271) ;-----------------------------------------------------------------------------
                                   (1272) ;  FUNCTION NAME: UART_CmdReset
                                   (1273) ;
                                   (1274) ;  DESCRIPTION:
                                   (1275) ;     Reset command string and status flags
                                   (1276) ;-----------------------------------------------------------------------------
                                   (1277) ;
                                   (1278) ;  ARGUMENTS:
                                   (1279) ;     none.
                                   (1280) ;
                                   (1281) ;  RETURNS:
                                   (1282) ;     none.
                                   (1283) ;
                                   (1284) ;  SIDE EFFECTS:
                                   (1285) ;    The A and X registers may be modified by this or future implementations
                                   (1286) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1287) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1288) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1289) ;    functions.
                                   (1290) ;          
                                   (1291) ;    Currently only the page pointer registers listed below are modified: 
                                   (1292) ;          CUR_PP
                                   (1293) ;
                                   (1294) ;  THEORY of OPERATION or PROCEDURE:
                                   (1295) ;     Clear the command buffer, command counter, and flag.
                                   (1296) ;
                                   (1297)  UART_CmdReset:
                                   (1298) _UART_CmdReset:
                                   (1299)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1300)    RAM_SETPAGE_CUR >UART_aRxBuffer
0B07: 70 BF    AND   F,191         (1301)    mov [UART_aRxBuffer], 0x00
                                   (1302)    RAM_SETPAGE_CUR >UART_bRxCnt
0B09: 62 D0 02 MOV   REG[208],2    (1303)    mov [UART_bRxCnt], 0x00
0B0C: 50 E0    MOV   A,224         (1304)    and [UART_fStatus], 0x00
0B0E: 02 EF    ADD   A,[g_xConf+2] (1305)    RAM_SETPAGE_CUR >ptrParam
0B10: 5C       MOV   X,A           (1306)    mov [ptrParam],0x00
0B11: 62 D3 01 MOV   REG[211],1    (1307)    RAM_EPILOGUE RAM_USE_CLASS_4
0B14: 52 00    MOV   A,[X+0]       (1308)    ret
0B16: B0 04    JNZ   0x0B1B        (1309) .ENDSECTION
0B18: 10       PUSH  X             (1310) 
0B19: 80 33    JMP   0x0B4D        (1311) 
                                   (1312) .SECTION
                                   (1313) ;-----------------------------------------------------------------------------
                                   (1314) ;  FUNCTION NAME: UART_bCmdCheck
0B1B: 39 20    CMP   A,32          (1315) ;
0B1D: B0 11    JNZ   0x0B2F        (1316) ;  DESCRIPTION:
0B1F: 75       INC   X             (1317) ;     Check to see if valid command in buffer.
0B20: 76 EF    INC   [g_xConf+2]   (1318) ;-----------------------------------------------------------------------------
0B22: 52 00    MOV   A,[X+0]       (1319) ;
0B24: 3C EF 1F CMP   [g_xConf+2],31(1320) ;  ARGUMENTS:
0B27: BF F3    JNZ   0x0B1B        (1321) ;     none.
                                   (1322) ;
                                   (1323) ;  RETURNS:
0B29: 10       PUSH  X             (1324) ;     BYTE  fStatus - Status of command receive buffer.
                                   (1325) ;                     Returns non-zero value in A if command is valid.
0B2A: 56 00 00 MOV   [X+0],0       (1326) ;
0B2D: 80 1F    JMP   0x0B4D        (1327) ;  SIDE EFFECTS:
                                   (1328) ;    The A and X registers may be modified by this or future implementations
                                   (1329) ;    of this function.  The same is true for all RAM page pointer registers in
0B2F: 10       PUSH  X             (1330) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1331) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1332) ;    functions.
0B30: 75       INC   X             (1333) ;          
0B31: 76 EF    INC   [g_xConf+2]   (1334) ;    Currently only the page pointer registers listed below are modified: 
0B33: 3C EF 1F CMP   [g_xConf+2],31(1335) ;          CUR_PP
0B36: AF F3    JZ    0x0B2A        (1336) ;
0B38: 52 00    MOV   A,[X+0]       (1337) ;  THEORY of OPERATION or PROCEDURE:
0B3A: A0 12    JZ    0x0B4D        (1338) ;     Read the status and control register.
0B3C: 39 20    CMP   A,32          (1339) ;
0B3E: BF F1    JNZ   0x0B30        (1340)  UART_bCmdCheck:
0B40: 56 00 00 MOV   [X+0],0       (1341) _UART_bCmdCheck:
0B43: 76 EF    INC   [g_xConf+2]   (1342)    RAM_PROLOGUE RAM_USE_CLASS_4
0B45: 3C EF 1F CMP   [g_xConf+2],31(1343)    RAM_SETPAGE_CUR >UART_fStatus
0B48: B0 04    JNZ   0x0B4D        (1344)    mov A,  [UART_fStatus]
0B4A: 55 EF 1F MOV   [g_xConf+2],31(1345)    and A, UART_RX_BUF_CMDTERM                    ; Mask off Command status
                                   (1346)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1347)    ret
0B4D: 20       POP   X             (1348) .ENDSECTION
0B4E: 10       PUSH  X             (1349)     
0B4F: 3D 00 00 CMP   [X+0],0       (1350) 
0B52: B0 0B    JNZ   0x0B5E        (1351) .SECTION
0B54: 20       POP   X             (1352) ;-----------------------------------------------------------------------------
0B55: 57 00    MOV   X,0           (1353) ;  FUNCTION NAME: UART_bErrCheck
0B57: 50 01    MOV   A,1           (1354) ;
0B59: 70 3F    AND   F,63
0B5B: 71 C0    OR    F,192         (1355) ;  DESCRIPTION:
                                   (1356) ;     Check to see if an error has occured since last CmdReset
0B5D: 7F       RET                 (1357) ;-----------------------------------------------------------------------------
                                   (1358) ;
                                   (1359) ;  ARGUMENTS:
0B5E: 20       POP   X             (1360) ;     none.
0B5F: 50 01    MOV   A,1           (1361) ;
0B61: 70 3F    AND   F,63
0B63: 71 C0    OR    F,192         (1362) ;  RETURNS:
                                   (1363) ;     BYTE  fStatus - Status of command receive buffer.
0B65: 7F       RET                 (1364) ;                     Returns non-zero value in A if command is valid.
                                   (1365) ;           0x80 => Parity Error
                                   (1366) ;           0x40 => OverRun Error
                                   (1367) ;           0x20 => Framing Error
                                   (1368) ;           0x10 => Software Buffer OverRun
                                   (1369) ;
                                   (1370) ;  SIDE EFFECTS:
                                   (1371) ;    The A and X registers may be modified by this or future implementations
                                   (1372) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1373) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1374) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1375) ;    functions.
                                   (1376) ;          
                                   (1377) ;    Currently only the page pointer registers listed below are modified: 
                                   (1378) ;          CUR_PP
                                   (1379) ;     Error Status is clear when read.
                                   (1380) ;
                                   (1381) ;  THEORY of OPERATION or PROCEDURE:
                                   (1382) ;     Read RX buffer error status and clear status
                                   (1383) ;
                                   (1384)  UART_bErrCheck:
                                   (1385) _UART_bErrCheck:
                                   (1386)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1387)    RAM_SETPAGE_CUR >UART_fStatus
                                   (1388)    mov A,  [UART_fStatus]
                                   (1389)    and A, UART_RX_BUF_ERROR                      ; Mask off Error status
                                   (1390)    and [UART_fStatus], ~UART_RX_BUF_ERROR
                                   (1391)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1392)    ret
                                   (1393) .ENDSECTION
                                   (1394) 
0B66: 62 D0 02 MOV   REG[208],2    (1395) .SECTION
0B69: 50 E0    MOV   A,224         (1396) ;-----------------------------------------------------------------------------
0B6B: 02 EF    ADD   A,[g_xConf+2] (1397) ;  FUNCTION NAME: UART_bCmdLength
0B6D: 5C       MOV   X,A           (1398) ;
0B6E: 50 01    MOV   A,1           (1399) ;  DESCRIPTION:
                                   (1400) ;     Get length of command string
0B72: 43 E1 10 OR    REG[225],16   (1401) ;-----------------------------------------------------------------------------

FILE: lib\timer16_delay.asm
                                   (0102) ;;*****************************************************************************
0B75: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: Timer16_Delay.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/6/24 at 12:17:24
                                   (0106) ;;  Generated by PSoC Designer 5.0.972.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "Timer16_Delay.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
0B76: 41 E1 EF AND   REG[225],239  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
0B79: 7F       RET                 (0131) export  Timer16_Delay_EnableInt
                                   (0132) export _Timer16_Delay_EnableInt
                                   (0133) export  Timer16_Delay_DisableInt
                                   (0134) export _Timer16_Delay_DisableInt
                                   (0135) export  Timer16_Delay_Start
                                   (0136) export _Timer16_Delay_Start
                                   (0137) export  Timer16_Delay_Stop
                                   (0138) export _Timer16_Delay_Stop
                                   (0139) export  Timer16_Delay_WritePeriod
                                   (0140) export _Timer16_Delay_WritePeriod
                                   (0141) export  Timer16_Delay_WriteCompareValue
                                   (0142) export _Timer16_Delay_WriteCompareValue
                                   (0143) export  Timer16_Delay_wReadCompareValue
                                   (0144) export _Timer16_Delay_wReadCompareValue
                                   (0145) export  Timer16_Delay_wReadTimer
                                   (0146) export _Timer16_Delay_wReadTimer
                                   (0147) export  Timer16_Delay_wReadTimerSaveCV
                                   (0148) export _Timer16_Delay_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wTimer16_Delay_ReadCompareValue  ; deprecated
                                   (0153) export _wTimer16_Delay_ReadCompareValue  ; deprecated
                                   (0154) export  wTimer16_Delay_ReadTimer         ; deprecated
                                   (0155) export _wTimer16_Delay_ReadTimer         ; deprecated
                                   (0156) export  wTimer16_Delay_ReadTimerSaveCV   ; deprecated
0B7A: 43 2F 01 OR    REG[47],1     (0157) export _wTimer16_Delay_ReadTimerSaveCV   ; deprecated
                                   (0158) 
0B7D: 7F       RET                 (0159) export  wTimer16_Delay_ReadCounter       ; obsolete
                                   (0160) export _wTimer16_Delay_ReadCounter       ; obsolete
                                   (0161) export  wTimer16_Delay_CaptureCounter    ; obsolete
                                   (0162) export _wTimer16_Delay_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA sark100_swranalyzer_bl_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: Timer16_Delay_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
0B7E: 41 2F FE AND   REG[47],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
0B81: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  Timer16_Delay_EnableInt:
                                   (0200) _Timer16_Delay_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    Timer16_Delay_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: Timer16_Delay_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
0B82: 60 2D    MOV   REG[45],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
0B84: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
0B85: 60 31    MOV   REG[49],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
0B87: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  Timer16_Delay_DisableInt:
                                   (0228) _Timer16_Delay_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    Timer16_Delay_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: Timer16_Delay_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
0B88: 60 2E    MOV   REG[46],A     (0246) ;  ARGUMENTS:    None
0B8A: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
0B8B: 60 32    MOV   REG[50],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
0B8D: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  Timer16_Delay_Start:
                                   (0256) _Timer16_Delay_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    Timer16_Delay_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: Timer16_Delay_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
0B8E: 5D 32    MOV   A,REG[50]     (0277) ;    The A and X registers may be modified by this or future implementations
0B90: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
0B91: 5D 2E    MOV   A,REG[46]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
0B93: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  Timer16_Delay_Stop:
                                   (0284) _Timer16_Delay_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    Timer16_Delay_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: Timer16_Delay_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  Timer16_Delay_WritePeriod:
                                   (0313) _Timer16_Delay_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[Timer16_Delay_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[Timer16_Delay_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: Timer16_Delay_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call Timer16_Delay_Stop to disable).
0B94: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
0B95: 38 03    ADD   SP,3          (0334) ;
0B97: 5D 2F    MOV   A,REG[47]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
0B99: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
0B9A: 5D 2E    MOV   A,REG[46]     (0337) ;  SIDE EFFECTS: 
0B9C: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
0B9D: 5D 32    MOV   A,REG[50]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
0B9F: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
0BA0: 5D 2C    MOV   A,REG[44]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
0BA2: 5D 32    MOV   A,REG[50]     (0343) ;
0BA4: 54 01    MOV   [X+1],A       (0344)  Timer16_Delay_WriteCompareValue:
0BA6: 5D 2E    MOV   A,REG[46]     (0345) _Timer16_Delay_WriteCompareValue:
0BA8: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
0BAA: 50 00    MOV   A,0           (0347)    mov   reg[Timer16_Delay_COMPARE_LSB_REG], A
0BAC: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
0BAF: A0 03    JZ    0x0BB3        (0349)    mov   reg[Timer16_Delay_COMPARE_MSB_REG], A
0BB1: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
0BB3: 54 00    MOV   [X+0],A       (0352) 
0BB5: 70 FE    AND   F,254         (0353) .ENDSECTION
0BB7: 41 2F FE AND   REG[47],254   (0354) 
0BBA: 18       POP   A             (0355) 
0BBB: 60 32    MOV   REG[50],A     (0356) .SECTION
0BBD: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
0BBE: 60 2E    MOV   REG[46],A     (0358) ;  FUNCTION NAME: Timer16_Delay_wReadCompareValue
0BC0: 18       POP   A             (0359) ;
0BC1: 60 2F    MOV   REG[47],A     (0360) ;  DESCRIPTION:
0BC3: 18       POP   A             (0361) ;     Reads the Compare registers.
0BC4: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
0BC5: 70 3F    AND   F,63
0BC7: 71 C0    OR    F,192         (0363) ;
0BC9: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  Timer16_Delay_wReadCompareValue:
                                   (0374) _Timer16_Delay_wReadCompareValue:
                                   (0375)  wTimer16_Delay_ReadCompareValue:                ; this name deprecated
                                   (0376) _wTimer16_Delay_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[Timer16_Delay_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[Timer16_Delay_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: Timer16_Delay_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
0BCA: 5D 2C    MOV   A,REG[44]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
0BCC: 5D 32    MOV   A,REG[50]     (0408) ;        functions.
0BCE: 5C       MOV   X,A           (0409) ;
0BCF: 5D 2E    MOV   A,REG[46]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
0BD3: 43 E1 20 OR    REG[225],32   (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\pwm8_buzz.asm
                                   (0095) ;;*****************************************************************************
0BD6: 7F       RET                 (0096) ;;*****************************************************************************
                                   (0097) ;;  FILENAME: PWM8_BUZZ.asm
                                   (0098) ;;   Version: 2.5, Updated on 2009/6/24 at 12:16:54
                                   (0099) ;;  Generated by PSoC Designer 5.0.972.0
                                   (0100) ;;
                                   (0101) ;;  DESCRIPTION: PWM8 User Module software implementation file
                                   (0102) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0103) ;;
                                   (0104) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0105) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0106) ;;        This means it is the caller's responsibility to preserve any values
                                   (0107) ;;        in the X and A registers that are still needed after the API functions
                                   (0108) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0109) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0110) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0111) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0112) ;;-----------------------------------------------------------------------------
                                   (0113) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0114) ;;*****************************************************************************
                                   (0115) ;;*****************************************************************************
                                   (0116) 
                                   (0117) include "m8c.inc"
                                   (0118) include "PWM8_BUZZ.inc"
                                   (0119) include "memory.inc"
                                   (0120) 
                                   (0121) ;-----------------------------------------------
0BD7: 41 E1 DF AND   REG[225],223  (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0BDA: 7F       RET                 (0124) export  PWM8_BUZZ_EnableInt
                                   (0125) export _PWM8_BUZZ_EnableInt
                                   (0126) export  PWM8_BUZZ_DisableInt
                                   (0127) export _PWM8_BUZZ_DisableInt
                                   (0128) export  PWM8_BUZZ_Start
                                   (0129) export _PWM8_BUZZ_Start
                                   (0130) export  PWM8_BUZZ_Stop
                                   (0131) export _PWM8_BUZZ_Stop
                                   (0132) export  PWM8_BUZZ_WritePeriod
                                   (0133) export _PWM8_BUZZ_WritePeriod
                                   (0134) export  PWM8_BUZZ_WritePulseWidth
                                   (0135) export _PWM8_BUZZ_WritePulseWidth
                                   (0136) export  PWM8_BUZZ_bReadPulseWidth
                                   (0137) export _PWM8_BUZZ_bReadPulseWidth
                                   (0138) export  PWM8_BUZZ_bReadCounter
                                   (0139) export _PWM8_BUZZ_bReadCounter
                                   (0140) 
                                   (0141) ; The following functions are deprecated and subject to omission in future releases
                                   (0142) ;
                                   (0143) export  bPWM8_BUZZ_ReadPulseWidth    ; deprecated
                                   (0144) export _bPWM8_BUZZ_ReadPulseWidth    ; deprecated
                                   (0145) export  bPWM8_BUZZ_ReadCounter       ; deprecated
                                   (0146) export _bPWM8_BUZZ_ReadCounter       ; deprecated
                                   (0147) 
                                   (0148) 
                                   (0149) AREA sark100_swranalyzer_bl_RAM (RAM,REL)
                                   (0150) 
0BDB: 43 37 01 OR    REG[55],1     (0151) ;-----------------------------------------------
                                   (0152) ;  Constant Definitions
0BDE: 7F       RET                 (0153) ;-----------------------------------------------
                                   (0154) 
                                   (0155) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                   (0156) 
                                   (0157) 
                                   (0158) ;-----------------------------------------------
                                   (0159) ; Variable Allocation
                                   (0160) ;-----------------------------------------------
                                   (0161) 
                                   (0162) 
                                   (0163) AREA UserModules (ROM, REL)
                                   (0164) 
                                   (0165) .SECTION
                                   (0166) ;-----------------------------------------------------------------------------
                                   (0167) ;  FUNCTION NAME: PWM8_BUZZ_EnableInt
                                   (0168) ;
                                   (0169) ;  DESCRIPTION:
                                   (0170) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                   (0171) ;     associated with this User Module. This function has no effect until and
                                   (0172) ;     unless the global interrupts are enabled (for example by using the
                                   (0173) ;     macro M8C_EnableGInt).
                                   (0174) ;-----------------------------------------------------------------------------
                                   (0175) ;
                                   (0176) ;  ARGUMENTS:    None.
                                   (0177) ;  RETURNS:      Nothing.
                                   (0178) ;  SIDE EFFECTS:
0BDF: 41 37 FE AND   REG[55],254   (0179) ;    The A and X registers may be modified by this or future implementations
                                   (0180) ;    of this function.  The same is true for all RAM page pointer registers in
0BE2: 7F       RET                 (0181) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0182) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0183) ;    functions.
                                   (0184) ;
                                   (0185)  PWM8_BUZZ_EnableInt:
                                   (0186) _PWM8_BUZZ_EnableInt:
                                   (0187)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0188)    PWM8_BUZZ_EnableInt_M
                                   (0189)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0190)    ret
                                   (0191) 
                                   (0192) 
                                   (0193) .ENDSECTION
                                   (0194) 
                                   (0195) .SECTION
                                   (0196) ;-----------------------------------------------------------------------------
                                   (0197) ;  FUNCTION NAME: PWM8_BUZZ_DisableInt
                                   (0198) ;
                                   (0199) ;  DESCRIPTION:
                                   (0200) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                   (0201) ;     mask bit associated with this User Module.
                                   (0202) ;-----------------------------------------------------------------------------
                                   (0203) ;
                                   (0204) ;  ARGUMENTS:    None
                                   (0205) ;  RETURNS:      Nothing
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
0BE3: 60 35    MOV   REG[53],A     (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0BE5: 7F       RET                 (0211) ;    functions.
                                   (0212) ;
                                   (0213)  PWM8_BUZZ_DisableInt:
                                   (0214) _PWM8_BUZZ_DisableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    PWM8_BUZZ_DisableInt_M
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) 
                                   (0220) 
                                   (0221) .ENDSECTION
                                   (0222) 
                                   (0223) .SECTION
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;  FUNCTION NAME: PWM8_BUZZ_Start
                                   (0226) ;
                                   (0227) ;  DESCRIPTION:
                                   (0228) ;     Sets the start bit in the Control register of this user module.  The
                                   (0229) ;     PWM will begin counting on the next input clock as soon as the
                                   (0230) ;     enable input is asserted high.
                                   (0231) ;-----------------------------------------------------------------------------
                                   (0232) ;
                                   (0233) ;  ARGUMENTS:    None
                                   (0234) ;  RETURNS:      Nothing
                                   (0235) ;  SIDE EFFECTS:
0BE6: 60 36    MOV   REG[54],A     (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
0BE8: 7F       RET                 (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0240) ;    functions.
                                   (0241) ;
                                   (0242)  PWM8_BUZZ_Start:
                                   (0243) _PWM8_BUZZ_Start:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    PWM8_BUZZ_Start_M
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) 
                                   (0249) 
                                   (0250) .ENDSECTION
                                   (0251) 
                                   (0252) .SECTION
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;  FUNCTION NAME: PWM8_BUZZ_Stop
                                   (0255) ;
                                   (0256) ;  DESCRIPTION:
                                   (0257) ;     Disables PWM operation by clearing the start bit in the Control
                                   (0258) ;     register.
                                   (0259) ;-----------------------------------------------------------------------------
                                   (0260) ;
                                   (0261) ;  ARGUMENTS:    None
                                   (0262) ;  RETURNS:      Nothing
                                   (0263) ;  SIDE EFFECTS:
                                   (0264) ;    The A and X registers may be modified by this or future implementations
0BE9: 5D 36    MOV   A,REG[54]     (0265) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0266) ;    the Large Memory Model.  When necessary, it is the calling function's
0BEB: 7F       RET                 (0267) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0268) ;    functions.
                                   (0269) ;
                                   (0270)  PWM8_BUZZ_Stop:
                                   (0271) _PWM8_BUZZ_Stop:
                                   (0272)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0273)    PWM8_BUZZ_Stop_M
                                   (0274)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0275)    ret
                                   (0276) 
                                   (0277) 
                                   (0278) .ENDSECTION
                                   (0279) 
                                   (0280) .SECTION
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;  FUNCTION NAME: PWM8_BUZZ_WritePeriod
                                   (0283) ;
                                   (0284) ;  DESCRIPTION:
                                   (0285) ;     Write the 8-bit period value into the Period register (DR1).
                                   (0286) ;-----------------------------------------------------------------------------
                                   (0287) ;
                                   (0288) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                   (0289) ;  RETURNS:   Nothing
                                   (0290) ;  SIDE EFFECTS:
                                   (0291) ;    If the PWM user module is stopped, then this value will also be
                                   (0292) ;    latched into the Count register (DR0).
                                   (0293) ;    
                                   (0294) ;    The A and X registers may be modified by this or future implementations
                                   (0295) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0296) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0297) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0298) ;    functions.
                                   (0299) ;
                                   (0300)  PWM8_BUZZ_WritePeriod:
                                   (0301) _PWM8_BUZZ_WritePeriod:
                                   (0302)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0303)    mov   reg[PWM8_BUZZ_PERIOD_REG], A
0BEC: 4F       MOV   X,SP          (0304)    RAM_EPILOGUE RAM_USE_CLASS_1
0BED: 5D 36    MOV   A,REG[54]     (0305)    ret
0BEF: 08       PUSH  A             (0306) 
0BF0: 41 37 FE AND   REG[55],254   (0307) 
0BF3: 71 10    OR    F,16          (0308) .ENDSECTION
0BF5: 5D 35    MOV   A,REG[53]     (0309) 
0BF7: 08       PUSH  A             (0310) .SECTION
                                   (0311) ;-----------------------------------------------------------------------------
0BF8: 62 35 00 MOV   REG[53],0     (0312) ;  FUNCTION NAME: PWM8_BUZZ_WritePulseWidth
0BFB: 70 EF    AND   F,239         (0313) ;
                                   (0314) ;  DESCRIPTION:
0BFD: 5D 34    MOV   A,REG[52]     (0315) ;     Writes compare value into the Compare register (DR2).
0BFF: 5D 36    MOV   A,REG[54]     (0316) ;-----------------------------------------------------------------------------
0C01: 08       PUSH  A             (0317) ;
0C02: 52 00    MOV   A,[X+0]       (0318) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
0C04: 60 36    MOV   REG[54],A     (0319) ;  RETURNS:      Nothing
0C06: 71 10    OR    F,16          (0320) ;  SIDE EFFECTS:
0C08: 52 01    MOV   A,[X+1]       (0321) ;    The A and X registers may be modified by this or future implementations
0C0A: 60 35    MOV   REG[53],A     (0322) ;    of this function.  The same is true for all RAM page pointer registers in
0C0C: 70 EF    AND   F,239         (0323) ;    the Large Memory Model.  When necessary, it is the calling function's
0C0E: 43 37 01 OR    REG[55],1     (0324) ;    responsibility to perserve their values across calls to fastcall16 
0C11: 18       POP   A             (0325) ;    functions.
0C12: 38 FE    ADD   SP,254        (0326) ;
0C14: 70 3F    AND   F,63
0C16: 71 C0    OR    F,192         (0327)  PWM8_BUZZ_WritePulseWidth:
0C19: 21 03    AND   A,3           (0328) _PWM8_BUZZ_WritePulseWidth:

FILE: lib\pga_dds_2.asm
0C1B: 4F       MOV   X,SP          (0110) ;;*****************************************************************************
                                   (0111) ;;*****************************************************************************
0C1C: 08       PUSH  A             (0112) ;;  FILENAME:   PGA_DDS_2.asm  ( PGA )
0C1D: 5D 7B    MOV   A,REG[123]    (0113) ;;  Version: 3.2, Updated on 2009/6/23 at 19:34:6
0C1F: 21 FC    AND   A,252         (0114) ;;  Generated by PSoC Designer 5.0.972.0
0C21: 2B 00    OR    A,[X+0]       (0115) ;;
0C23: 60 7B    MOV   REG[123],A    (0116) ;;  DESCRIPTION:  PGA User Module software implementation file for the
0C25: 18       POP   A             (0117) ;;                22/24/27/29xxx PSoC family of devices.
0C26: 70 3F    AND   F,63
0C28: 71 C0    OR    F,192         (0118) ;;
0C2A: 7F       RET                 (0119) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0120) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0121) ;;        This means it is the caller's responsibility to preserve any values
                                   (0122) ;;        in the X and A registers that are still needed after the API functions
                                   (0123) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0124) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0125) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0126) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0127) ;;-----------------------------------------------------------------------------
                                   (0128) ;;  Copyright (c) Cypress MicroSystems 2004. All Rights Reserved.
                                   (0129) ;;*****************************************************************************
                                   (0130) ;;*****************************************************************************
                                   (0131) 
                                   (0132) ;; -----------------------------------------------------------------
                                   (0133) ;;                         Register Definitions
                                   (0134) ;;
                                   (0135) ;; Uses 1 Continuous Time Block configured as shown.
                                   (0136) ;;
                                   (0137) ;; * For a Mask/Val pair, this indicates that the value is
                                   (0138) ;;   determined by the user either through config-time parameteriza-
                                   (0139) ;;   tion or run-time manipulation.
                                   (0140) ;;
                                   (0141) ;; BIT FIELD             Mask/Val Function
                                   (0142) ;; -----------------            -----   --------------------
                                   (0143) ;; GAIN_CR0.RES_RATIO_T2B       F0/*    User Parameter (by table)
                                   (0144) ;; GAIN_CR0.GAIN_ATTEN          08/*    Gain (by table)
                                   (0145) ;; GAIN_CR0.RES_SOURCE          04/1    Res source to output
                                   (0146) ;; GAIN_CR0.RES_REF             03/*    Res ref
                                   (0147) ;;
                                   (0148) ;; GAIN_CR1.A_OUT               80/*    User Parameter (Output bus)
                                   (0149) ;; GAIN_CR1.COMP_EN             40/0    Comparator bus disabled
0C2B: 21 FC    AND   A,252         (0150) ;; GAIN_CR1.CT_NEG_INPUT_MUX    38/4    Neg mux to analog f.b. tap
0C2D: 4F       MOV   X,SP          (0151) ;; GAIN_CR1.CT_POS_INPUT_MUX    07/*    Pos mux, typically to col. input mux
                                   (0152) ;;
0C2E: 08       PUSH  A             (0153) ;; GAIN_CR2.CP_COMP             80/0    Latch transparent on PH1
0C2F: 5D 79    MOV   A,REG[121]    (0154) ;; GAIN_CR2.CK_COMP             40/0    Latch transparent
0C31: 21 07    AND   A,7           (0155) ;; GAIN_CR2.CC_COMP             20/1    Mode OP-AMP (not comparator)
0C33: 48 00 04 TST   [X+0],4       (0156) ;; GAIN_CR2.BYPASS_OBUS         1C/0    Bypass OFF
0C36: B0 0E    JNZ   0x0C45        (0157) ;; GAIN_CR2.PWR_SELECT          03/*    Power OFF (0h) at start-up
0C38: 41 78 FE AND   REG[120],254  (0158) ;;
0C3B: 2B 00    OR    A,[X+0]       (0159) ;; --------------------------------------------------------------------
0C3D: 60 79    MOV   REG[121],A    (0160) 
0C3F: 18       POP   A             (0161) include "PGA_DDS_2.inc"
0C40: 70 3F    AND   F,63
0C42: 71 C0    OR    F,192         (0162) include "m8c.inc"
0C44: 7F       RET                 (0163) include "memory.inc"
                                   (0164) 
                                   (0165) 
0C45: 27 00 18 AND   [X+0],24      (0166) ;-----------------------------------------------
0C48: 2B 00    OR    A,[X+0]       (0167) ;  Global Symbols
0C4A: 60 79    MOV   REG[121],A    (0168) ;-----------------------------------------------
0C4C: 43 78 01 OR    REG[120],1    (0169) export  PGA_DDS_2_Start
0C4F: 18       POP   A             (0170) export _PGA_DDS_2_Start
0C50: 70 3F    AND   F,63
0C52: 71 C0    OR    F,192         (0171) export  PGA_DDS_2_SetPower
0C54: 7F       RET                 (0172) export _PGA_DDS_2_SetPower
                                   (0173) 
                                   (0174) export  PGA_DDS_2_SetGain
                                   (0175) export _PGA_DDS_2_SetGain
                                   (0176) 
                                   (0177) export  PGA_DDS_2_Stop
                                   (0178) export _PGA_DDS_2_Stop
                                   (0179) 
                                   (0180) ;-----------------------------------------------
                                   (0181) ;  EQUATES
                                   (0182) ;-----------------------------------------------
                                   (0183) POWERMASK:     equ 03h
                                   (0184) GAINREGMASK:   equ f8h
                                   (0185) GAINMASK:      equ fCh
                                   (0186) HIGHGAIN:      equ 04h
                                   (0187) HIGHGAINMASK:  equ 18h
                                   (0188) EXGAIN:        equ 01h
                                   (0189) 
                                   (0190) AREA UserModules (ROM, REL)
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: PGA_DDS_2_Start
                                   (0194) ;  FUNCTION NAME: PGA_DDS_2_SetPower
                                   (0195) ;
                                   (0196) ;  DESCRIPTION:
                                   (0197) ;    Applies power setting to the module's PSoC block.
                                   (0198) ;-----------------------------------------------------------------------------
0C55: 41 7B FC AND   REG[123],252  (0199) ;
                                   (0200) ;  ARGUMENTS:
0C59: 21 03    AND   A,3           (0201) ;  A  Contains the power settings 0=Off, 1=Low, 2=Med, and 3=High

FILE: lib\pga_dds_1.asm
0C5B: 4F       MOV   X,SP          (0110) ;;*****************************************************************************
                                   (0111) ;;*****************************************************************************
0C5C: 08       PUSH  A             (0112) ;;  FILENAME:   PGA_DDS_1.asm  ( PGA )
0C5D: 5D 7F    MOV   A,REG[127]    (0113) ;;  Version: 3.2, Updated on 2009/6/23 at 19:34:6
0C5F: 21 FC    AND   A,252         (0114) ;;  Generated by PSoC Designer 5.0.972.0
0C61: 2B 00    OR    A,[X+0]       (0115) ;;
0C63: 60 7F    MOV   REG[127],A    (0116) ;;  DESCRIPTION:  PGA User Module software implementation file for the
0C65: 18       POP   A             (0117) ;;                22/24/27/29xxx PSoC family of devices.
0C66: 70 3F    AND   F,63
0C68: 71 C0    OR    F,192         (0118) ;;
0C6A: 7F       RET                 (0119) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0120) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0121) ;;        This means it is the caller's responsibility to preserve any values
                                   (0122) ;;        in the X and A registers that are still needed after the API functions
                                   (0123) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0124) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0125) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0126) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0127) ;;-----------------------------------------------------------------------------
                                   (0128) ;;  Copyright (c) Cypress MicroSystems 2004. All Rights Reserved.
                                   (0129) ;;*****************************************************************************
                                   (0130) ;;*****************************************************************************
                                   (0131) 
                                   (0132) ;; -----------------------------------------------------------------
                                   (0133) ;;                         Register Definitions
                                   (0134) ;;
                                   (0135) ;; Uses 1 Continuous Time Block configured as shown.
                                   (0136) ;;
                                   (0137) ;; * For a Mask/Val pair, this indicates that the value is
                                   (0138) ;;   determined by the user either through config-time parameteriza-
                                   (0139) ;;   tion or run-time manipulation.
                                   (0140) ;;
                                   (0141) ;; BIT FIELD             Mask/Val Function
                                   (0142) ;; -----------------            -----   --------------------
                                   (0143) ;; GAIN_CR0.RES_RATIO_T2B       F0/*    User Parameter (by table)
                                   (0144) ;; GAIN_CR0.GAIN_ATTEN          08/*    Gain (by table)
                                   (0145) ;; GAIN_CR0.RES_SOURCE          04/1    Res source to output
                                   (0146) ;; GAIN_CR0.RES_REF             03/*    Res ref
                                   (0147) ;;
                                   (0148) ;; GAIN_CR1.A_OUT               80/*    User Parameter (Output bus)
                                   (0149) ;; GAIN_CR1.COMP_EN             40/0    Comparator bus disabled
0C6B: 21 FC    AND   A,252         (0150) ;; GAIN_CR1.CT_NEG_INPUT_MUX    38/4    Neg mux to analog f.b. tap
0C6D: 4F       MOV   X,SP          (0151) ;; GAIN_CR1.CT_POS_INPUT_MUX    07/*    Pos mux, typically to col. input mux
                                   (0152) ;;
0C6E: 08       PUSH  A             (0153) ;; GAIN_CR2.CP_COMP             80/0    Latch transparent on PH1
0C6F: 5D 7D    MOV   A,REG[125]    (0154) ;; GAIN_CR2.CK_COMP             40/0    Latch transparent
0C71: 21 07    AND   A,7           (0155) ;; GAIN_CR2.CC_COMP             20/1    Mode OP-AMP (not comparator)
0C73: 48 00 04 TST   [X+0],4       (0156) ;; GAIN_CR2.BYPASS_OBUS         1C/0    Bypass OFF
0C76: B0 0E    JNZ   0x0C85        (0157) ;; GAIN_CR2.PWR_SELECT          03/*    Power OFF (0h) at start-up
0C78: 41 7C FE AND   REG[124],254  (0158) ;;
0C7B: 2B 00    OR    A,[X+0]       (0159) ;; --------------------------------------------------------------------
0C7D: 60 7D    MOV   REG[125],A    (0160) 
0C7F: 18       POP   A             (0161) include "PGA_DDS_1.inc"
0C80: 70 3F    AND   F,63
0C82: 71 C0    OR    F,192         (0162) include "m8c.inc"
0C84: 7F       RET                 (0163) include "memory.inc"
                                   (0164) 
                                   (0165) 
0C85: 27 00 18 AND   [X+0],24      (0166) ;-----------------------------------------------
0C88: 2B 00    OR    A,[X+0]       (0167) ;  Global Symbols
0C8A: 60 7D    MOV   REG[125],A    (0168) ;-----------------------------------------------
0C8C: 43 7C 01 OR    REG[124],1    (0169) export  PGA_DDS_1_Start
0C8F: 18       POP   A             (0170) export _PGA_DDS_1_Start
0C90: 70 3F    AND   F,63
0C92: 71 C0    OR    F,192         (0171) export  PGA_DDS_1_SetPower
0C94: 7F       RET                 (0172) export _PGA_DDS_1_SetPower
                                   (0173) 
                                   (0174) export  PGA_DDS_1_SetGain
                                   (0175) export _PGA_DDS_1_SetGain
                                   (0176) 
                                   (0177) export  PGA_DDS_1_Stop
                                   (0178) export _PGA_DDS_1_Stop
                                   (0179) 
                                   (0180) ;-----------------------------------------------
                                   (0181) ;  EQUATES
                                   (0182) ;-----------------------------------------------
                                   (0183) POWERMASK:     equ 03h
                                   (0184) GAINREGMASK:   equ f8h
                                   (0185) GAINMASK:      equ fCh
                                   (0186) HIGHGAIN:      equ 04h
                                   (0187) HIGHGAINMASK:  equ 18h
                                   (0188) EXGAIN:        equ 01h
                                   (0189) 
                                   (0190) AREA UserModules (ROM, REL)
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: PGA_DDS_1_Start
                                   (0194) ;  FUNCTION NAME: PGA_DDS_1_SetPower
                                   (0195) ;
                                   (0196) ;  DESCRIPTION:
                                   (0197) ;    Applies power setting to the module's PSoC block.
                                   (0198) ;-----------------------------------------------------------------------------
0C95: 41 7F FC AND   REG[127],252  (0199) ;
                                   (0200) ;  ARGUMENTS:
0C99: 21 03    AND   A,3           (0201) ;  A  Contains the power settings 0=Off, 1=Low, 2=Med, and 3=High

FILE: lib\pga_adc.asm
0C9B: 4F       MOV   X,SP          (0110) ;;*****************************************************************************
                                   (0111) ;;*****************************************************************************
0C9C: 08       PUSH  A             (0112) ;;  FILENAME:   PGA_ADC.asm  ( PGA )
0C9D: 5D 73    MOV   A,REG[115]    (0113) ;;  Version: 3.2, Updated on 2009/6/23 at 19:34:6
0C9F: 21 FC    AND   A,252         (0114) ;;  Generated by PSoC Designer 5.0.972.0
0CA1: 2B 00    OR    A,[X+0]       (0115) ;;
0CA3: 60 73    MOV   REG[115],A    (0116) ;;  DESCRIPTION:  PGA User Module software implementation file for the
0CA5: 18       POP   A             (0117) ;;                22/24/27/29xxx PSoC family of devices.
0CA6: 70 3F    AND   F,63
0CA8: 71 C0    OR    F,192         (0118) ;;
0CAA: 7F       RET                 (0119) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0120) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0121) ;;        This means it is the caller's responsibility to preserve any values
                                   (0122) ;;        in the X and A registers that are still needed after the API functions
                                   (0123) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0124) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0125) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0126) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0127) ;;-----------------------------------------------------------------------------
                                   (0128) ;;  Copyright (c) Cypress MicroSystems 2004. All Rights Reserved.
                                   (0129) ;;*****************************************************************************
                                   (0130) ;;*****************************************************************************
                                   (0131) 
                                   (0132) ;; -----------------------------------------------------------------
                                   (0133) ;;                         Register Definitions
                                   (0134) ;;
                                   (0135) ;; Uses 1 Continuous Time Block configured as shown.
                                   (0136) ;;
                                   (0137) ;; * For a Mask/Val pair, this indicates that the value is
                                   (0138) ;;   determined by the user either through config-time parameteriza-
                                   (0139) ;;   tion or run-time manipulation.
                                   (0140) ;;
                                   (0141) ;; BIT FIELD             Mask/Val Function
                                   (0142) ;; -----------------            -----   --------------------
                                   (0143) ;; GAIN_CR0.RES_RATIO_T2B       F0/*    User Parameter (by table)
                                   (0144) ;; GAIN_CR0.GAIN_ATTEN          08/*    Gain (by table)
                                   (0145) ;; GAIN_CR0.RES_SOURCE          04/1    Res source to output
                                   (0146) ;; GAIN_CR0.RES_REF             03/*    Res ref
                                   (0147) ;;
                                   (0148) ;; GAIN_CR1.A_OUT               80/*    User Parameter (Output bus)
                                   (0149) ;; GAIN_CR1.COMP_EN             40/0    Comparator bus disabled
0CAB: 21 FC    AND   A,252         (0150) ;; GAIN_CR1.CT_NEG_INPUT_MUX    38/4    Neg mux to analog f.b. tap
0CAD: 4F       MOV   X,SP          (0151) ;; GAIN_CR1.CT_POS_INPUT_MUX    07/*    Pos mux, typically to col. input mux
                                   (0152) ;;
0CAE: 08       PUSH  A             (0153) ;; GAIN_CR2.CP_COMP             80/0    Latch transparent on PH1
0CAF: 5D 71    MOV   A,REG[113]    (0154) ;; GAIN_CR2.CK_COMP             40/0    Latch transparent
0CB1: 21 07    AND   A,7           (0155) ;; GAIN_CR2.CC_COMP             20/1    Mode OP-AMP (not comparator)
0CB3: 48 00 04 TST   [X+0],4       (0156) ;; GAIN_CR2.BYPASS_OBUS         1C/0    Bypass OFF
0CB6: B0 0E    JNZ   0x0CC5        (0157) ;; GAIN_CR2.PWR_SELECT          03/*    Power OFF (0h) at start-up
0CB8: 41 70 FE AND   REG[112],254  (0158) ;;
0CBB: 2B 00    OR    A,[X+0]       (0159) ;; --------------------------------------------------------------------
0CBD: 60 71    MOV   REG[113],A    (0160) 
0CBF: 18       POP   A             (0161) include "PGA_ADC.inc"
0CC0: 70 3F    AND   F,63
0CC2: 71 C0    OR    F,192         (0162) include "m8c.inc"
0CC4: 7F       RET                 (0163) include "memory.inc"
                                   (0164) 
                                   (0165) 
0CC5: 27 00 18 AND   [X+0],24      (0166) ;-----------------------------------------------
0CC8: 2B 00    OR    A,[X+0]       (0167) ;  Global Symbols
0CCA: 60 71    MOV   REG[113],A    (0168) ;-----------------------------------------------
0CCC: 43 70 01 OR    REG[112],1    (0169) export  PGA_ADC_Start
0CCF: 18       POP   A             (0170) export _PGA_ADC_Start
0CD0: 70 3F    AND   F,63
0CD2: 71 C0    OR    F,192         (0171) export  PGA_ADC_SetPower
0CD4: 7F       RET                 (0172) export _PGA_ADC_SetPower
                                   (0173) 
                                   (0174) export  PGA_ADC_SetGain
                                   (0175) export _PGA_ADC_SetGain
                                   (0176) 
                                   (0177) export  PGA_ADC_Stop
                                   (0178) export _PGA_ADC_Stop
                                   (0179) 
                                   (0180) ;-----------------------------------------------
                                   (0181) ;  EQUATES
                                   (0182) ;-----------------------------------------------
                                   (0183) POWERMASK:     equ 03h
                                   (0184) GAINREGMASK:   equ f8h
                                   (0185) GAINMASK:      equ fCh
                                   (0186) HIGHGAIN:      equ 04h
                                   (0187) HIGHGAINMASK:  equ 18h
                                   (0188) EXGAIN:        equ 01h
                                   (0189) 
                                   (0190) AREA UserModules (ROM, REL)
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: PGA_ADC_Start
                                   (0194) ;  FUNCTION NAME: PGA_ADC_SetPower
                                   (0195) ;
                                   (0196) ;  DESCRIPTION:
                                   (0197) ;    Applies power setting to the module's PSoC block.
                                   (0198) ;-----------------------------------------------------------------------------
0CD5: 41 73 FC AND   REG[115],252  (0199) ;
                                   (0200) ;  ARGUMENTS:
0CD9: 08       PUSH  A             (0201) ;  A  Contains the power settings 0=Off, 1=Low, 2=Med, and 3=High

FILE: lib\lcd.asm
0CDA: 10       PUSH  X             (0210) ;;*****************************************************************************
0CDB: 28       ROMX                (0211) ;;*****************************************************************************
0CDC: B0 04    JNZ   0x0CE1        (0212) ;;  FILENAME:   LCD.asm
0CDE: 20       POP   X             (0213) ;;  Version: 1.5, Updated on 2009/6/23 at 19:33:13
0CDF: 18       POP   A             (0214) ;;  Generated by PSoC Designer 5.0.972.0
                                   (0215) ;;
0CE0: 7F       RET                 (0216) ;;  DESCRIPTION: LCD User Module software implementation file
                                   (0217) ;;               for the M8C based PSoC family of devices.
                                   (0218) ;;
0CE1: 90 44    CALL  0x0D27        (0219) ;; This set of functions is written for the common 2 and 4 line
0CE3: 20       POP   X             (0220) ;; LCDs that use the Hitachi HD44780A controller.
0CE4: 18       POP   A             (0221) ;;
0CE5: 75       INC   X             (0222) ;;  LCD connections to PSoC port
0CE6: DF F2    JNC   0x0CD9        (0223) ;;
0CE8: 74       INC   A             (0224) ;;    PX.0 ==> LCD D4
0CE9: 8F EF    JMP   0x0CD9        (0225) ;;    PX.1 ==> LCD D5
0CEB: 30       HALT  
0CEC: 31 32    XOR   A,50
0CEE: 33 34    XOR   A,[X+52]
0CF0: 35 36    XOR   [X+54],A
0CF2: 37 38 39 XOR   [X+56],57
0CF5: 41 42 43 AND   REG[66],67
0CF8: 44 45 46 OR    REG[X+69],70
                                   (0226) ;;    PX.2 ==> LCD D6
                                   (0227) ;;    PX.3 ==> LCD D7
                                   (0228) ;;    PX.4 ==> LCD E
                                   (0229) ;;    PX.5 ==> LCD RS
                                   (0230) ;;    PX.6 ==> LCD R/W
                                   (0231) ;;
                                   (0232) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0233) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0234) ;;        This means it is the caller's responsibility to preserve any values
                                   (0235) ;;        in the X and A registers that are still needed after the API functions
                                   (0236) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0237) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0238) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0239) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0240) ;;-----------------------------------------------------------------------------
                                   (0241) ;;  Copyright (c) Cypress Semiconductor 2001-2006. All Rights Reserved.
                                   (0242) ;;*****************************************************************************
                                   (0243) ;;*****************************************************************************
                                   (0244) 
                                   (0245) include "m8c.inc"
                                   (0246) include "memory.inc"
                                   (0247) include "LCD.inc"
                                   (0248) 
                                   (0249) ;-----------------------------------------------
                                   (0250) ;  Global Symbols
                                   (0251) ;-----------------------------------------------
                                   (0252) 
                                   (0253) export   LCD_Start
                                   (0254) export  _LCD_Start
                                   (0255) export   LCD_Init
                                   (0256) export  _LCD_Init
                                   (0257) 
                                   (0258) export   LCD_WriteData
                                   (0259) export  _LCD_WriteData
                                   (0260) 
0CFB: 08       PUSH  A             (0261) export   LCD_Control
0CFC: 67       ASR   A             (0262) export  _LCD_Control
0CFD: 67       ASR   A             (0263) 
0CFE: 67       ASR   A             (0264) export  LCD_PrString
0CFF: 67       ASR   A             (0265) export _LCD_PrString
0D00: 21 0F    AND   A,15          (0266) 
0D02: FF E7    INDEX 0x0CEB        (0267) export  LCD_PrCString
0D04: 90 21    CALL  0x0D27        (0268) export _LCD_PrCString
0D06: 18       POP   A             (0269) 
0D07: 21 0F    AND   A,15          (0270) export  LCD_Position
0D09: FF E0    INDEX 0x0CEB        (0271) export _LCD_Position
0D0B: 90 1A    CALL  0x0D27        (0272) 
                                   (0273) export  LCD_PrHexByte
0D0D: 7F       RET                 (0274) export _LCD_PrHexByte
                                   (0275) 
                                   (0276) export  LCD_PrHexInt
                                   (0277) export _LCD_PrHexInt
                                   (0278) 
                                   (0279) export  LCD_Delay50uTimes
                                   (0280) export _LCD_Delay50uTimes
                                   (0281) 
                                   (0282) export  LCD_Delay50u
                                   (0283) export _LCD_Delay50u
                                   (0284) 
                                   (0285) ;-----------------------------------------------
                                   (0286) ; If bargraph functions not required, don't
                                   (0287) ; export the function names.
                                   (0288) ;-----------------------------------------------
                                   (0289) 
                                   (0290) IF (LCD_BARGRAPH_ENABLE)
                                   (0291) export  LCD_InitBG
                                   (0292) export _LCD_InitBG
                                   (0293) 
                                   (0294) export  LCD_InitVBG
                                   (0295) export _LCD_InitVBG
                                   (0296) 
                                   (0297) ; NOTE: The two functions,
                                   (0298) ;
                                   (0299) ;    LCD_DrawVBG and
                                   (0300) ;    LCD_DrawBG
                                   (0301) ;
                                   (0302) ; are implemented using both fastcall16 and legacy fastcall16 because they
                                   (0303) ; fall into a special and rare case where the calling sequences specified
                                   (0304) ; by the two disciplines are incompatible. The fastcall16 versions are
                                   (0305) ; provided for both C and Assembly users in all memory models. The legacy
0D0E: 4B       SWAP  A,X           (0306) ; fastcall16 versions are provided only to support existing small memory
0D0F: 9F EA    CALL  0x0CFB        (0307) ; model assembly language code---they do not work in the large memory
0D11: 5B       MOV   A,X           (0308) ; model.
0D12: 9F E7    CALL  0x0CFB        (0309) ;
                                   (0310) ; ** The legacy fastcall16 versions are provided on a temporary basis to
0D14: 7F       RET                 (0311) ; ** ease the transition to the 4.2 release of PSoC Designer. Their use is
                                   (0312) ; ** deprecated and their status is "No Further Maintenance".
                                   (0313) ;
                                   (0314) ; The fastcall16 versions of these functions are distinguished by a
                                   (0315) ; leading underscore in the name. The legacy fastcall16 names (which appear
                                   (0316) ; in this comment) do not have the leading underscore. Details on the
                                   (0317) ; calling sequence to be used for fastcall16 are given in the user module
                                   (0318) ; datasheet.
                                   (0319) ;
                                   (0320) ; Fastcall16 versions:
                                   (0321) export _LCD_DrawVBG
                                   (0322) export _LCD_DrawBG
                                   (0323) 
                                   (0324) IF SYSTEM_SMALL_MEMORY_MODEL
                                   (0325) ; Legacy Fastcall versions:
                                   (0326) export  LCD_DrawVBG
                                   (0327) export  LCD_DrawBG
                                   (0328) ENDIF  ; SYSTEM_SMALL_MEMORY_MODEL
                                   (0329) 
                                   (0330) ENDIF  ; BARGRAPH_ENABLE
                                   (0331) 
                                   (0332) ;
                                   (0333) ; The following functions are deprecated and will be eliminated in a future
                                   (0334) ; version of PSoC Designer.
                                   (0335) ;
                                   (0336) export   LCD_Write_Data
                                   (0337) export  _LCD_Write_Data
                                   (0338) 
                                   (0339) 
                                   (0340) ;-----------------------------------------------
                                   (0341) ;  EQUATES
                                   (0342) ;-----------------------------------------------
                                   (0343) 
0D15: 70 BF    AND   F,191         (0344) LCD_Port:           equ    PRT2DR
0D17: 60 D3    MOV   REG[211],A    (0345) LCD_PortMode0:      equ    PRT2DM0
                                   (0346) LCD_PortMode1:      equ    PRT2DM1
0D19: 52 00    MOV   A,[X+0]       (0347) 
0D1B: A0 06    JZ    0x0D22        (0348) LCD_E:              equ    10h
                                   (0349) LCD_RW:             equ    40h
0D1D: 90 08    CALL  0x0D27        (0350) LCD_RS:             equ    20h
0D1F: 75       INC   X             (0351) 
0D20: 8F F8    JMP   0x0D19        (0352) LCD_DATA_MASK:      equ    0Fh
0D22: 70 3F    AND   F,63
                                   (0353) LCD_READY_BIT:      equ    08h
0D24: 71 C0    OR    F,192         (0354) 
0D26: 7F       RET                 (0355) LCD_DATA_READ:      equ    ( LCD_E | LCD_RW | LCD_RS )
                                   (0356) LCD_CNTL_READ:      equ    ( LCD_E | LCD_RW )
                                   (0357) LCD_PORT_WRITE:     equ    7Fh
                                   (0358) LCD_PORT_MASK:      equ    7Fh
                                   (0359) 
                                   (0360) LCD_DISP_INC:       equ    03h
                                   (0361) LCD_DISP_OFF:       equ    08h
                                   (0362) LCD_DISP_ON:        equ    0Ch
                                   (0363) LCD_4BIT_2LINE:     equ    2Ch
                                   (0364) 
                                   (0365) 
                                   (0366) ;-----------------------------------------------
                                   (0367) ;      Bargraph definitions
                                   (0368) ;-----------------------------------------------
                                   (0369) 
                                   (0370) LCD_BG_CHAR_WIDTH:  equ    16     ; 16 characters in width
                                   (0371) LCD_BG_SEG_WIDTH:   equ    80     ; 16 * 5 = 80
                                   (0372) LCD_BG_COL_START:   equ     0     ; Always start in the left most column
                                   (0373) 
                                   (0374)                                   ; Offsets for 2x16, 2x20, 4x20
                                   (0375)                                   ; Change these values for a custom LCD
                                   (0376) 
                                   (0377) LCD_ROW1_OFFSET:    equ    80h    ; Address/command offset for row 1
                                   (0378) LCD_ROW2_OFFSET:    equ    C0h    ; Address/command offset for row 2
                                   (0379) LCD_ROW3_OFFSET:    equ    94h    ; Address/command offset for row 1
                                   (0380) LCD_ROW4_OFFSET:    equ    D4h    ; Address/command offset for row 2
                                   (0381) 
                                   (0382) LCD_BG_ROW1_OFFSET: equ    80h    ; Address/command offset for row 1
                                   (0383) LCD_BG_ROW2_OFFSET: equ    C0h    ; Address/command offset for row 2
                                   (0384) 
                                   (0385) LCD_CG_RAM_OFFSET:  equ    40h    ; Offset to character RAM
                                   (0386) 
0D27: 90 65    CALL  0x0D8E        (0387) AREA UserModules (ROM, REL)
                                   (0388) 
0D29: 08       PUSH  A             (0389) .SECTION
0D2A: 67       ASR   A             (0390) ;-----------------------------------------------------------------------------
0D2B: 67       ASR   A             (0391) ;  FUNCTION NAME: LCD_PrCString
0D2C: 67       ASR   A             (0392) ;
0D2D: 67       ASR   A             (0393) ;  DESCRIPTION:
0D2E: 21 0F    AND   A,15          (0394) ;    Print constant (ROM) string to LCD
0D30: 90 3B    CALL  0x0D6D        (0395) ;-----------------------------------------------------------------------------
0D32: 18       POP   A             (0396) ;
0D33: 21 0F    AND   A,15          (0397) ;  ARGUMENTS:
0D35: 40       NOP                 (0398) ;     A:X  Pointer to String
0D36: 40       NOP                 (0399) ;          A contains MSB of string address
0D37: 40       NOP                 (0400) ;          X contains LSB of string address
0D38: 90 33    CALL  0x0D6D        (0401) ;
                                   (0402) ;  RETURNS:  none
0D3A: 7F       RET                 (0403) ;
                                   (0404) ;  SIDE EFFECTS:
                                   (0405) ;    The A and X registers may be modified by this or future implementations
                                   (0406) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0407) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0408) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0409) ;    functions.
                                   (0410) ;          
                                   (0411) ;    Currently only the page pointer registers listed below are modified: 
                                   (0412) ;          CUR_PP
                                   (0413) ;
                                   (0414)  LCD_PrCString:
                                   (0415) _LCD_PrCString:
                                   (0416)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0417)  .Loop_PrCString:
                                   (0418)     push  A                            ; Store ROM pointer
                                   (0419)     push  X
                                   (0420)     romx                               ; Get character from ROM
                                   (0421)     jnz   .LCD_PrCString_WR            ; print character and advance pointer
                                   (0422)     pop   X                            ; Restore the stack
                                   (0423)     pop   A
                                   (0424)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0425)     ret                                ; Return
                                   (0426) 
                                   (0427) .LCD_PrCString_WR:
                                   (0428)     call  LCD_WriteData                ; Write data to LCD
                                   (0429)     pop   X                            ; Get ROM pointer
                                   (0430)     pop   A
                                   (0431)     inc   X                            ; Inc LSB of pointer
                                   (0432)     jnc   .Loop_PrCString
0D3B: 90 51    CALL  0x0D8E        (0433)     inc   A                            ; Inc MSB of pointer if LSB overflow
                                   (0434)     jmp   .Loop_PrCString
0D3D: 08       PUSH  A             (0435) 
0D3E: 67       ASR   A             (0436) .ENDSECTION
0D3F: 67       ASR   A             (0437) 
0D40: 67       ASR   A             (0438) ;-----------------------------------------------------------------------------
0D41: 67       ASR   A             (0439) ;  FUNCTION NAME: LCD_PrHexByte
0D42: 21 0F    AND   A,15          (0440) ;
0D44: 90 09    CALL  0x0D4F        (0441) ;  DESCRIPTION:
0D46: 18       POP   A             (0442) ;     Print a byte in Hex (two characters) to current LCD position
0D47: 21 0F    AND   A,15          (0443) ;
0D49: 40       NOP                 (0444) ;-----------------------------------------------------------------------------
0D4A: 40       NOP                 (0445) ;
0D4B: 40       NOP                 (0446) ;  ARGUMENTS:
0D4C: 90 01    CALL  0x0D4F        (0447) ;     A  => (BYTE) Data/char to be printed
                                   (0448) ;
0D4E: 7F       RET                 (0449) ;  RETURNS: none
                                   (0450) ;
                                   (0451) ;  SIDE EFFECTS:
                                   (0452) ;    The A and X registers may be modified by this or future implementations
                                   (0453) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0454) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0455) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0456) ;    functions.
                                   (0457) ;          
                                   (0458) ;    Currently only the page pointer registers listed below are modified: 
                                   (0459) ;          CUR_PP
                                   (0460) ;
                                   (0461) .LITERAL
                                   (0462) LCD_HEX_STR::
                                   (0463)      DS    "0123456789ABCDEF"
                                   (0464) .ENDLITERAL
                                   (0465) .SECTION
                                   (0466) 
                                   (0467)  LCD_PrHexByte:
                                   (0468) _LCD_PrHexByte:
                                   (0469)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0470)     push  A                            ; Save lower nibble
                                   (0471)     asr   A                            ; Shift high nibble to right
                                   (0472)     asr   A
                                   (0473)     asr   A
                                   (0474)     asr   A
                                   (0475)     and   A,0Fh                        ; Mask off nibble
                                   (0476)     index LCD_HEX_STR                  ; Get Hex value
                                   (0477)     call  LCD_WriteData                ; Write data to screen
0D4F: 08       PUSH  A             (0478)     pop   A                            ; Restore value
0D50: 62 D0 00 MOV   REG[208],0    (0479)     and   A,0Fh                        ; Mask off lower nibble
0D53: 26 02 80 AND   [2],128       (0480)     index LCD_HEX_STR                  ; Get Hex value
0D56: 51 02    MOV   A,[2]         (0481)     call  LCD_WriteData                ; Write data to screen
0D58: 60 08    MOV   REG[8],A      (0482)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0483)     ret
0D5A: 18       POP   A             (0484) .ENDSECTION
0D5B: 21 0F    AND   A,15          (0485) 
0D5D: 29 10    OR    A,16          (0486) .SECTION
0D5F: 2A 02    OR    A,[2]         (0487) ;-----------------------------------------------------------------------------
0D61: 60 08    MOV   REG[8],A      (0488) ;  FUNCTION NAME: LCD_PrHexInt
0D63: 53 02    MOV   [2],A         (0489) ;
0D65: 40       NOP                 (0490) ;  DESCRIPTION:
0D66: 21 8F    AND   A,143         (0491) ;     Print an Int in Hex (four characters) to current LCD position
0D68: 53 02    MOV   [2],A         (0492) ;
0D6A: 60 08    MOV   REG[8],A      (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;
0D6C: 7F       RET                 (0495) ;  ARGUMENTS:
                                   (0496) ;     A:X Integer value
                                   (0497) ;         A  contains LSB of Int
                                   (0498) ;         X  contains MSB of Int
                                   (0499) ;
                                   (0500) ;  RETURNS: none
                                   (0501) ;
                                   (0502) ;  SIDE EFFECTS:
                                   (0503) ;    The A and X registers may be modified by this or future implementations
                                   (0504) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0505) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0506) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0507) ;    functions.
                                   (0508) ;          
                                   (0509) ;    Currently only the page pointer registers listed below are modified: 
                                   (0510) ;          CUR_PP
                                   (0511) ;
                                   (0512)  LCD_PrHexInt:
                                   (0513) _LCD_PrHexInt:
                                   (0514)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0515)     swap  A,X
                                   (0516)     call  LCD_PrHexByte                ; Print MSB
                                   (0517)     mov   A,X                          ; Move LSB into position
                                   (0518)     call  LCD_PrHexByte                ; Print LSB
                                   (0519)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0520)     ret
                                   (0521) .ENDSECTION
                                   (0522) 
                                   (0523) .SECTION
0D6D: 08       PUSH  A             (0524) ;-----------------------------------------------------------------------------
0D6E: 62 D0 00 MOV   REG[208],0    (0525) ;  FUNCTION NAME: LCD_PrString
0D71: 26 02 80 AND   [2],128       (0526) ;
0D74: 2E 02 20 OR    [2],32        (0527) ;  DESCRIPTION:
0D77: 51 02    MOV   A,[2]         (0528) ;     Print (RAM) ASCII string to LCD
0D79: 60 08    MOV   REG[8],A      (0529) ;
                                   (0530) ;-----------------------------------------------------------------------------
0D7B: 18       POP   A             (0531) ;
0D7C: 21 0F    AND   A,15          (0532) ;  ARGUMENTS:
0D7E: 29 30    OR    A,48          (0533) ;     A:X contains pointer to string
0D80: 2A 02    OR    A,[2]         (0534) ;         X  contains LSB of string pointer
0D82: 60 08    MOV   REG[8],A      (0535) ;         A  contains MSB or page of string pointer (not used at this time)
0D84: 53 02    MOV   [2],A         (0536) ;
0D86: 40       NOP                 (0537) ;  RETURNS:
0D87: 21 AF    AND   A,175         (0538) ;
0D89: 53 02    MOV   [2],A         (0539) ;  SIDE EFFECTS:
0D8B: 60 08    MOV   REG[8],A      (0540) ;    The A and X registers may be modified by this or future implementations
                                   (0541) ;    of this function.  The same is true for all RAM page pointer registers in
0D8D: 7F       RET                 (0542) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0543) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0544) ;    functions.
                                   (0545) ;          
                                   (0546) ;    Currently only the page pointer registers listed below are modified: 
                                   (0547) ;          CUR_PP
                                   (0548) ;          IDX_PP
                                   (0549) ;
                                   (0550) ;
                                   (0551)  LCD_PrString:
                                   (0552) _LCD_PrString:
                                   (0553)     RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0554)     RAM_SETPAGE_IDX A
                                   (0555)  .Loop_PrString:
                                   (0556)     mov   A,[X]                        ; Get value pointed to by X
                                   (0557)     jz    .End_LCD_PrString            ; Check for end of string
                                   (0558)     ;LCD_writeData is known not to modify X so no need to preserve
                                   (0559)     call  LCD_WriteData                ; Write data to screen
                                   (0560)     inc   X                            ; Advance pointer to next character
                                   (0561)     jmp   .Loop_PrString               ; Go get next character
                                   (0562) .End_LCD_PrString:
                                   (0563)     RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0564)     ret
                                   (0565) .ENDSECTION
                                   (0566) 
                                   (0567) .SECTION
                                   (0568) ;-----------------------------------------------------------------------------
                                   (0569) ;  FUNCTION NAME: LCD_WriteData
                                   (0570) ;
                                   (0571) ;  DESCRIPTION:
0D8E: 08       PUSH  A             (0572) ;     Write a byte to the LCD's data register.
0D8F: 62 D0 00 MOV   REG[208],0    (0573) ;
0D92: 26 02 80 AND   [2],128       (0574) ;-----------------------------------------------------------------------------
0D95: 51 02    MOV   A,[2]         (0575) ;
0D97: 60 08    MOV   REG[8],A      (0576) ;  ARGUMENTS:
                                   (0577) ;    A contains byte to be written to LCD data register
0D99: 26 03 F0 AND   [3],240       (0578) ;
0D9C: 51 03    MOV   A,[3]         (0579) ;  RETURNS: none
0D9E: 71 10    OR    F,16          (0580) ;
0DA0: 60 08    MOV   REG[8],A      (0581) ;  SIDE EFFECTS:
0DA2: 70 EF    AND   F,239         (0582) ;    The A and X registers may be modified by this or future implementations
                                   (0583) ;    of this function.  The same is true for all RAM page pointer registers in
0DA4: 2E 02 40 OR    [2],64        (0584) ;    the Large Memory Model.  When necessary, it is the calling function's
0DA7: 51 02    MOV   A,[2]         (0585) ;    responsibility to preserve their values across calls to fastcall16 
0DA9: 60 08    MOV   REG[8],A      (0586) ;    functions.
0DAB: 40       NOP                 (0587) ;          
                                   (0588) ;    Currently only the page pointer registers listed below are modified: 
0DAC: 10       PUSH  X             (0589) ;          CUR_PP
0DAD: 57 FF    MOV   X,255         (0590) ;
                                   (0591)  LCD_WriteData:
                                   (0592) _LCD_WriteData:
0DAF: 2E 02 50 OR    [2],80        (0593)  LCD_Write_Data:   ; Do not use
0DB2: 51 02    MOV   A,[2]         (0594) _LCD_Write_Data:   ; Do not use
0DB4: 60 08    MOV   REG[8],A      (0595)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0596)     call  LCD_Check_Ready              ; Make sure controller is ready
0DB6: 40       NOP                 (0597)                                        ; A is preserved in LCD_Check_Ready
0DB7: 40       NOP                 (0598)     push  A                            ; Save copy of character
0DB8: 5D 08    MOV   A,REG[8]      (0599)     asr   A                            ; Shift high nibble to right
                                   (0600)     asr   A
                                   (0601)     asr   A
                                   (0602)     asr   A
                                   (0603)     and   A,0Fh                        ; Mask off high nibble
                                   (0604)     call  LCD_WDATA_Nibble             ; Write Upper nibble
                                   (0605)     pop   A                            ; Retrieve copy of character
                                   (0606)     and   A,0Fh                        ; Mask off high nibble
                                   (0607)     nop
                                   (0608)     nop
                                   (0609)     nop
                                   (0610)     call  LCD_WDATA_Nibble   ; Write Lower nibble
0DBA: 08       PUSH  A             (0611)     RAM_EPILOGUE RAM_USE_CLASS_1
0DBB: 26 02 C0 AND   [2],192       (0612)     ret
0DBE: 51 02    MOV   A,[2]         (0613) .ENDSECTION
0DC0: 60 08    MOV   REG[8],A      (0614) 
                                   (0615) .SECTION
0DC2: 40       NOP                 (0616) ;-----------------------------------------------------------------------------
0DC3: 40       NOP                 (0617) ;  FUNCTION NAME: LCD_Control
0DC4: 40       NOP                 (0618) ;
                                   (0619) ;  DESCRIPTION:
0DC5: 2E 02 50 OR    [2],80        (0620) ;     Write a byte to the LCD's control register.
0DC8: 51 02    MOV   A,[2]         (0621) ;
0DCA: 60 08    MOV   REG[8],A      (0622) ;-----------------------------------------------------------------------------
                                   (0623) ;
0DCC: 40       NOP                 (0624) ;  ARGUMENTS:
0DCD: 40       NOP                 (0625) ;     A contains data to be written to LCD control register.
                                   (0626) ;
0DCE: 26 02 C0 AND   [2],192       (0627) ;  RETURNS: none
0DD1: 51 02    MOV   A,[2]         (0628) ;
0DD3: 60 08    MOV   REG[8],A      (0629) ;  SIDE EFFECTS:
                                   (0630) ;    The A and X registers may be modified by this or future implementations
0DD5: 18       POP   A             (0631) ;    of this function.  The same is true for all RAM page pointer registers in
0DD6: 21 08    AND   A,8           (0632) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0633) ;    responsibility to preserve their values across calls to fastcall16 
0DD8: A0 04    JZ    0x0DDD        (0634) ;    functions.
0DDA: 79       DEC   X             (0635) ;          
0DDB: BF D3    JNZ   0x0DAF        (0636) ;    Currently only the page pointer registers listed below are modified: 
                                   (0637) ;          CUR_PP
0DDD: 20       POP   X             (0638) ;
                                   (0639)  LCD_Control:
0DDE: 2E 03 7F OR    [3],127       (0640) _LCD_Control:
0DE1: 51 03    MOV   A,[3]         (0641)     RAM_PROLOGUE RAM_USE_CLASS_1
0DE3: 71 10    OR    F,16          (0642)     call  LCD_Check_Ready              ; Make sure controller is ready
0DE5: 60 08    MOV   REG[8],A      (0643)                                        ; A is preserved in LCD_Check_Ready
0DE7: 70 EF    AND   F,239         (0644)     push  A                            ; Save copy of byte
0DE9: 18       POP   A             (0645)     asr   A                            ; Shift Upper Nibble to right
                                   (0646)     asr   A
0DEA: 7F       RET                 (0647)     asr   A
                                   (0648)     asr   A
                                   (0649)     and   A,0Fh                        ; Mask off, just in case
                                   (0650)     call  LCD_WCNTL_Nibble             ; Write high nibble
                                   (0651)     pop   A                            ; Restore copy of byte
                                   (0652)     and   A,0Fh                        ; Mask off high nibble
                                   (0653)     nop
                                   (0654)     nop
                                   (0655)     nop
                                   (0656)     call  LCD_WCNTL_Nibble             ; Write Lower nibble
                                   (0657)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0658)     ret
                                   (0659) .ENDSECTION
                                   (0660) 
                                   (0661) .SECTION
                                   (0662) ;-----------------------------------------------------------------------------
                                   (0663) ;  FUNCTION NAME: LCD_WCNTL_Nibble
                                   (0664) ;
                                   (0665) ;  DESCRIPTION:
                                   (0666) ;     Write a single nibble to the LCD's command register
                                   (0667) ;
                                   (0668) ;-----------------------------------------------------------------------------
                                   (0669) ;
                                   (0670) ;  ARGUMENTS:
                                   (0671) ;     A[3:0]   Contains Nibble to be written to command register
                                   (0672) ;
                                   (0673) ;  RETURNS: none
                                   (0674) ;
                                   (0675) ;  SIDE EFFECTS:
                                   (0676) ;    The A and X registers may be modified by this or future implementations
                                   (0677) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0678) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0679) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0680) ;    functions.
                                   (0681) ;          
                                   (0682) ;    Currently only the page pointer registers listed below are modified: 
                                   (0683) ;          CUR_PP
0DEB: 62 D0 00 MOV   REG[208],0    (0684) ;
                                   (0685)  LCD_WCNTL_Nibble:
0DEE: 26 03 80 AND   [3],128       (0686)     RAM_PROLOGUE RAM_USE_CLASS_4
0DF1: 2E 03 7F OR    [3],127       (0687)     push  A
0DF4: 26 04 80 AND   [4],128       (0688)     RAM_SETPAGE_CUR >Port_2_Data_SHADE           ; Set CUR_PP to LCD variable address
                                   (0689)     and   [Port_2_Data_SHADE],~LCD_PORT_MASK
0DF7: 51 03    MOV   A,[3]         (0690)     mov   A,[Port_2_Data_SHADE]
0DF9: 71 10    OR    F,16          (0691)     mov   reg[LCD_Port],A                        ; Reset control lines
0DFB: 60 08    MOV   REG[8],A      (0692) 
0DFD: 51 04    MOV   A,[4]         (0693)     pop   A
0DFF: 60 09    MOV   REG[9],A      (0694)     and   A,LCD_DATA_MASK                        ; Make sure no bogus data in MSN
0E01: 70 EF    AND   F,239         (0695)     or    A,LCD_E                                ; Bring "E" Enable line high
                                   (0696)     or    A,[Port_2_Data_SHADE]                  ; OR in bit 7 just
0E03: 50 FA    MOV   A,250         (0697)     mov   reg[LCD_Port], A                       ; Write data
0E05: 90 67    CALL  0x0E6E        (0698)     mov   [Port_2_Data_SHADE],A                  ; Keep shadow register in sync
0E07: 50 FA    MOV   A,250         (0699)     nop
0E09: 90 63    CALL  0x0E6E        (0700)     and   A,(~LCD_PORT_MASK|LCD_DATA_MASK)       ; Disable E signal and leave data on bus.
                                   (0701)     mov   [Port_2_Data_SHADE],A                  ; Keep shadow register in sync
0E0B: 50 03    MOV   A,3           (0702)     mov   reg[LCD_Port],A
0E0D: 9F 40    CALL  0x0D4F        (0703)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0704)     ret
0E0F: 50 52    MOV   A,82          (0705) .ENDSECTION
0E11: 90 5B    CALL  0x0E6E        (0706) 
                                   (0707) .SECTION
0E13: 50 03    MOV   A,3           (0708) ;-----------------------------------------------------------------------------
0E15: 9F 38    CALL  0x0D4F        (0709) ;  FUNCTION NAME: LCD_WDATA_Nibble
                                   (0710) ;
0E17: 90 63    CALL  0x0E7C        (0711) ;  DESCRIPTION:
0E19: 90 61    CALL  0x0E7C        (0712) ;     Write a single nibble to the LCD's DATA register
0E1B: 90 5F    CALL  0x0E7C        (0713) ;
                                   (0714) ;-----------------------------------------------------------------------------
0E1D: 50 03    MOV   A,3           (0715) ;
0E1F: 9F 2E    CALL  0x0D4F        (0716) ;  ARGUMENTS:
                                   (0717) ;     A[3:0]   Contains Nibble to be written to data register
0E21: 50 5A    MOV   A,90          (0718) ;
0E23: 90 49    CALL  0x0E6E        (0719) ;  RETURNS: none
                                   (0720) ;
0E25: 50 02    MOV   A,2           (0721) ;  SIDE EFFECTS:
0E27: 9F 26    CALL  0x0D4F        (0722) ;    The A and X registers may be modified by this or future implementations
                                   (0723) ;    of this function.  The same is true for all RAM page pointer registers in
0E29: 50 5A    MOV   A,90          (0724) ;    the Large Memory Model.  When necessary, it is the calling function's
0E2B: 90 41    CALL  0x0E6E        (0725) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0726) ;    functions.
0E2D: 50 08    MOV   A,8           (0727) ;          
0E2F: 9F 0A    CALL  0x0D3B        (0728) ;    Currently only the page pointer registers listed below are modified: 
0E31: 50 5A    MOV   A,90          (0729) ;          CUR_PP
0E33: 90 39    CALL  0x0E6E        (0730) ;
                                   (0731) LCD_WDATA_Nibble:
0E35: 50 01    MOV   A,1           (0732)     RAM_PROLOGUE RAM_USE_CLASS_4
0E37: 9F 02    CALL  0x0D3B        (0733)     push  A
0E39: 50 5A    MOV   A,90          (0734)     RAM_SETPAGE_CUR >Port_2_Data_SHADE          ; Set CUR_PP to LCD variable address
0E3B: 90 31    CALL  0x0E6E        (0735)     and   [Port_2_Data_SHADE],~LCD_PORT_MASK
                                   (0736)     or    [Port_2_Data_SHADE],LCD_RS                  ; Raise RS to signify a Data Write
0E3D: 50 06    MOV   A,6           (0737)     mov   A,[Port_2_Data_SHADE]
0E3F: 9E FA    CALL  0x0D3B        (0738)     mov   reg[LCD_Port],A
                                   (0739) 
0E41: 50 0E    MOV   A,14          (0740)     pop   A
0E43: 9E F6    CALL  0x0D3B        (0741)     and   A,LCD_DATA_MASK                             ; Make sure no bogus data in A[7:4]
                                   (0742)     or    A,(LCD_E | LCD_RS)                          ; Bring "E" Enable line high
0E45: 50 2C    MOV   A,44          (0743)     or    A,[Port_2_Data_SHADE]                       ; Keep shadow in sync
0E47: 9E F2    CALL  0x0D3B        (0744)     mov   reg[LCD_Port], A                            ; Write data
                                   (0745)     mov   [Port_2_Data_SHADE],A                       ; Keep shadow in sync
0E49: 50 08    MOV   A,8           (0746)     NOP
0E4B: 9E EE    CALL  0x0D3B        (0747)     and   A,(~LCD_PORT_MASK|LCD_DATA_MASK|LCD_RS)     ; Disable E signal and leave Data on bus
                                   (0748)     mov   [Port_2_Data_SHADE],A                       ; keep shadow in sync
0E4D: 50 0C    MOV   A,12          (0749)     mov   reg[LCD_Port],A
0E4F: 9E EA    CALL  0x0D3B        (0750)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0751)     ret
0E51: 50 03    MOV   A,3           (0752) .ENDSECTION
0E53: 9E E6    CALL  0x0D3B        (0753) 
                                   (0754) .SECTION
0E55: 50 5A    MOV   A,90          (0755) ;-----------------------------------------------------------------------------
0E57: 90 15    CALL  0x0E6E        (0756) ;  FUNCTION NAME: LCD_Check_Ready
                                   (0757) ;
0E59: 7F       RET                 (0758) ;  DESCRIPTION:
0E5A: 80 C0    JMP   0x0F1B
0E5C: 94 D4    CALL  0x1332
                                   (0759) ;     Wait until LCD has completed last command.
                                   (0760) ;
                                   (0761) ;-----------------------------------------------------------------------------
                                   (0762) ;
                                   (0763) ;  ARGUMENTS: none
                                   (0764) ;
                                   (0765) ;  RETURNS: none
                                   (0766) ;
                                   (0767) ;  SIDE EFFECTS:
                                   (0768) ;    The A and X registers may be modified by this or future implementations
                                   (0769) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0770) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0771) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0772) ;    functions.
                                   (0773) ;          
                                   (0774) ;    Currently only the page pointer registers listed below are modified: 
                                   (0775) ;          CUR_PP
                                   (0776) ;
                                   (0777) ;     If LCD is not present, this routine may never return.
                                   (0778) ;
                                   (0779) LCD_Check_Ready:
                                   (0780)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0781)     push  A                                           ; Save Accumulator
                                   (0782)     RAM_SETPAGE_CUR >Port_2_Data_SHADE                ; Set CUR_PP to LCD variable address
                                   (0783)     and   [Port_2_Data_SHADE],~LCD_PORT_MASK          ; Mask of all LCD bits
                                   (0784)     mov   A,[Port_2_Data_SHADE]
                                   (0785)     mov   reg[LCD_Port],A                             ; Zero LCD port bits
                                   (0786) 
                                   (0787)     and   [Port_2_DriveMode_0_SHADE],~LCD_DATA_MASK   ; Clear out LCD mode bits.
                                   (0788)     mov   A,[Port_2_DriveMode_0_SHADE]
                                   (0789)     M8C_SetBank1                                      ; Change port mode to read status
                                   (0790)     mov   reg[LCD_PortMode0],A                        ; Setup LCD Port for reading
0E5E: 21 03    AND   A,3           (0791)     M8C_SetBank0
0E60: 10       PUSH  X             (0792) 
0E61: FF F7    INDEX 0x0E5A        (0793)     or    [Port_2_Data_SHADE],LCD_RW                  ; Raise RW to signify Read operation
0E63: 4F       MOV   X,SP          (0794)     mov   A,[Port_2_Data_SHADE]
0E64: 03 FF    ADD   A,[X-1]       (0795)     mov   reg[LCD_Port],A
0E66: 20       POP   X             (0796)     NOP
                                   (0797) 
0E67: 9E D2    CALL  0x0D3B        (0798)     push  X							                            ; Save 'X' register
0E69: 70 3F    AND   F,63
0E6B: 71 C0    OR    F,192         (0799)     mov   X,255                         			            ; 255 Attempts
0E6D: 7F       RET                 (0800) 
                                   (0801) .LCD_RDY_LOOP:
                                   (0802)     or    [Port_2_Data_SHADE], LCD_CNTL_READ                    ; Raise E to start cycle
                                   (0803)     mov   A,[Port_2_Data_SHADE]
                                   (0804)     mov   reg[LCD_Port],A
                                   (0805) 
                                   (0806)     nop                                               ; Wait 2 nops to make sure data is ready
                                   (0807)     nop
                                   (0808)     mov   A,reg[LCD_Port]
                                   (0809) 
                                   (0810) ; The code below is used to work around the async read issue with the ICE with the 
                                   (0811) ; 25/26xxx family of devices.  It will help to eliminate "Invalid memory reference" 
                                   (0812) ; errors.  It is not required when running without the ICE or when using any other 
                                   (0813) ; family besides the 25/26xxx family. If not using the ICE or with any other family
                                   (0814) ; the ICE_PORT_SYNC flag should be set to 0.
                                   (0815) IF(ICE_PORT_SYNC)                          
                                   (0816)     mov   reg[ 0xfa], A                    
                                   (0817)     mov   A, reg[0xfa]                     
                                   (0818) ENDIF   
                                   (0819)                                    
                                   (0820)     push  A
                                   (0821)     and   [Port_2_Data_SHADE],(~LCD_PORT_MASK | LCD_RW)         ; Lower E signal
                                   (0822)     mov   A,[Port_2_Data_SHADE]
                                   (0823)     mov   reg[LCD_Port],A
                                   (0824) 
                                   (0825)     nop                                    ; Add delay for the slowest part and the
                                   (0826)     nop                                    ; fastest PSoC
                                   (0827)     nop
0E6E: 90 0C    CALL  0x0E7C        (0828)                                                                 ; Get the LSBs
0E70: 78       DEC   A             (0829)     or    [Port_2_Data_SHADE],LCD_CNTL_READ                     ; Raise E to start cycle
0E71: BF FC    JNZ   0x0E6E        (0830)     mov   A,[Port_2_Data_SHADE]
                                   (0831)     mov   reg[LCD_Port],A
0E73: 7F       RET                 (0832) 
0E74: 08       PUSH  A
0E75: 19 3A    SBB   A,58
0E77: 7C 01 01 LCALL 0x0101
0E7A: 01 01    ADD   A,1
                                   (0833)     nop
                                   (0834)     nop
                                   (0835) 
                                   (0836)     and   [Port_2_Data_SHADE],(~LCD_PORT_MASK | LCD_RW)         ; Lower E signal
                                   (0837)     mov   A,[Port_2_Data_SHADE]
                                   (0838)     mov   reg[LCD_Port],A
                                   (0839) 
                                   (0840)     pop   A
                                   (0841)     and   A,LCD_READY_BIT                                       ; Check busy
                                   (0842) 
                                   (0843)     jz    .UNLOCK
                                   (0844)     dec   X
                                   (0845)     jnz   .LCD_RDY_LOOP                                         ; If LCD still busy, read again for 255 times
                                   (0846) .UNLOCK:
                                   (0847)     pop   X							                            ; Restore 'X' register
                                   (0848) 
                                   (0849)     or    [Port_2_DriveMode_0_SHADE],LCD_PORT_WRITE   ; Revert Data bit to Write mode
                                   (0850)     mov   A,[Port_2_DriveMode_0_SHADE]
                                   (0851)     M8C_SetBank1
                                   (0852)     mov   reg[LCD_PortMode0],A                        ; Setup LCD Port for writing
                                   (0853)     M8C_SetBank0
                                   (0854)     pop   A
                                   (0855)     RAM_EPILOGUE RAM_USE_CLASS_4                                ; Restore Accumulator
                                   (0856)     ret
                                   (0857) .ENDSECTION
                                   (0858) 
                                   (0859) .SECTION
                                   (0860) ;-----------------------------------------------------------------------------
                                   (0861) ;  FUNCTION NAME: LCD_Start
                                   (0862) ;  FUNCTION NAME: LCD_Init
                                   (0863) ;
                                   (0864) ;  DESCRIPTION:
                                   (0865) ;     Initialize LCD
                                   (0866) ;
                                   (0867) ;-----------------------------------------------------------------------------
                                   (0868) ;
                                   (0869) ;  ARGUMENTS: none
                                   (0870) ;
                                   (0871) ;  RETURNS: none
0E7C: 08       PUSH  A             (0872) ;
0E7D: 71 10    OR    F,16          (0873) ;  SIDE EFFECTS:
0E7F: 5D E0    MOV   A,REG[224]    (0874) ;    The A and X registers may be modified by this or future implementations
0E81: 70 EF    AND   F,239         (0875) ;    of this function.  The same is true for all RAM page pointer registers in
0E83: 21 07    AND   A,7           (0876) ;    the Large Memory Model.  When necessary, it is the calling function's
0E85: 39 05    CMP   A,5           (0877) ;    responsibility to preserve their values across calls to fastcall16 
0E87: D0 06    JNC   0x0E8E        (0878) ;    functions.
0E89: FF E9    INDEX 0x0E74        (0879) ;          
                                   (0880) ;    Currently only the page pointer registers listed below are modified: 
0E8B: 78       DEC   A             (0881) ;          CUR_PP
0E8C: BF FE    JNZ   0x0E8B        (0882) ;
                                   (0883) ;  THEORY of OPERATION or PROCEDURE:
0E8E: 18       POP   A             (0884) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0885) ;    This initialization is a bit long, but it should work for
0E8F: 7F       RET                 (0886) ;    most 2 and 4 line LCDs.
                                   (0887) ;
                                   (0888)  LCD_Start:
                                   (0889) _LCD_Start:
                                   (0890)  LCD_Init:
                                   (0891) _LCD_Init:
                                   (0892)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0893)     RAM_SETPAGE_CUR >Port_2_Data_SHADE                          ; Set CUR_PP to LCD variable address
                                   (0894) 
                                   (0895)     and   [Port_2_DriveMode_0_SHADE],~LCD_PORT_MASK             ; Mask off LCD bits
                                   (0896)     or    [Port_2_DriveMode_0_SHADE],LCD_PORT_WRITE             ; Set LCD port for writing
                                   (0897)     and   [Port_2_DriveMode_1_SHADE],~LCD_PORT_MASK             ; Mask off LCD bits
                                   (0898) 
                                   (0899)     mov   A,[Port_2_DriveMode_0_SHADE]
                                   (0900)     M8C_SetBank1
                                   (0901)     mov   reg[LCD_PortMode0],A                                  ; Setup LCD Port for writing
                                   (0902)     mov   A,[Port_2_DriveMode_1_SHADE]
                                   (0903)     mov   reg[LCD_PortMode1],A
                                   (0904)     M8C_SetBank0
                                   (0905) 
                                   (0906)     mov   A,250                             ; Delay for 12.5 mSec (250 * 50uSec)
                                   (0907)     call  LCD_Delay50uTimes
                                   (0908)     mov   A,250                             ; Delay for 12.5 mSec (250 * 50uSec)
                                   (0909)     call  LCD_Delay50uTimes
                                   (0910) 
                                   (0911)     mov   A,03h
                                   (0912)     call  LCD_WCNTL_Nibble
                                   (0913) 
                                   (0914)     mov   A,82                              ; Delay for 4.1 mSec (82 * 50uSec)
                                   (0915)     call  LCD_Delay50uTimes
                                   (0916) 
                                   (0917)     mov   A,03h
                                   (0918)     call  LCD_WCNTL_Nibble
                                   (0919) 
                                   (0920)     call  LCD_Delay50u
                                   (0921)     call  LCD_Delay50u
                                   (0922)     call  LCD_Delay50u
                                   (0923) 
                                   (0924)     mov   A,03h
                                   (0925)     call  LCD_WCNTL_Nibble
                                   (0926) 
                                   (0927)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0928)     call  LCD_Delay50uTimes
                                   (0929) 
                                   (0930)     mov   A,02h
                                   (0931)     call  LCD_WCNTL_Nibble
                                   (0932) 
                                   (0933)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0934)     call  LCD_Delay50uTimes
                                   (0935) 
                                   (0936)     mov   A,08h
                                   (0937)     call  LCD_Control
                                   (0938)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0939)     call  LCD_Delay50uTimes
                                   (0940) 
                                   (0941)     mov   A,01h
                                   (0942)     call  LCD_Control
                                   (0943)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0944)     call  LCD_Delay50uTimes
                                   (0945) 
                                   (0946)     mov   A,06h
                                   (0947)     call  LCD_Control
                                   (0948) 
                                   (0949)     mov   A,0Eh
                                   (0950)     call  LCD_Control
                                   (0951) 
                                   (0952)     mov   A,LCD_4BIT_2LINE                  ; Setup for 4 bit interface, 2 line
                                   (0953)     call  LCD_Control
                                   (0954) 
                                   (0955)     mov   A,LCD_DISP_OFF
                                   (0956)     call  LCD_Control
                                   (0957) 
                                   (0958)     mov   A,LCD_DISP_ON
                                   (0959)     call  LCD_Control
                                   (0960) 
                                   (0961)     mov   A,LCD_DISP_INC
                                   (0962)     call  LCD_Control
                                   (0963) 
                                   (0964)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0965)     call  LCD_Delay50uTimes
                                   (0966)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0967)     ret
                                   (0968) .ENDSECTION
                                   (0969) 
                                   (0970) ;-----------------------------------------------------------------------------
                                   (0971) ;  FUNCTION NAME: LCD_Position
                                   (0972) ;
                                   (0973) ;  DESCRIPTION:
                                   (0974) ;     Position Cursor at Row and Col location
                                   (0975) ;
                                   (0976) ;-----------------------------------------------------------------------------
                                   (0977) ;
                                   (0978) ;  ARGUMENTS:
                                   (0979) ;     A => Row  0 to 3
                                   (0980) ;     X => Col  0 to 39+
                                   (0981) ;
                                   (0982) ;  RETURNS:  none
                                   (0983) ;
                                   (0984) ;  SIDE EFFECTS:
                                   (0985) ;    The A and X registers may be modified by this or future implementations
                                   (0986) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0987) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0988) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0989) ;    functions.
                                   (0990) ;
                                   (0991) .LITERAL
                                   (0992) LCD_ROW_OFFSET::
                                   (0993)      DB    LCD_ROW1_OFFSET, LCD_ROW2_OFFSET, LCD_ROW3_OFFSET, LCD_ROW4_OFFSET
                                   (0994) .ENDLITERAL
                                   (0995) 
                                   (0996) .SECTION
                                   (0997)  LCD_Position:
                                   (0998) _LCD_Position:
                                   (0999)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1000)     and   A,03h                        ; Mask off 2 bits for row address 0 to 3
                                   (1001)     push  X                            ; Store COL
                                   (1002)     index LCD_ROW_OFFSET ; Get ROW memory offset from table
                                   (1003)     mov   X,SP                         ; Get Stack pointer
                                   (1004)     add   A,[X+(-1)]                   ; Add the COL to the display pointer
                                   (1005)     pop   X
                                   (1006) 
                                   (1007)     call  LCD_Control                  ; Write control byte
                                   (1008)     RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1009)     ret
                                   (1010) .ENDSECTION
                                   (1011) 
                                   (1012) .SECTION
                                   (1013) ;-----------------------------------------------------------------------------
                                   (1014) ;  FUNCTION NAME: LCD_Delay50uTimes
                                   (1015) ;
0E90: 4F       MOV   X,SP          (1016) ;  DESCRIPTION:
0E91: 10       PUSH  X             (1017) ;     Delay increments of 50uSeconds
0E92: 52 FD    MOV   A,[X-3]       (1018) ;
0E94: 59 FC    MOV   X,[X-4]       (1019) ;-----------------------------------------------------------------------------
0E96: 70 3F    AND   F,63
0E98: 71 C0    OR    F,192         (1020) ;
0E9A: 9F C2    CALL  0x0E5E        (1021) ;  ARGUMENTS:
                                   (1022) ;     A contains the delay multiplier
0E9C: 20       POP   X             (1023) ;
                                   (1024) ;  RETURNS:
                                   (1025) ;
0E9D: 3D FA 00 CMP   [X-6],0       (1026) ;  SIDE EFFECTS:
0EA0: B0 05    JNZ   0x0EA6        (1027) ;    The A and X registers may be modified by this or future implementations
0EA2: 50 00    MOV   A,0           (1028) ;    of this function.  The same is true for all RAM page pointer registers in
0EA4: 80 11    JMP   0x0EB6        (1029) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1030) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1031) ;    functions.
0EA6: 3D FA 06 CMP   [X-6],6       (1032) ;
0EA9: D0 07    JNC   0x0EB1        (1033) ;
0EAB: 52 FA    MOV   A,[X-6]       (1034)  LCD_Delay50uTimes:
0EAD: 15 FA    SUB   [X-6],A       (1035) _LCD_Delay50uTimes:
0EAF: 80 06    JMP   0x0EB6        (1036)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (1037)     call  LCD_Delay50u
                                   (1038)     dec   A
0EB1: 50 06    MOV   A,6           (1039)     jnz   LCD_Delay50uTimes
0EB3: 17 FA 05 SUB   [X-6],5       (1040)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1041)     ret
                                   (1042) 
0EB6: 9E 6F    CALL  0x0D27        (1043) .ENDSECTION
                                   (1044) 
0EB8: 7B FB    DEC   [X-5]         (1045) ;-----------------------------------------------------------------------------
0EBA: BF E2    JNZ   0x0E9D        (1046) ;  FUNCTION NAME: LCD_Delay50u
0EBC: 70 3F    AND   F,63
0EBE: 71 C0    OR    F,192         (1047) ;
0EC0: 7F       RET                 (1048) ;  DESCRIPTION:
                                   (1049) ;     Delay 50uSec for any clock frequency from 1.5MHz to 24MHz
                                   (1050) ;     Slower clock frequencies the delay will be;
                                   (1051) ;           1.5
                                   (1052) ;        -------------- * 50uSec
                                   (1053) ;        clock_freq(MHz)
                                   (1054) ;
                                   (1055) ;
                                   (1056) ;-----------------------------------------------------------------------------
                                   (1057) ;
                                   (1058) ;  ARGUMENTS: none
                                   (1059) ;
                                   (1060) ;  RETURNS: none
                                   (1061) ;
                                   (1062) ;  SIDE EFFECTS:
                                   (1063) ;    The A and X registers may be modified by this or future implementations
                                   (1064) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1065) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1066) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1067) ;    functions.
                                   (1068) ;
                                   (1069) ;  THEORY of OPERATION or PROCEDURE:
                                   (1070) ;
                                   (1071) .LITERAL
                                   (1072)  LCD_Delay50u_Table::
                                   (1073)      DB    08h,  19h,   3Ah,   7Ch,   01h,    01h,    01h,   01h
                                   (1074) ;         3MHz, 6MHz, 12MHz, 24MHz, 1.5MHz, 750kHz, 188kHz, 94kHz
                                   (1075) .ENDLITERAL
                                   (1076) .SECTION
                                   (1077) 
                                   (1078)   LCD_Delay50u:
                                   (1079)  _LCD_Delay50u:                        ; [11]  Call
                                   (1080)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (1081)     push  A
                                   (1082)     M8C_SetBank1                         ; [4]
                                   (1083)     mov   A, reg[OSC_CR0]                ; [6] Get delay value
                                   (1084)     M8C_SetBank0                         ; [4]
                                   (1085)     and   A,07h                          ; [4] Mask off only the clock bits
                                   (1086)     cmp   A,05h
                                   (1087)     jnc   .Delay50u_End
                                   (1088)     index LCD_Delay50u_Table ; [13] Get delay value
                                   (1089) .Delay50u_Loop:                          ;
                                   (1090)     dec   A                              ; [4]
                                   (1091)     jnz   .Delay50u_Loop                 ; [5]
                                   (1092) .Delay50u_End:
                                   (1093)     pop   A
                                   (1094)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1095)     ret
                                   (1096) .ENDSECTION
                                   (1097) 
                                   (1098) 
                                   (1099) ;-----------------------------------------------------------------------------
                                   (1100) ;      If bargraph is not enabled, the following functions are not required.
                                   (1101) ;-----------------------------------------------------------------------------
                                   (1102) 
                                   (1103) IF (LCD_BARGRAPH_ENABLE)
                                   (1104) 
                                   (1105) IF SYSTEM_SMALL_MEMORY_MODEL
                                   (1106) .SECTION
                                   (1107) ;-----------------------------------------------------------------------------
                                   (1108) ;  FUNCTION NAME: LCD_DrawBG
                                   (1109) ;
                                   (1110) ;  DESCRIPTION:
                                   (1111) ;  This legacy fastcall version are provided only to support existing small
                                   (1112) ;  memory model assembly language code---it does not work in the large memory
                                   (1113) ;  model.
                                   (1114) ;
                                   (1115) ;  ** This legacy fastcall version is provided on a temporary basis to
                                   (1116) ;  ** ease the transition to the 4.2 release of PSoC Designer. Its use is
                                   (1117) ;  ** deprecated and its status is "No Further Maintenance". If you call this
                                   (1118) ;  ** function in assembly you should convert to _LCD_DrawVBG
                                   (1119) ;  ** (with a leading underscore) and the fastcall16 interface
                                   (1120) ;
                                   (1121) ;  Draw a horizontal bargraph on the LCD with the given parameters.  This
                                   (1122) ;  is a legacy function that is intended to support existing Assembly
                                   (1123) ;  language programs that call this function.  This should not be used for
                                   (1124) ;  new code or with Large Memory Model programs.
                                   (1125) ;-----------------------------------------------------------------------------
                                   (1126) ;
                                   (1127) ;  LEGACY FASTCALL ARGUMENTS:
                                   (1128) ;    A    => Starting row for bargraph 0 to 3
                                   (1129) ;   [X]   => Starting Column for bargraph 0 to 39+
                                   (1130) ;   [x-1] => Length of bargraph in chars 1 to 40+
                                   (1131) ;   [X-2] => Position of pointer in segments 5 times Length
                                   (1132) ;
                                   (1133) ;
                                   (1134) ;  RETURNS:  none
                                   (1135) ;
                                   (1136) ;  SIDE EFFECTS:
                                   (1137) ;    The A and X registers may be modified by this or future implementations
                                   (1138) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1139) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1140) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1141) ;    functions.
                                   (1142) ;
                                   (1143) ;    If LCD_Init is not called before this function, the
                                   (1144) ;    bargraph will not be drawn properly.
                                   (1145) ;
                                   (1146) ; Stack offset constants
                                   (1147) BG_COLX:       equ  0                   ; Stack position of Column
                                   (1148) BG_CHAR_LENX:  equ -1                   ; Stack position of Length
                                   (1149) BG_LENGTHX:    equ -2                   ; Stack position of bargraph pointer position
                                   (1150) 
                                   (1151) 
                                   (1152) LCD_DrawBG:
                                   (1153)     push  X
                                   (1154)     mov   X,[X+BG_COLX]                 ; Row in A, Col in X
                                   (1155)     call  LCD_Position                 ; Set cursor position
                                   (1156)     pop   X                             ; Restore pointer
                                   (1157) 
                                   (1158) .LCD_BG_LOOP1X:
                                   (1159)     cmp   [X+BG_LENGTHX],00h            ; Check for past end of BG
                                   (1160)     jnz   .LCD_CHECK1X
                                   (1161)     mov   A,00h                         ; Load empty character
                                   (1162)     jmp   .LCD_BG_DOITX                 ;
                                   (1163) 
                                   (1164) .LCD_CHECK1X:
                                   (1165)     cmp   [X+BG_LENGTHX],06h            ; Check if BG pointer is at this character
                                   (1166)     jnc   .LCD_CHECK2X                  ; Note yet, use full character
                                   (1167)     mov   A,[X+BG_LENGTHX]
                                   (1168)     sub   [X+BG_LENGTHX],A
0EC1: 4F       MOV   X,SP          (1169)     jmp   .LCD_BG_DOITX
0EC2: 52 FD    MOV   A,[X-3]       (1170) 
0EC4: 21 03    AND   A,3           (1171) .LCD_CHECK2X:                           ; Put index to full character
                                   (1172)     mov   A, 06h
0EC6: 08       PUSH  A             (1173)     sub   [X+BG_LENGTHX],05h            ; Subtract another 5 positions
0EC7: FF 91    INDEX 0x0E5A        (1174) 
0EC9: 03 FC    ADD   A,[X-4]       (1175) .LCD_BG_DOITX:
0ECB: 9E 6E    CALL  0x0D3B        (1176)     call  LCD_WriteData                ; Display BG character
0ECD: 3D FA 00 CMP   [X-6],0       (1177) 
0ED0: B0 05    JNZ   0x0ED6        (1178)     dec   [X+BG_CHAR_LENX]              ; Dec Char count
0ED2: 50 20    MOV   A,32          (1179)     jnz   .LCD_BG_LOOP1X                ; Do it all over again
0ED4: 80 13    JMP   0x0EE8        (1180)     ret
                                   (1181) .ENDSECTION
0ED6: 3D FA 09 CMP   [X-6],9       (1182) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
0ED9: D0 09    JNC   0x0EE3        (1183) 
                                   (1184) .SECTION
0EDB: 52 FA    MOV   A,[X-6]       (1185) ;-----------------------------------------------------------------------------
0EDD: 78       DEC   A             (1186) ;  FUNCTION NAME: LCD_DrawBG
0EDE: 56 FA 00 MOV   [X-6],0       (1187) ;
0EE1: 80 06    JMP   0x0EE8        (1188) ;  DESCRIPTION:
                                   (1189) ;     Draw a horizontal bargraph on the LCD with the given parameters.
                                   (1190) ;
0EE3: 17 FA 08 SUB   [X-6],8       (1191) ;
0EE6: 50 07    MOV   A,7           (1192) ;-----------------------------------------------------------------------------
                                   (1193) ;
                                   (1194) ;  FASTCALL16 ARGUMENTS:
0EE8: 9E 3D    CALL  0x0D27        (1195) ;   [SP-3] => Starting row for bargraph 0 to 3
0EEA: 18       POP   A             (1196) ;   [SP-4] => Starting Column for bargraph 0 to 39+
0EEB: 78       DEC   A             (1197) ;   [SP-5] => Length of bargraph in chars 1 to 40+
0EEC: 7B FB    DEC   [X-5]         (1198) ;   [SP-6] => Position of pointer in segments 5 times Length
0EEE: BF D7    JNZ   0x0EC6        (1199) ;
0EF0: 70 3F    AND   F,63
0EF2: 71 C0    OR    F,192         (1200) ;
0EF4: 7F       RET                 (1201) ;  RETURNS:  none
                                   (1202) ;
                                   (1203) ;  SIDE EFFECTS:
                                   (1204) ;    The A and X registers may be modified by this or future implementations
                                   (1205) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1206) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1207) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1208) ;    functions.
                                   (1209) ;          
                                   (1210) ;    Currently only the page pointer registers listed below are modified: 
                                   (1211) ;          CUR_PP
                                   (1212) ;
                                   (1213) ;    If LCD_Init is not called before this function, the
                                   (1214) ;    bargraph will not be drawn properly.
                                   (1215) ;
                                   (1216) ; Stack offset constants
                                   (1217) BG_ROW:       equ -3
                                   (1218) BG_COL:       equ -4                   ; Stack position of Column
                                   (1219) BG_CHAR_LEN:  equ -5                   ; Stack position of Length
                                   (1220) BG_LENGTH:    equ -6                   ; Stack position of bargraph pointer position
                                   (1221) 
                                   (1222) 
                                   (1223) _LCD_DrawBG:
                                   (1224)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1225)     mov   X, SP
                                   (1226)     push  X
                                   (1227)     mov   A,[X+BG_ROW]                 ; Row in A
                                   (1228)     mov   X,[X+BG_COL]                 ; Col in X
                                   (1229)     RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1230)     call  LCD_Position                 ; Set cursor position
                                   (1231)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1232)     pop  X
                                   (1233) 
                                   (1234) .LCD_BG_LOOP1:
                                   (1235)     cmp   [X+BG_LENGTH],00h            ; Check for past end of BG
                                   (1236)     jnz   .LCD_CHECK1
                                   (1237)     mov   A,00h                        ; Load empty character
                                   (1238)     jmp   .LCD_BG_DOIT                  ;
0EF5: 4F       MOV   X,SP          (1239) 
0EF6: 08       PUSH  A             (1240) .LCD_CHECK1:
0EF7: 08       PUSH  A             (1241)     cmp   [X+BG_LENGTH],06h            ; Check if BG pointer is at this character
                                   (1242)     jnc   .LCD_CHECK2                   ; Note yet, use full character
0EF8: 50 40    MOV   A,64          (1243)     mov   A,[X+BG_LENGTH]
0EFA: 9E 3F    CALL  0x0D3B        (1244)     sub   [X+BG_LENGTH],A
0EFC: 56 00 01 MOV   [X+0],1       (1245)     jmp   .LCD_BG_DOIT
                                   (1246) 
                                   (1247) .LCD_CHECK2:                            ; Put index to full character
0EFF: 56 01 08 MOV   [X+1],8       (1248)     mov   A, 06h
                                   (1249)     sub   [X+BG_LENGTH],05h            ; Subtract another 5 positions
0F02: 52 00    MOV   A,[X+0]       (1250) 
0F04: 3B 01    CMP   A,[X+1]       (1251) .LCD_BG_DOIT:
0F06: D0 05    JNC   0x0F0C        (1252)     call  LCD_WriteData                ; Display BG character
0F08: 50 00    MOV   A,0           (1253) 
0F0A: 80 03    JMP   0x0F0E        (1254)     dec   [X+BG_CHAR_LEN]              ; Dec Char count
                                   (1255)     jnz   .LCD_BG_LOOP1                 ; Do it all over again
0F0C: 50 FF    MOV   A,255         (1256)     RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1257)     ret
0F0E: 9E 17    CALL  0x0D27        (1258) .ENDSECTION
0F10: 7B 01    DEC   [X+1]         (1259) 
0F12: BF EF    JNZ   0x0F02        (1260) IF SYSTEM_SMALL_MEMORY_MODEL
0F14: 77 00    INC   [X+0]         (1261) .SECTION
0F16: 3D 00 09 CMP   [X+0],9       (1262) ;-----------------------------------------------------------------------------
0F19: BF E5    JNZ   0x0EFF        (1263) ;  FUNCTION NAME: LCD_DrawVBG
                                   (1264) ;
0F1B: 18       POP   A             (1265) ;  DESCRIPTION:
0F1C: 18       POP   A             (1266) ;  This legacy fastcall version are provided only to support existing small
0F1D: 50 0C    MOV   A,12          (1267) ;  memory model assembly language code---it does not work in the large memory
0F1F: 9E 1A    CALL  0x0D3B        (1268) ;  model.
0F21: 70 3F    AND   F,63
0F23: 71 C0    OR    F,192         (1269) ;
0F25: 7F       RET                 (1270) ;  ** This legacy fastcall version is provided on a temporary basis to
0F26: 00       SWI   
0F27: 10       PUSH  X
0F28: 18       POP   A
0F29: 1C 1E    SBB   [30],A
0F2B: 1F 1F 00 SBB   [X+31],0
0F2E: 10       PUSH  X
0F2F: 08       PUSH  A
0F30: 04 02    ADD   [2],A
0F32: 01 00    ADD   A,0
                                   (1271) ;  ** ease the transition to the 4.2 release of PSoC Designer. Its use is
                                   (1272) ;  ** deprecated and its status is "No Further Maintenance". If you call this
                                   (1273) ;  ** function in assembly you should convert to _LCD_DrawVBG
                                   (1274) ;  ** (with a leading underscore) and the fastcall16 interface
                                   (1275) ;
                                   (1276) ;  Draw a vertical bargraph on the LCD with the given parameters. This
                                   (1277) ;  is a legacy function that is intended to support existing Assembly
                                   (1278) ;  language programs that call this function.  This should not be used for
                                   (1279) ;  new code or with Large Memory Model programs.
                                   (1280) ;-----------------------------------------------------------------------------
                                   (1281) ;
                                   (1282) ;  LEGACY FASTCALL ARGUMENTS:
                                   (1283) ;    A    => Starting row for bargraph 0 to 3
                                   (1284) ;   [X]   => Starting Column for bargraph 0 to 40+
                                   (1285) ;   [x-1] => Height of bargraph in chars 1 - 4
                                   (1286) ;   [X-2] => Position of pointer in segments 8 times height
                                   (1287) ;  RETURNS:
                                   (1288) ;
                                   (1289) ;  SIDE EFFECTS:
                                   (1290) ;    The A and X registers may be modified by this or future implementations
                                   (1291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1293) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1294) ;    functions.
                                   (1295) ;    
                                   (1296) ;    If LCD_Init is not called before this function, the
                                   (1297) ;    bargraph will not be drawn properly.
                                   (1298) ;
                                   (1299) ; Stack offset constants
                                   (1300) VBG_COLX:            equ  0
                                   (1301) VBG_CHAR_HEIGHTX:    equ -1
                                   (1302) VBG_SEG_HEIGHTX:     equ -2
                                   (1303) 
                                   (1304) LCD_DrawVBG:
                                   (1305) 
                                   (1306)     and   A,03h                        ; Make sure only rows 0 - 3 are valid
                                   (1307) .VBG_LOOPX:
                                   (1308)     push  A
                                   (1309)     index LCD_ROW_OFFSET  ; Get row offset
                                   (1310)     add   A,[X+VBG_COLX]                ; Add column offset to position
                                   (1311)     call  LCD_Control                  ; Position Cursor
                                   (1312)     cmp   [X+VBG_SEG_HEIGHTX],00h       ; Check for zero segs
                                   (1313)     jnz   .VBG_NZ_SEGX
                                   (1314)     mov   A,' '                        ; Load space character
                                   (1315)     jmp   .VBG_WRITE_CHARX
                                   (1316) .VBG_NZ_SEGX:
                                   (1317)     cmp   [X+VBG_SEG_HEIGHTX],09h       ; Check for full segment
                                   (1318)     jnc   .VBG_FULL_SEGX
                                   (1319)                                         ; Partial segment between 1 and 8
0F34: 4F       MOV   X,SP          (1320)     mov   A,[X+VBG_SEG_HEIGHTX]
0F35: 38 03    ADD   SP,3          (1321)     dec   A
0F37: 54 02    MOV   [X+2],A       (1322)     mov   [X+VBG_SEG_HEIGHTX],00h       ; Zero segment height
                                   (1323)     jmp   .VBG_WRITE_CHARX
0F39: 50 40    MOV   A,64          (1324) 
0F3B: 9D FE    CALL  0x0D3B        (1325) .VBG_FULL_SEGX:                          ; Bargaph
0F3D: 56 00 00 MOV   [X+0],0       (1326)     sub   [X+VBG_SEG_HEIGHTX],08h       ; Subtract full segment
                                   (1327)     mov   A,07h                        ; Load full segment
                                   (1328) 
0F40: 56 01 08 MOV   [X+1],8       (1329) .VBG_WRITE_CHARX:                        ; Write character to display
                                   (1330)     call  LCD_WriteData                ; Write value
0F43: 52 00    MOV   A,[X+0]       (1331)     pop   A
0F45: 3D 02 00 CMP   [X+2],0       (1332)     dec   A
0F48: B0 05    JNZ   0x0F4E        (1333)     dec   [X+VBG_CHAR_HEIGHTX]
0F4A: FF DA    INDEX 0x0F26        (1334)     jnz   .VBG_LOOPX
0F4C: 80 03    JMP   0x0F50        (1335)     ret
                                   (1336) .ENDSECTION
0F4E: FF DD    INDEX 0x0F2D        (1337) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                   (1338) 
0F50: 9D D5    CALL  0x0D27        (1339) .SECTION
0F52: 7B 01    DEC   [X+1]         (1340) ;-----------------------------------------------------------------------------
0F54: BF EE    JNZ   0x0F43        (1341) ;  FUNCTION NAME: LCD_DrawVBG
0F56: 77 00    INC   [X+0]         (1342) ;
0F58: 3D 00 07 CMP   [X+0],7       (1343) ;  DESCRIPTION:
0F5B: BF E4    JNZ   0x0F40        (1344) ;     Draw a vertical bargraph on the LCD with the given parameters.
                                   (1345) ;
0F5D: 38 FD    ADD   SP,253        (1346) ;
0F5F: 50 0C    MOV   A,12          (1347) ;-----------------------------------------------------------------------------
0F61: 9D D8    CALL  0x0D3B        (1348) ;
0F63: 70 3F    AND   F,63
0F65: 71 C0    OR    F,192         (1349) ;  FASTCALL16 ARGUMENTS:
0F68: 7F       RET                 (1350) ;

FILE: lib\e2prom.asm
                                   (0106) ;;*****************************************************************************
                                   (0107) ;;*****************************************************************************
                                   (0108) ;;  FILENAME:   E2PROM.asm
                                   (0109) ;;  Version: 1.7, Updated on 2009/6/23 at 19:32:46
                                   (0110) ;;  Generated by PSoC Designer 5.0.972.0
                                   (0111) ;;
                                   (0112) ;;  DESCRIPTION: EEPROM emulation User Module implementation file
                                   (0113) ;;     for CY8C22/24/26/27/29xxx and related devices.
                                   (0114) ;;
                                   (0115) ;;     Routines in this file perform E2PROM User Module Read and
                                   (0116) ;;     Write operations.
                                   (0117) ;;
                                   (0118) ;;     They provide a layer of abstraction on top of the E2PROMLIB.asm routines
                                   (0119) ;;     to allow instancing of the EEPROM devices.  Together the E2PROM and
                                   (0120) ;;     E2PROMLIB algorithms emulate a byte-wise EEPROM device on a block oriented
                                   (0121) ;;     flash architecture.
                                   (0122) ;;
                                   (0123) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0124) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0125) ;;        This means it is the caller's responsibility to preserve any values
                                   (0126) ;;        in the X and A registers that are still needed after the API functions
                                   (0127) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0128) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0129) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0130) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0131) ;;-----------------------------------------------------------------------------
                                   (0132) ;;  Copyright (c) Cypress MicroSystems 2001-2004. All Rights Reserved.
                                   (0133) ;;*****************************************************************************
                                   (0134) ;;*****************************************************************************
                                   (0135) 
                                   (0136) ;Preset CPU_EQUATE for CY8C25/26xxx identification
                                   (0137) CPU_F:   equ   0
0F69: 7F       RET                 (0138) 
                                   (0139) include "m8c.inc"
                                   (0140) include "E2PROM.inc"
                                   (0141) include "memory.inc"
                                   (0142) 
                                   (0143) ;-------------------------------------------------------------------
                                   (0144) ;  Declare the functions global for both assembler and C compiler.
                                   (0145) ;
                                   (0146) ;  Note that there are two names for each API. First name is
                                   (0147) ;  assembler reference. Name with underscore is name refence for
                                   (0148) ;  C compiler.  Calling function in C source code does not require
                                   (0149) ;  the underscore.
                                   (0150) ;-------------------------------------------------------------------
                                   (0151) 
                                   (0152) ;-----------------------------------------------
                                   (0153) ;  Global Symbols
                                   (0154) ;-----------------------------------------------
                                   (0155) 
                                   (0156) export   E2PROM_Start
                                   (0157) export  _E2PROM_Start
                                   (0158) export   E2PROM_Stop
                                   (0159) export  _E2PROM_Stop
                                   (0160) export   E2PROM_bE2Write
                                   (0161) export  _E2PROM_bE2Write
                                   (0162) export   E2PROM_E2Read
                                   (0163) export  _E2PROM_E2Read
                                   (0164) 
                                   (0165) export   E2PROM_RESERVED
                                   (0166) 
                                   (0167) ;-----------------------------------------------------------------
                                   (0168) ;  Allocate the E2PROM EEPROM device in Flash memory
                                   (0169) ;     This will allow the linker to perform memory collision
                                   (0170) ;     checking and the EEPROM device will be displayed in the
                                   (0171) ;     map file.
                                   (0172) ;     Note that this memory region can also be accessed from "C".
                                   (0173) ;-----------------------------------------------------------------
                                   (0174) AREA  E2PROM_AREA   (ROM,ABS,CON)
                                   (0175)    ORG   E2PROM_START_ADDR
                                   (0176) 
                                   (0177) _E2PROM_RESERVED::
                                   (0178)  E2PROM_RESERVED::     blkb     180h
                                   (0179) 
                                   (0180) 
                                   (0181) AREA  UserModules (ROM,REL)
                                   (0182) 
                                   (0183) ;-----------------------------------------------------------------------------
                                   (0184) ;  FUNCTION NAME: E2PROM_Start
                                   (0185) ;
                                   (0186) ;  DESCRIPTION:
                                   (0187) ;     Start routine for the E2PROM user module.  This routine is
                                   (0188) ;     a place holder for conformance and consistency.
                                   (0189) ;-----------------------------------------------------------------------------
                                   (0190) ;
                                   (0191) ;  ARGUMENTS:
                                   (0192) ;     None
                                   (0193) ;
                                   (0194) ;  RETURNS:
                                   (0195) ;     None
                                   (0196) ;
                                   (0197) ;  SIDE EFFECTS: 
                                   (0198) ;    The A and X registers may be modified by this or future implementations
                                   (0199) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0200) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0201) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0202) ;    functions.
                                   (0203) ;
                                   (0204) .SECTION
                                   (0205) 
                                   (0206)  E2PROM_Start:
                                   (0207) _E2PROM_Start:
                                   (0208)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0209)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0210)    ret
                                   (0211) 
                                   (0212) .ENDSECTION
                                   (0213) 
                                   (0214) 
0F6A: 5D F7    MOV   A,REG[247]    (0215) ;-----------------------------------------------------------------------------
0F6C: 08       PUSH  A             (0216) ;  FUNCTION NAME: E2PROM_Stop
                                   (0217) ;
0F6D: 50 01    MOV   A,1           (0218) ;  DESCRIPTION:
0F6F: 08       PUSH  A             (0219) ;     Stop routine for the E2PROM user module.  This routine is
0F70: 50 C8    MOV   A,200         (0220) ;     a place holder for conformance and consistency.
0F72: 08       PUSH  A             (0221) ;
0F73: 7D 10 7E LJMP  0x107E        (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;
                                   (0224) ;  ARGUMENTS:
                                   (0225) ;     None
                                   (0226) ;
                                   (0227) ;  RETURNS:
                                   (0228) ;     None
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS: 
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237) .SECTION
                                   (0238) 
                                   (0239)  E2PROM_Stop:
                                   (0240) _E2PROM_Stop:
                                   (0241)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0242)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0243)    ret
                                   (0244) 
                                   (0245) .ENDSECTION
                                   (0246) 
                                   (0247) 
                                   (0248) ;-----------------------------------------------------------------------------
                                   (0249) ;  FUNCTION NAME: E2PROM_E2Write
                                   (0250) ;
                                   (0251) ;  DESCRIPTION:
                                   (0252) ;     Writes the specified E2PROM data at the wAddr and wByteCount from RAM into
                                   (0253) ;     Flash into the defined E2PROM instance.
                                   (0254) ;
                                   (0255) ;     Prototype in C is:
                                   (0256) ;
                                   (0257) ;        #pragma  fastcall16 E2Write
                                   (0258) ;        void E2PROM_bE2Write( WORD wAddr, BYTE * pbData, WORD wByteCount,
                                   (0259) ;                                        CHAR cTemperature );
                                   (0260) ;
                                   (0261) ;     Easiest method to call from assembly is as follows:
                                   (0262) ;           push  X                    ; push X only if X needs to be perserved
                                   (0263) ;           mov   X, SP
                                   (0264) ;           push  <cTemperature>
                                   (0265) ;           push  <wByteCount>
                                   (0266) ;           push  <wByteCount+1>
                                   (0267) ;           push  <pbDataDest>                  
                                   (0268) ;           push  <pbDataDest+1>
                                   (0269) ;           push  <wAddr>
                                   (0270) ;           push  <wAddr+1>
                                   (0271) ;           call  E2PROM_bE2Write
                                   (0272) ;           add   SP, -E2_RD_ARG_STACK_FRAME_SIZE
                                   (0273) ;           pop   X                    ; restore X only if it was saved above
                                   (0274) ;
                                   (0275) ;           where <> refers to any addressing mode or number of instructions to
                                   (0276) ;              place the referenced data on the stack frame.
                                   (0277) ;
                                   (0278) ;     Other method is to create a stack frame using the defined equates and
                                   (0279) ;     load them into the stack frame using [X+E2_WR_ARG_*] offset addressing mode.
                                   (0280) ;     If this method is used in the LMM (large memory model) then make sure
                                   (0281) ;     that the index page tracks the stack page or is set to the same page
                                   (0282) ;     as the stack page.
                                   (0283) ;
                                   (0284) ;-----------------------------------------------------------------------------
                                   (0285) ;
                                   (0286) ;  ARGUMENTS:
                                   (0287) ;     wAddr:         WORD   - relative OFFSET in defined E2PROM to write data
                                   (0288) ;     pbData:        BYTE * - pointer to the RAM buffer of data to write
                                   (0289) ;     wByteCount:    WORD   - number of bytes to write into E2PROM
                                   (0290) ;     cTemperature:  CHAR   - temperature in degrees celsius
                                   (0291) ;
                                   (0292) ;  RETURNS:    E2PROM_NOERROR, E2PROM_FAILURE, or
                                   (0293) ;              E2PROM_STACKOVERFLOW
                                   (0294) ;
                                   (0295) ;  SIDE EFFECTS: 
0F76: 5D F7    MOV   A,REG[247]    (0296) ;    If a partial block is to be saved to flash, then a 64 byte buffer
0F78: 08       PUSH  A             (0297) ;    is temporary allocated.
                                   (0298) ;
                                   (0299) ;    The A and X registers may be modified by this or future implementations
                                   (0300) ;    of this function.  The same is true for all RAM page pointer registers in
0F79: 50 01    MOV   A,1           (0301) ;    the Large Memory Model.  When necessary, it is the calling function's
0F7B: 5C       MOV   X,A           (0302) ;    responsibility to perserve their values across calls to fastcall16 
0F7C: 50 C8    MOV   A,200         (0303) ;    functions.
0F81: 21 03    AND   A,3           (0304) ;          

FILE: lib\amux4_adc.asm
0F83: 57 00    MOV   X,0           (0083) ;;*****************************************************************************
                                   (0084) ;;*****************************************************************************
0F85: 79       DEC   X             (0085) ;;  FILENAME:   AMUX4_ADC.asm
0F86: C0 05    JC    0x0F8C        (0086) ;;  Version: 1.4, Updated on 2009/6/23 at 19:29:19
0F88: 64       ASL   A             (0087) ;;  Generated by PSoC Designer 5.0.972.0
0F89: 64       ASL   A             (0088) ;;
0F8A: 8F FA    JMP   0x0F85        (0089) ;;  DESCRIPTION: AMux4 User Module software implementation file
                                   (0090) ;;               for 22/24/25/26/27xxx PSoC family devices.
                                   (0091) ;;
0F8C: 4F       MOV   X,SP          (0092) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
0F8D: 08       PUSH  A             (0093) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0094) ;;        This means it is the caller's responsibility to preserve any values
                                   (0095) ;;        in the X and A registers that are still needed after the API functions
                                   (0096) ;;        returns. For Large Memory Model devices it is also the caller's 
0F8E: 5D 60    MOV   A,REG[96]     (0097) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0098) ;;        MVW_PP registers. Even though some of these registers may not be modified
0F90: 21 FC    AND   A,252         (0099) ;;        now, there is no guarantee that will remain the case in future releases.
0F92: 2B 00    OR    A,[X+0]       (0100) ;;-----------------------------------------------------------------------------
                                   (0101) ;;  Copyright (c) Cypress MicroSystems 2002-2003. All Rights Reserved.
                                   (0102) ;;*****************************************************************************
                                   (0103) ;;*****************************************************************************
0F94: 60 60    MOV   REG[96],A     (0104) 
                                   (0105) 
0F96: 18       POP   A             (0106) include "AMUX4_ADC.inc"
0F97: 70 3F    AND   F,63
                                   (0107) include "m8c.inc"
                                   (0108) include "memory.inc"
                                   (0109) 
                                   (0110) ;-----------------------------------------------
0F99: 71 C0    OR    F,192         (0111) ;  Global Symbols
0F9B: 7F       RET                 (0112) ;-----------------------------------------------
                                   (0113) export  AMUX4_ADC_InputSelect
                                   (0114) export _AMUX4_ADC_InputSelect
                                   (0115) 
                                   (0116) export  AMUX4_ADC_Start
                                   (0117) export _AMUX4_ADC_Start
                                   (0118) 
                                   (0119) export  AMUX4_ADC_Stop
                                   (0120) export _AMUX4_ADC_Stop
                                   (0121) 
                                   (0122) ;-----------------------------------------------
                                   (0123) ;  EQUATES
                                   (0124) ;-----------------------------------------------
                                   (0125) 
                                   (0126) MUXMASK:                     equ 03h
                                   (0127) 
                                   (0128) AREA UserModules (ROM, REL)
                                   (0129) .SECTION
                                   (0130) ;-----------------------------------------------------------------------------
                                   (0131) ;  FUNCTION NAME: AMUX4_ADC_InputSelect
                                   (0132) ;
                                   (0133) ;  DESCRIPTION:
                                   (0134) ;    Place the signal from one of four port0 pins on the Analog Column bus.
                                   (0135) ;
                                   (0136) ;-----------------------------------------------------------------------------
                                   (0137) ;
                                   (0138) ;  ARGUMENTS:
                                   (0139) ;    A contains the mux input control value
0F9C: 7F       RET                 (0140) ;
                                   (0141) ;      Input           Code
                                   (0142) ;   Mux input 0,1       00h
                                   (0143) ;   Mux input 2,3       01h
                                   (0144) ;   Mux input 4,5       02h
                                   (0145) ;   Mux input 6,7       03h
                                   (0146) ;
                                   (0147) ;  RETURNS: none
                                   (0148) ;
                                   (0149) ;  SIDE EFFECTS:
                                   (0150) ;    The A and X registers may be modified by this or future implementations
                                   (0151) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0152) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0153) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0154) ;    functions.
                                   (0155) ;
                                   (0156)  AMUX4_ADC_InputSelect:
                                   (0157) _AMUX4_ADC_InputSelect:
                                   (0158)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (0159) 	
                                   (0160) IF (AMUX4_ADC_COL_COUNT)
                                   (0161) 	M8C_SetBank1      ; ACE_AMX_IN is in Bank 1
                                   (0162) ENDIF
                                   (0163) 	
                                   (0164)     and  A, MUXMASK                    ; Mask off only valid port0 input bits
                                   (0165)     mov  X,AMUX4_ADC_MUX_COL
                                   (0166) .AMUX4_ShiftIt:                         ; Shift value to correct bit position for Mux
                                   (0167)     dec  X
0F9E: 76 06    INC   [6]           (0168)     jc   .AMUX4_SetIt

FILE: lib\adcinc12int.asm
                                   (0089) ;;*****************************************************************************
                                   (0090) ;;*****************************************************************************
                                   (0091) ;;  FILENAME:   ADCINC12INT.asm
                                   (0092) ;;  Version: 5.3, Updated on 2009/6/23 at 19:29:4
                                   (0093) ;;  Generated by PSoC Designer 5.0.972.0
                                   (0094) ;;
                                   (0095) ;;  DESCRIPTION:
                                   (0096) ;;    Assembler source for interrupt routines the 12 bit Incremential
                                   (0097) ;;    A/D converter.
                                   (0098) ;;-----------------------------------------------------------------------------
                                   (0099) ;;  Copyright (c) Cypress MicroSystems 2002-2003. All Rights Reserved.
0FA0: 7E       RETI                (0100) ;;*****************************************************************************
                                   (0101) ;;*****************************************************************************
                                   (0102) 
                                   (0103) include "ADCINC12.inc"
                                   (0104) include "m8c.inc"
                                   (0105) include "memory.inc"
                                   (0106) 
                                   (0107) ;-----------------------------------------------
                                   (0108) ;  Global Symbols
                                   (0109) ;-----------------------------------------------
                                   (0110) export _ADCINC12_CNT_ISR
                                   (0111) export _ADCINC12_TMR_ISR
                                   (0112) export  ADCINC12_cTimerU
0FA1: 7A 05    DEC   [5]           (0113) export  ADCINC12_cCounterU
                                   (0114) export _ADCINC12_iIncr
0FA3: A0 02    JZ    0x0FA6        (0115) export  ADCINC12_iIncr
0FA5: 7E       RETI                (0116) export _ADCINC12_fIncr
                                   (0117) export  ADCINC12_fIncr
0FA6: 49 83 10 TST   REG[131],16   (0118) export  ADCINC12_bIncrC
0FA9: A0 0F    JZ    0x0FB9        (0119) 
                                   (0120) ;-----------------------------------------------
0FAB: 40       NOP                 (0121) ; Variable Allocation
                                   (0122) ;-----------------------------------------------
                                   (0123) AREA InterruptRAM (RAM,REL,CON)
0FAC: 62 27 05 MOV   REG[39],5     (0124)     ADCINC12_cTimerU:   BLK  1                   ;The Upper byte of the Timer
0FAF: 41 83 EF AND   REG[131],239  (0125)     ADCINC12_cCounterU: BLK  1                   ;The Upper byte of the Counter
                                   (0126)    _ADCINC12_iIncr:
0FB2: 41 82 DF AND   REG[130],223  (0127)     ADCINC12_iIncr:     BLK  2                   ;A/D value
                                   (0128)    _ADCINC12_fIncr:
0FB5: 55 05 40 MOV   [5],64        (0129)     ADCINC12_fIncr:     BLK  1                   ;Data Valid Flag
                                   (0130)     ADCINC12_bIncrC:    BLK  1                   ;# of times to run A/D
0FB8: 7E       RETI                (0131) 
                                   (0132) 
0FB9: 71 10    OR    F,16          (0133) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0FBB: 41 25 0F AND   REG[37],15    (0134) ;---------------------------------------------------
0FBE: 70 EF    AND   F,239         (0135) ; Insert your custom declarations below this banner
                                   (0136) ;---------------------------------------------------
0FC0: 71 01    OR    F,1           (0137) 
                                   (0138) ;------------------------
                                   (0139) ; Includes
                                   (0140) ;------------------------
                                   (0141) 
                                   (0142) 	
                                   (0143) ;------------------------
                                   (0144) ;  Constant Definitions
                                   (0145) ;------------------------
                                   (0146) 
                                   (0147) 
                                   (0148) ;------------------------
                                   (0149) ; Variable Allocation
                                   (0150) ;------------------------
                                   (0151) 
                                   (0152) 
                                   (0153) ;---------------------------------------------------
0FC2: 43 82 20 OR    REG[130],32   (0154) ; Insert your custom declarations above this banner
                                   (0155) ;---------------------------------------------------
0FC5: 43 83 10 OR    REG[131],16   (0156) ;@PSoC_UserCode_END@ (Do not change this line.)
0FC8: 08       PUSH  A             (0157) 
0FC9: 5D 24    MOV   A,REG[36]     (0158) 
0FCB: 5D 26    MOV   A,REG[38]     (0159) AREA UserModules (ROM, REL)
                                   (0160) ;-----------------------------------------------
0FCD: 62 27 00 MOV   REG[39],0     (0161) ;  EQUATES
0FD0: 71 10    OR    F,16          (0162) ;-----------------------------------------------
0FD2: 43 25 40 OR    REG[37],64    (0163) LowByte:   equ 1
0FD5: 70 EF    AND   F,239         (0164) HighByte:  equ 0
                                   (0165) 
                                   (0166) ;-----------------------------------------------------------------------------
0FD7: 73       CPL   A             (0167) ;  FUNCTION NAME: _ADCINC12_CNT_ISR
0FD8: 3C 06 20 CMP   [6],32        (0168) ;
0FDB: B0 05    JNZ   0x0FE1        (0169) ;  DESCRIPTION:
                                   (0170) ;    Increment the upper (software) half on the counter whenever the
0FDD: 7A 06    DEC   [6]           (0171) ;    lower (hardware) half of the counter underflows.
0FDF: 50 FF    MOV   A,255         (0172) ;
                                   (0173) ;-----------------------------------------------------------------------------
0FE1: 68 06    ASR   [6]           (0174) ;
0FE3: 6D       RRC   A             (0175) _ADCINC12_CNT_ISR:
0FE4: 68 06    ASR   [6]           (0176)    inc [ADCINC12_cCounterU]
0FE6: 6D       RRC   A             (0177)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                   (0178)    ;---------------------------------------------------
0FE7: 5F 07 06 MOV   [7],[6]       (0179)    ; Insert your custom code below this banner
0FEA: 53 08    MOV   [8],A         (0180)    ;---------------------------------------------------
0FEC: 55 09 01 MOV   [9],1         (0181)    ;   NOTE: interrupt service routines must preserve
0FEF: 18       POP   A             (0182)    ;   the values of the A and X CPU registers.
                                   (0183) 
                                   (0184)    ;---------------------------------------------------
                                   (0185)    ; Insert your custom code above this banner
                                   (0186)    ;---------------------------------------------------
                                   (0187)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0188)    reti
                                   (0189) 
                                   (0190) ;-----------------------------------------------------------------------------
                                   (0191) ;  FUNCTION NAME: _ADCINC12_TMR_ISR
                                   (0192) ;
                                   (0193) ;  DESCRIPTION:
                                   (0194) ;    This routine allows the counter to collect data for 64 timer cycles
                                   (0195) ;    This routine then holds the integrater in reset for one cycle while
                                   (0196) ;    the A/D value is calculated.
                                   (0197) ;
                                   (0198) ;-----------------------------------------------------------------------------
0FF0: 3C 0A 00 CMP   [10],0        (0199) ;
0FF3: A0 17    JZ    0x100B        (0200) _ADCINC12_TMR_ISR:
                                   (0201)    dec [ADCINC12_cTimerU]
0FF5: 7A 0A    DEC   [10]          (0202) ;  if(upper count >0 )
0FF7: B0 13    JNZ   0x100B        (0203)    jz  else1
                                   (0204)       reti
0FF9: 62 23 00 MOV   REG[35],0     (0205)    else1:;(upper count decremented to 0)
0FFC: 62 27 00 MOV   REG[39],0     (0206)       tst reg[ADCINC12_AtoDcr3],10h
0FFF: 40       NOP                 (0207)       jz   else2
1000: 40       NOP                 (0208) ;     if(A/D has been in reset mode)
1001: 41 E1 FC AND   REG[225],252  (0209)          nop                                     ; Dummy statement to keep time
                                   (0210)                                              ; between turning on and off counter
                                   (0211)                          ; the same.
1004: 43 82 20 OR    REG[130],32   (0212)          mov reg[ADCINC12_CounterCR0],(ADCINC12_fDBLK_ENABLE|ADCINC12_fPULSE_WIDE)    ; Enable Counter
                                   (0213)          and reg[ADCINC12_AtoDcr3],~10h          ; Enable Analog Integrator
1007: 43 83 10 OR    REG[131],16   (0214) IF ADCINC12_NoAZ
100A: 7E       RETI                (0215)          and reg[ADCINC12_AtoDcr2],~20h
                                   (0216) ENDIF
                                   (0217)          mov [ADCINC12_cTimerU],(1<<(ADCINC12_NUMBITS - 6))
                                   (0218)                                                  ; This will be the real counter value
100B: 55 05 01 MOV   [5],1         (0219)          reti
100E: 55 06 E0 MOV   [6],224       (0220)       else2:;(A/D has been in integrate mode)
1011: 62 25 FF MOV   REG[37],255   (0221)          M8C_SetBank1
1015: 10       PUSH  X             (0222)          and reg[ADCINC12_CounterSL], 0x0F       ; Disable input to counter

FILE: lib\adcinc12.asm
1016: 4F       MOV   X,SP          (0085) ;;*****************************************************************************
1017: 21 03    AND   A,3           (0086) ;;*****************************************************************************
1019: 08       PUSH  A             (0087) ;;  FILENAME:   ADCINC12.asm
101A: 5D 83    MOV   A,REG[131]    (0088) ;;  Version: 5.3, Updated on 2009/6/23 at 19:29:4
101C: 21 FC    AND   A,252         (0089) ;;  Generated by PSoC Designer 5.0.972.0
101E: 2B 00    OR    A,[X+0]       (0090) ;;
1020: 60 83    MOV   REG[131],A    (0091) ;;  DESCRIPTION: ADCINC12 12 bit incremental A/D converter User Module
1022: 18       POP   A             (0092) ;;               software implementation file for 22/24/25/26/27xxx PSoC
1023: 20       POP   X             (0093) ;;               family of devices.
1024: 70 3F    AND   F,63
1026: 71 C0    OR    F,192         (0094) ;;
1028: 7F       RET                 (0095) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0096) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0097) ;;        This means it is the caller's responsibility to preserve any values
                                   (0098) ;;        in the X and A registers that are still needed after the API functions
                                   (0099) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0100) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0101) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0102) ;;        now, there is no guarantee that will remain the case in future releases.        
                                   (0103) ;;-----------------------------------------------------------------------------
                                   (0104) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;*****************************************************************************
                                   (0107) 
                                   (0108) include "ADCINC12.inc"
                                   (0109) include "m8c.inc"
                                   (0110) include "memory.inc"
                                   (0111) 
                                   (0112) ;-----------------------------------------------
                                   (0113) ;  Global Symbols
                                   (0114) ;-----------------------------------------------
                                   (0115) export  ADCINC12_Start
                                   (0116) export _ADCINC12_Start
                                   (0117) export  ADCINC12_SetPower
                                   (0118) export _ADCINC12_SetPower
                                   (0119) export  ADCINC12_Stop
                                   (0120) export _ADCINC12_Stop
1029: 41 83 FC AND   REG[131],252  (0121) export  ADCINC12_GetSamples
                                   (0122) export _ADCINC12_GetSamples
102C: 7F       RET                 (0123) export  ADCINC12_StopAD
                                   (0124) export _ADCINC12_StopAD
                                   (0125) export  ADCINC12_fIsData
                                   (0126) export _ADCINC12_fIsData
                                   (0127) export  ADCINC12_fIsDataAvailable
                                   (0128) export _ADCINC12_fIsDataAvailable
                                   (0129) export  ADCINC12_iGetData
                                   (0130) export _ADCINC12_iGetData
                                   (0131) export  ADCINC12_ClearFlag
                                   (0132) export _ADCINC12_ClearFlag
                                   (0133) 
                                   (0134) ;-----------------------------------------------
                                   (0135) ;  EQUATES
                                   (0136) ;-----------------------------------------------
                                   (0137) LowByte:   equ 1
                                   (0138) HighByte:  equ 0
                                   (0139) 
                                   (0140) AREA UserModules (ROM, REL)
                                   (0141) .SECTION
                                   (0142) ;-----------------------------------------------------------------------------
                                   (0143) ;  FUNCTION NAME: ADCINC12_Start
                                   (0144) ;  FUNCTION NAME: ADCINC12_SetPower
                                   (0145) ;
                                   (0146) ;  DESCRIPTION:
                                   (0147) ;     Applies power setting to the module's analog PSoC block.
                                   (0148) ;
                                   (0149) ;-----------------------------------------------------------------------------
                                   (0150) ;
                                   (0151) ;  ARGUMENTS:
                                   (0152) ;    A  contains the power setting
                                   (0153) ;
102D: 62 D0 00 MOV   REG[208],0    (0154) ;  RETURNS: none
1030: 53 0A    MOV   [10],A        (0155) ;
1032: 43 E1 01 OR    REG[225],1    (0156) ;  SIDE EFFECTS:
1035: 43 E1 02 OR    REG[225],2    (0157) ;    The A and X registers may be modified by this or future implementations
                                   (0158) ;    of this function.  The same is true for all RAM page pointer registers in
1038: 55 05 01 MOV   [5],1         (0159) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0160) ;    responsibility to perserve their values across calls to fastcall16 
103B: 43 82 20 OR    REG[130],32   (0161) ;    functions.
                                   (0162) ;
103E: 43 83 10 OR    REG[131],16   (0163)  ADCINC12_Start:
1041: 55 06 E0 MOV   [6],224       (0164) _ADCINC12_Start:
1044: 62 21 FF MOV   REG[33],255   (0165)  ADCINC12_SetPower:
1047: 62 25 FF MOV   REG[37],255   (0166) _ADCINC12_SetPower:
104A: 62 23 01 MOV   REG[35],1     (0167)    RAM_PROLOGUE RAM_USE_CLASS_2
104D: 55 09 00 MOV   [9],0         (0168)    push X                              ;save X
                                   (0169)    mov  X,SP                           ;X will point at next pushed value
1050: 7F       RET                 (0170)    and  A,03h
                                   (0171)    push A                              ;X points at copy of A
                                   (0172)    mov  A,reg[ADCINC12_AtoDcr3]
                                   (0173)    and  A,~03h                         ;clear power bits
                                   (0174)    or   A,[ X ]
                                   (0175)    mov  reg[ADCINC12_AtoDcr3],A
                                   (0176)    pop  A
                                   (0177)    pop  X
                                   (0178)    RAM_EPILOGUE RAM_USE_CLASS_2
                                   (0179)    ret
                                   (0180) .ENDSECTION
                                   (0181) 
                                   (0182) .SECTION
                                   (0183) ;-----------------------------------------------------------------------------
                                   (0184) ;  FUNCTION NAME: ADCINC12_Stop
                                   (0185) ;
                                   (0186) ;  DESCRIPTION:
                                   (0187) ;    Removes power from the module's analog PSoC Block
                                   (0188) ;
                                   (0189) ;-----------------------------------------------------------------------------
                                   (0190) ;
                                   (0191) ;  ARGUMENTS: none
                                   (0192) ;
                                   (0193) ;  RETURNS: none
                                   (0194) ;
                                   (0195) ;  SIDE EFFECTS:
                                   (0196) ;    The A and X registers may be modified by this or future implementations
                                   (0197) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0198) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0199) ;    responsibility to perserve their values across calls to fastcall16 
1051: 62 D0 00 MOV   REG[208],0    (0200) ;    functions.
1054: 62 23 00 MOV   REG[35],0     (0201) ;
1057: 62 27 00 MOV   REG[39],0     (0202)  ADCINC12_Stop:
105A: 40       NOP                 (0203) _ADCINC12_Stop:
105B: 40       NOP                 (0204)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0205)    and reg[ADCINC12_AtoDcr3], ~03h
105C: 41 E1 FE AND   REG[225],254  (0206)    RAM_EPILOGUE RAM_USE_CLASS_1
105F: 41 E1 FD AND   REG[225],253  (0207)    ret
                                   (0208) .ENDSECTION
1062: 43 82 20 OR    REG[130],32   (0209) 
                                   (0210) .SECTION
1065: 43 83 10 OR    REG[131],16   (0211) ;-----------------------------------------------------------------------------
                                   (0212) ;  FUNCTION NAME: ADCINC12_Get_Samples
1068: 7F       RET                 (0213) ;
                                   (0214) ;  DESCRIPTION:
                                   (0215) ;    Starts the A/D convertor and will place data is memory.  A flag
                                   (0216) ;    is set whenever a new data value is available.
                                   (0217) ;
                                   (0218) ;-----------------------------------------------------------------------------
                                   (0219) ;
                                   (0220) ;  ARGUMENTS:
                                   (0221) ;    A  passes the number of samples to be taken.  (0 is continous)
                                   (0222) ;
                                   (0223) ;  RETURNS:
                                   (0224) ;
                                   (0225) ;  SIDE EFFECTS:
                                   (0226) ;    The A and X registers may be modified by this or future implementations
                                   (0227) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0228) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0229) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0230) ;    functions.
                                   (0231) ;          
                                   (0232) ;    Currently only the page pointer registers listed below are modified: 
                                   (0233) ;          CUR_PP
                                   (0234) ;
                                   (0235)  ADCINC12_GetSamples:
                                   (0236) _ADCINC12_GetSamples:
                                   (0237)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0238)    RAM_SETPAGE_CUR >ADCINC12_bIncrC
                                   (0239)    mov [ADCINC12_bIncrC],A                       ;number of samples
                                   (0240)    or  reg[ADCINC12_TimerIntReg],ADCINC12_TimerMask
                                   (0241)    or  reg[ADCINC12_CounterIntReg], ADCINC12_CounterMask
                                   (0242)                                                  ;Enable both interrupts
                                   (0243)    mov [ADCINC12_cTimerU],1                      ;Force the Timer to do one cycle of rest
                                   (0244) IF ADCINC12_NoAZ
                                   (0245)    or  reg[ADCINC12_AtoDcr2],20h                 ;force the Integrator into reset
                                   (0246) ENDIF
1069: 62 D0 00 MOV   REG[208],0    (0247)    or  reg[ADCINC12_AtoDcr3],10h
106C: 51 09    MOV   A,[9]         (0248)    mov [ADCINC12_cCounterU],(-(1<<(ADCINC12_NUMBITS - 7)));Initialize Counter
                                   (0249)    mov reg[ADCINC12_TimerDR1],ffh
106E: 7F       RET                 (0250)    mov reg[ADCINC12_CounterDR1],ffh
                                   (0251)    mov reg[ADCINC12_TimerCR0],01h                ;enable the Timer
                                   (0252)    mov [ADCINC12_fIncr],00h                      ;A/D Data Ready Flag is reset
                                   (0253)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0254)    ret
                                   (0255) .ENDSECTION
                                   (0256) 
                                   (0257) .SECTION
                                   (0258) ;-----------------------------------------------------------------------------
                                   (0259) ;  FUNCTION NAME: ADCINC12_StopAD
                                   (0260) ;
                                   (0261) ;  DESCRIPTION:
                                   (0262) ;    Completely shuts down the A/D is an orderly manner.  Both the
                                   (0263) ;    Timer and COunter interrupts are disabled.
                                   (0264) ;
                                   (0265) ;-----------------------------------------------------------------------------
                                   (0266) ;
                                   (0267) ;  ARGUMENTS:  none
                                   (0268) ;
                                   (0269) ;  RETURNS:  none
                                   (0270) ;
                                   (0271) ;  SIDE EFFECTS:
                                   (0272) ;    The A and X registers may be modified by this or future implementations
                                   (0273) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0274) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0275) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0276) ;    functions.
                                   (0277) ;          
                                   (0278) ;    Currently only the page pointer registers listed below are modified: 
                                   (0279) ;          CUR_PP
                                   (0280) ;
                                   (0281)  ADCINC12_StopAD:
106F: 62 D0 00 MOV   REG[208],0    (0282) _ADCINC12_StopAD:
1072: 58 07    MOV   X,[7]         (0283)    RAM_PROLOGUE RAM_USE_CLASS_4
1074: 51 08    MOV   A,[8]         (0284)    RAM_SETPAGE_CUR >ADCINC12_bIncrC   
                                   (0285)    mov reg[ADCINC12_TimerCR0],00h                ;disable the Timer
1076: 7F       RET                 (0286)    mov reg[ADCINC12_CounterCR0],00h              ;disable the Counter
                                   (0287)    nop
                                   (0288)    nop
                                   (0289)    ;Disable both interrupts
                                   (0290)    M8C_DisableIntMask ADCINC12_TimerIntReg, ADCINC12_TimerMask 
                                   (0291)    M8C_DisableIntMask ADCINC12_CounterIntReg, ADCINC12_CounterMask 
                                   (0292) IF ADCINC12_NoAZ
                                   (0293)    or  reg[ADCINC12_AtoDcr2],20h                 ;reset Integrator
                                   (0294) ENDIF
                                   (0295)    or  reg[ADCINC12_AtoDcr3],10h
                                   (0296)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0297)    ret
                                   (0298) .ENDSECTION
                                   (0299) 
                                   (0300) .SECTION
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;  FUNCTION NAME: ADCINC12_fIsDataAvailable
                                   (0303) ;
                                   (0304) ;  DESCRIPTION:
                                   (0305) ;    This function returns a non-zero value when the ADC conversion
                                   (0306) ;    is complete.
                                   (0307) ;
                                   (0308) ;-----------------------------------------------------------------------------
                                   (0309) ;
                                   (0310) ;  ARGUMENTS: none
                                   (0311) ;
                                   (0312) ;  RETURNS:
                                   (0313) ;    A returns conversion status  A  = 0, conversion not complete
                                   (0314) ;                                 A != 0, Data available
1077: 62 D0 00 MOV   REG[208],0    (0315) ;
107A: 55 09 00 MOV   [9],0         (0316) ;  SIDE EFFECTS:
                                   (0317) ;    The A and X registers may be modified by this or future implementations
_BUZZ_Beep:
__text_start:
1276: 10       PUSH  X             (0318) ;    of this function.  The same is true for all RAM page pointer registers in
1277: 50 08    MOV   A,8
1279: 7C 0B E3 LCALL 0x0BE3
127C: 20       POP   X

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\buzzer.c
(0063) //*****************************************************************************/
(0064) //  This file is a part of the "SARK100 SWR Analyzer firmware"
127D: 10       PUSH  X
127E: 50 04    MOV   A,4
1280: 7C 0B E6 LCALL 0x0BE6
(0065) //
(0066) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
1283: 7C 0B D7 LCALL 0x0BD7
(0067) //  Melchor Varela, Madrid, Spain.
1286: 7C 0B DB LCALL 0x0BDB
1289: 20       POP   X
(0068) //  melchor.varela@gmail.com
128A: 50 00    MOV   A,0
128C: 08       PUSH  A
128D: 50 C8    MOV   A,200
128F: 08       PUSH  A
1290: 7C 53 01 LCALL _Delay_Ms
1293: 38 FE    ADD   SP,254
(0069) //
1295: 10       PUSH  X
1296: 7C 0B DF LCALL 0x0BDF
1299: 20       POP   X
(0070) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0071) //  and/or modify it under the terms of the GNU General Public License as
129A: 50 00    MOV   A,0
129C: 08       PUSH  A
129D: 50 C8    MOV   A,200
129F: 08       PUSH  A
12A0: 7C 53 01 LCALL _Delay_Ms
12A3: 38 FE    ADD   SP,254
12A5: 7F       RET   
(0072) //  published by the Free Software Foundation, either version 3 of the License,
(0073) //  or (at your option) any later version.
(0074) //
(0075) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
(0076) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0077) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
(0078) //  GNU General Public License for more details.
(0079) //
(0080) //  You should have received a copy of the GNU General Public License
(0081) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0082) //  see <http://www.gnu.org/licenses/>.
(0083) //*****************************************************************************/
(0084) //*****************************************************************************/
(0085) //
(0086) //	PROJECT:	SARK100 SWR Analyzer
(0087) // 	FILE NAME: 	BUZZER.C
(0088) // 	AUTHOR:		EA4FRB - Melchor Varela
(0089) //
(0090) // 	DESCRIPTION
(0091) //
_BUZZ_BeepError:
12A6: 10       PUSH  X
12A7: 50 10    MOV   A,16
12A9: 7C 0B E3 LCALL 0x0BE3
12AC: 20       POP   X
(0092) //	Buzzer management
(0093) //
12AD: 10       PUSH  X
12AE: 50 08    MOV   A,8
12B0: 7C 0B E6 LCALL 0x0BE6
(0094) // 	HISTORY
(0095) //
12B3: 7C 0B D7 LCALL 0x0BD7
(0096) //	NAME   	DATE		REMARKS
12B6: 7C 0B DB LCALL 0x0BDB
12B9: 20       POP   X
(0097) //
12BA: 50 00    MOV   A,0
12BC: 08       PUSH  A
12BD: 50 C8    MOV   A,200
12BF: 08       PUSH  A
12C0: 7C 53 01 LCALL _Delay_Ms
12C3: 38 FE    ADD   SP,254
(0098) //	MVM	   	DEC 2009	Creation
12C5: 10       PUSH  X
12C6: 7C 0B DF LCALL 0x0BDF
12C9: 20       POP   X
12CA: 7F       RET   
(0099) //
(0100) //*****************************************************************************/
(0101) #include <stdlib.h>
(0102) #include <m8c.h>
(0103) #include "PSoCAPI.h"
(0104) 
(0105) #include "util.h"
(0106) 
(0107) //-----------------------------------------------------------------------------
(0108) //  FUNCTION NAME:	BUZZ_Beep
(0109) //
(0110) //  DESCRIPTION:
(0111) //
(0112) //	Sounds buzzer, standard beep
(0113) //
(0114) //  ARGUMENTS:
(0115) //     none.
(0116) //
(0117) //  RETURNS:
(0118) //     none.
_BUZZ_KeyClick:
12CB: 10       PUSH  X
12CC: 50 08    MOV   A,8
12CE: 7C 0B E3 LCALL 0x0BE3
12D1: 20       POP   X
(0119) //
(0120) //-----------------------------------------------------------------------------
12D2: 10       PUSH  X
12D3: 50 04    MOV   A,4
12D5: 7C 0B E6 LCALL 0x0BE6
(0121) void BUZZ_Beep ( void )
(0122) {
12D8: 7C 0B D7 LCALL 0x0BD7
(0123) 										// Set period: clock 32Khz --> 4Khz
12DB: 7C 0B DB LCALL 0x0BDB
12DE: 20       POP   X
(0124) 	PWM8_BUZZ_WritePeriod(8);
12DF: 50 00    MOV   A,0
12E1: 08       PUSH  A
12E2: 50 05    MOV   A,5
12E4: 08       PUSH  A
12E5: 7C 53 01 LCALL _Delay_Ms
12E8: 38 FE    ADD   SP,254
(0125) 										// Set pulse width to generate a 50% duty cycle
12EA: 10       PUSH  X
12EB: 7C 0B DF LCALL 0x0BDF
12EE: 20       POP   X
12EF: 7F       RET   

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\calcs.c
(0001) //*****************************************************************************/
(0002) //  This file is a part of the "SARK100 SWR Analyzer firmware"
(0003) //
(0004) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
(0005) //  Melchor Varela, Madrid, Spain.
(0006) //  melchor.varela@gmail.com
(0007) //
(0008) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0009) //  and/or modify it under the terms of the GNU General Public License as
(0010) //  published by the Free Software Foundation, either version 3 of the License,
(0011) //  or (at your option) any later version.
(0012) //
(0013) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
(0014) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0015) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
(0016) //  GNU General Public License for more details.
(0017) //
(0018) //  You should have received a copy of the GNU General Public License
(0019) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0020) //  see <http://www.gnu.org/licenses/>.
(0021) //*****************************************************************************/
(0022) //*****************************************************************************/
(0023) //
(0024) //	PROJECT:	SARK100 SWR Analyzer
(0025) // 	FILE NAME: 	CALCS.C
(0026) // 	AUTHOR:		EA4FRB - Melchor Varela
(0027) //
(0028) // 	DESCRIPTION
(0029) //
(0030) //	SWR and impedance calculation routines
(0031) //
(0032) // 	HISTORY
(0033) //
(0034) //	NAME   	DATE		REMARKS
(0035) //
(0036) //	MVM	   	DEC 2009	Creation
(0037) //
(0038) //*****************************************************************************/
(0039) 
(0040) #include <m8c.h>        // part specific constants and macros
(0041) #include <math.h>
(0042) 
(0043) #include "PSoCAPI.h"
(0044) #include "psocgpioint.h"
(0045) #include "glb_data.h"
(0046) #include "calibrate_reflectometer.h"
(0047) 
(0048) //-----------------------------------------------------------------------------
(0049) //  Prototypes
(0050) //-----------------------------------------------------------------------------
(0051) static WORD Calc_Sqrt (DWORD dwN);
(0052) 
(0053) //-----------------------------------------------------------------------------
(0054) //  FUNCTION NAME:	Calculate_Swr
(0055) //
(0056) //  DESCRIPTION:
(0057) //
(0058) //	Calculates SWR based on VF and VR values
(0059) //	Notice that wVf value is x2 because it is measured at the bridge input, and
(0060) //	wVr is also x2 because the PGA gain is set to double, so both compensates and
(0061) //	it is not needed further calculation
(0062) //
(0063) //	SWR = (Vf+Vr/Vf-Vr)*100
(0064) //
(0065) //  ARGUMENTS:
(0066) //     	dwVf
(0067) //		dwVr
(0068) //
(0069) //  RETURNS:
(0070) //     SWR
(0071) //
(0072) //-----------------------------------------------------------------------------
(0073) WORD Calculate_Swr (DWORD dwVf, DWORD dwVr)
(0074) {
_Calculate_Swr:
  dwNumerator          --> X+6
  dwDenominator        --> X+2
  wSwr                 --> X+0
  dwVr                 --> X-11
  dwVf                 --> X-7
12F0: 10       PUSH  X
12F1: 4F       MOV   X,SP
12F2: 38 0A    ADD   SP,10
(0075) 	DWORD dwDenominator;
(0076) 	DWORD dwNumerator;
(0077) 	WORD wSwr;
(0078) 
(0079) 	if (dwVf>dwVr)
12F4: 52 F8    MOV   A,[X-8]
12F6: 13 FC    SUB   A,[X-4]
12F8: 52 F7    MOV   A,[X-9]
12FA: 1B FB    SBB   A,[X-5]
12FC: 52 F6    MOV   A,[X-10]
12FE: 1B FA    SBB   A,[X-6]
1300: 52 F5    MOV   A,[X-11]
1302: 1B F9    SBB   A,[X-7]
1304: D0 1B    JNC   0x1320
(0080) 		dwDenominator = dwVf-dwVr;
1306: 52 FC    MOV   A,[X-4]
1308: 13 F8    SUB   A,[X-8]
130A: 54 05    MOV   [X+5],A
130C: 52 FB    MOV   A,[X-5]
130E: 1B F7    SBB   A,[X-9]
1310: 54 04    MOV   [X+4],A
1312: 52 FA    MOV   A,[X-6]
1314: 1B F6    SBB   A,[X-10]
1316: 54 03    MOV   [X+3],A
1318: 52 F9    MOV   A,[X-7]
131A: 1B F5    SBB   A,[X-11]
131C: 54 02    MOV   [X+2],A
131E: 80 0D    JMP   0x132C
(0081) 	else
(0082) 		dwDenominator = 1;
1320: 56 02 00 MOV   [X+2],0
1323: 56 03 00 MOV   [X+3],0
1326: 56 04 00 MOV   [X+4],0
1329: 56 05 01 MOV   [X+5],1
(0083) 
(0084) 	dwNumerator = (dwVf+dwVr)*100;
132C: 62 D0 02 MOV   REG[208],2
132F: 52 FC    MOV   A,[X-4]
1331: 03 F8    ADD   A,[X-8]
1333: 53 B3    MOV   [__r3],A
1335: 52 FB    MOV   A,[X-5]
1337: 0B F7    ADC   A,[X-9]
1339: 53 B4    MOV   [__r2],A
133B: 52 FA    MOV   A,[X-6]
133D: 0B F6    ADC   A,[X-10]
133F: 53 B5    MOV   [__r1],A
1341: 52 F9    MOV   A,[X-7]
1343: 0B F5    ADC   A,[X-11]
1345: 08       PUSH  A
1346: 51 B5    MOV   A,[__r1]
1348: 08       PUSH  A
1349: 51 B4    MOV   A,[__r2]
134B: 08       PUSH  A
134C: 51 B3    MOV   A,[__r3]
134E: 08       PUSH  A
134F: 50 00    MOV   A,0
1351: 08       PUSH  A
1352: 08       PUSH  A
1353: 08       PUSH  A
1354: 50 64    MOV   A,100
1356: 08       PUSH  A
1357: 7C 57 3B LCALL __mul_32X32_32
135A: 38 FC    ADD   SP,252
135C: 18       POP   A
135D: 54 09    MOV   [X+9],A
135F: 18       POP   A
1360: 54 08    MOV   [X+8],A
1362: 18       POP   A
1363: 54 07    MOV   [X+7],A
1365: 18       POP   A
1366: 54 06    MOV   [X+6],A
(0085) 	wSwr = (dwNumerator/dwDenominator);
1368: 52 02    MOV   A,[X+2]
136A: 08       PUSH  A
136B: 52 03    MOV   A,[X+3]
136D: 08       PUSH  A
136E: 52 04    MOV   A,[X+4]
1370: 08       PUSH  A
1371: 52 05    MOV   A,[X+5]
1373: 08       PUSH  A
1374: 52 06    MOV   A,[X+6]
1376: 08       PUSH  A
1377: 52 07    MOV   A,[X+7]
1379: 08       PUSH  A
137A: 52 08    MOV   A,[X+8]
137C: 08       PUSH  A
137D: 52 09    MOV   A,[X+9]
137F: 08       PUSH  A
1380: 7C 55 EC LCALL __divmodu_32X32_32
1383: 18       POP   A
1384: 53 B3    MOV   [__r3],A
1386: 18       POP   A
1387: 53 B4    MOV   [__r2],A
1389: 18       POP   A
138A: 18       POP   A
138B: 38 FC    ADD   SP,252
138D: 51 B3    MOV   A,[__r3]
138F: 53 B5    MOV   [__r1],A
1391: 51 B4    MOV   A,[__r2]
1393: 53 B6    MOV   [__r0],A
1395: 51 B5    MOV   A,[__r1]
1397: 54 01    MOV   [X+1],A
1399: 51 B6    MOV   A,[__r0]
139B: 54 00    MOV   [X+0],A
(0086) 
(0087) 	if (wSwr > SWR_MAX)
139D: 50 E7    MOV   A,231
139F: 13 01    SUB   A,[X+1]
13A1: 50 03    MOV   A,3
13A3: 1B 00    SBB   A,[X+0]
13A5: D0 07    JNC   0x13AD
(0088) 		wSwr = SWR_MAX;
13A7: 56 01 E7 MOV   [X+1],231
13AA: 56 00 03 MOV   [X+0],3
(0089) 
(0090) 	return wSwr;
13AD: 62 D0 02 MOV   REG[208],2
13B0: 52 01    MOV   A,[X+1]
13B2: 53 B5    MOV   [__r1],A
13B4: 52 00    MOV   A,[X+0]
13B6: 53 B6    MOV   [__r0],A
13B8: 38 F6    ADD   SP,246
13BA: 20       POP   X
13BB: 7F       RET   
(0091) }
(0092) 
(0093) //-----------------------------------------------------------------------------
(0094) //  FUNCTION NAME:	Calculate_Z
(0095) //
(0096) //  DESCRIPTION:
(0097) //
(0098) //	Calculates impedance
(0099) //
(0100) //	Z = (50 * Vz)/Va;
(0101) //
(0102) //  ARGUMENTS:
(0103) //		dwVz
(0104) //		dwVa
(0105) //
(0106) //  RETURNS:
(0107) //     Z
(0108) //
(0109) //-----------------------------------------------------------------------------
(0110) WORD Calculate_Z (DWORD dwVz, DWORD dwVa)
(0111) {
_Calculate_Z:
  dwZ                  --> X+0
  dwVa                 --> X-11
  dwVz                 --> X-7
13BC: 10       PUSH  X
13BD: 4F       MOV   X,SP
13BE: 38 04    ADD   SP,4
(0112) 	DWORD dwZ;
(0113) 
(0114) 	if (dwVa == 0)						// Avoids divide by zero
13C0: 3D F5 00 CMP   [X-11],0
13C3: B0 1C    JNZ   0x13E0
13C5: 3D F6 00 CMP   [X-10],0
13C8: B0 17    JNZ   0x13E0
13CA: 3D F7 00 CMP   [X-9],0
13CD: B0 12    JNZ   0x13E0
13CF: 3D F8 00 CMP   [X-8],0
13D2: B0 0D    JNZ   0x13E0
(0115) 		dwVa = 1;
13D4: 56 F5 00 MOV   [X-11],0
13D7: 56 F6 00 MOV   [X-10],0
13DA: 56 F7 00 MOV   [X-9],0
13DD: 56 F8 01 MOV   [X-8],1
(0116) 
(0117) 	dwZ = ((DWORD)(dwVz * (DWORD)50))/dwVa;
13E0: 62 D0 02 MOV   REG[208],2
13E3: 52 F9    MOV   A,[X-7]
13E5: 08       PUSH  A
13E6: 52 FA    MOV   A,[X-6]
13E8: 08       PUSH  A
13E9: 52 FB    MOV   A,[X-5]
13EB: 08       PUSH  A
13EC: 52 FC    MOV   A,[X-4]
13EE: 08       PUSH  A
13EF: 50 00    MOV   A,0
13F1: 08       PUSH  A
13F2: 08       PUSH  A
13F3: 08       PUSH  A
13F4: 50 32    MOV   A,50
13F6: 08       PUSH  A
13F7: 7C 57 3B LCALL __mul_32X32_32
13FA: 38 FC    ADD   SP,252
13FC: 18       POP   A
13FD: 53 B3    MOV   [__r3],A
13FF: 18       POP   A
1400: 53 B4    MOV   [__r2],A
1402: 18       POP   A
1403: 53 B5    MOV   [__r1],A
1405: 18       POP   A
1406: 53 B6    MOV   [__r0],A
1408: 52 F5    MOV   A,[X-11]
140A: 08       PUSH  A
140B: 52 F6    MOV   A,[X-10]
140D: 08       PUSH  A
140E: 52 F7    MOV   A,[X-9]
1410: 08       PUSH  A
1411: 52 F8    MOV   A,[X-8]
1413: 08       PUSH  A
1414: 51 B6    MOV   A,[__r0]
1416: 08       PUSH  A
1417: 51 B5    MOV   A,[__r1]
1419: 08       PUSH  A
141A: 51 B4    MOV   A,[__r2]
141C: 08       PUSH  A
141D: 51 B3    MOV   A,[__r3]
141F: 08       PUSH  A
1420: 7C 55 EC LCALL __divmodu_32X32_32
1423: 18       POP   A
1424: 54 03    MOV   [X+3],A
1426: 18       POP   A
1427: 54 02    MOV   [X+2],A
1429: 18       POP   A
142A: 54 01    MOV   [X+1],A
142C: 18       POP   A
142D: 54 00    MOV   [X+0],A
142F: 38 FC    ADD   SP,252
(0118) 
(0119) 	if (dwZ > 2000)
1431: 50 D0    MOV   A,208
1433: 13 03    SUB   A,[X+3]
1435: 50 07    MOV   A,7
1437: 1B 02    SBB   A,[X+2]
1439: 50 00    MOV   A,0
143B: 1B 01    SBB   A,[X+1]
143D: 50 00    MOV   A,0
143F: 1B 00    SBB   A,[X+0]
1441: D0 0D    JNC   0x144F
(0120) 		dwZ = 2000;
1443: 56 00 00 MOV   [X+0],0
1446: 56 01 00 MOV   [X+1],0
1449: 56 02 07 MOV   [X+2],7
144C: 56 03 D0 MOV   [X+3],208
(0121) 
(0122) 	return (WORD)dwZ;
144F: 62 D0 02 MOV   REG[208],2
1452: 52 03    MOV   A,[X+3]
1454: 53 B5    MOV   [__r1],A
1456: 52 02    MOV   A,[X+2]
1458: 53 B6    MOV   [__r0],A
145A: 38 FC    ADD   SP,252
145C: 20       POP   X
145D: 7F       RET   
(0123) }
(0124) 
(0125) //-----------------------------------------------------------------------------
(0126) //  FUNCTION NAME:	Calculate_R
(0127) //
(0128) //  DESCRIPTION:
(0129) //
(0130) //	Calculates resistance
(0131) //
(0132) //               (2500 + Z^2) * SWR
(0133) //           R = ------------------
(0134) //                50 * (SWR^2 + 1)
(0135) //
(0136) //      OR ...
(0137) //                 (2500+Z^2)*SWR
(0138) //           R =  --------------------
(0139) //                  ((SWR^2)/2)+5000
(0140) //  ARGUMENTS:
(0141) //     wZ
(0142) //	   wSwr
(0143) //
(0144) //  RETURNS:
(0145) //     R
(0146) //
(0147) //-----------------------------------------------------------------------------
(0148) WORD Calculate_R (WORD wZ, WORD wSwr)
(0149) {
_Calculate_R:
  wR                   --> X+8
  dwDenominator        --> X+4
  dwNumerator          --> X+0
  wSwr                 --> X-7
  wZ                   --> X-5
145E: 10       PUSH  X
145F: 4F       MOV   X,SP
1460: 38 0A    ADD   SP,10
(0150) 	DWORD dwNumerator;
(0151) 	DWORD dwDenominator;
(0152) 	WORD wR;
(0153) 
(0154) 	dwDenominator = (((DWORD)wSwr*wSwr)/2)+5000;
1462: 62 D0 02 MOV   REG[208],2
1465: 52 FA    MOV   A,[X-6]
1467: 53 B3    MOV   [__r3],A
1469: 52 F9    MOV   A,[X-7]
146B: 53 B4    MOV   [__r2],A
146D: 52 FA    MOV   A,[X-6]
146F: 53 AF    MOV   [__r7],A
1471: 52 F9    MOV   A,[X-7]
1473: 53 B0    MOV   [__r6],A
1475: 50 00    MOV   A,0
1477: 08       PUSH  A
1478: 08       PUSH  A
1479: 51 B4    MOV   A,[__r2]
147B: 08       PUSH  A
147C: 51 B3    MOV   A,[__r3]
147E: 08       PUSH  A
147F: 50 00    MOV   A,0
1481: 08       PUSH  A
1482: 08       PUSH  A
1483: 51 B0    MOV   A,[__r6]
1485: 08       PUSH  A
1486: 51 AF    MOV   A,[__r7]
1488: 08       PUSH  A
1489: 7C 57 3B LCALL __mul_32X32_32
148C: 38 FC    ADD   SP,252
148E: 18       POP   A
148F: 53 B3    MOV   [__r3],A
1491: 18       POP   A
1492: 53 B4    MOV   [__r2],A
1494: 18       POP   A
1495: 53 B5    MOV   [__r1],A
1497: 18       POP   A
1498: 53 B6    MOV   [__r0],A
149A: 70 FB    AND   F,251
149C: 6E B6    RRC   [__r0]
149E: 6E B5    RRC   [__r1]
14A0: 6E B4    RRC   [__r2]
14A2: 6E B3    RRC   [__r3]
14A4: 51 B3    MOV   A,[__r3]
14A6: 01 88    ADD   A,136
14A8: 54 07    MOV   [X+7],A
14AA: 51 B4    MOV   A,[__r2]
14AC: 09 13    ADC   A,19
14AE: 54 06    MOV   [X+6],A
14B0: 51 B5    MOV   A,[__r1]
14B2: 09 00    ADC   A,0
14B4: 54 05    MOV   [X+5],A
14B6: 51 B6    MOV   A,[__r0]
14B8: 09 00    ADC   A,0
14BA: 54 04    MOV   [X+4],A
(0155) 	dwNumerator = (((DWORD)wZ*wZ) + 2500) * (DWORD)wSwr;
14BC: 52 FC    MOV   A,[X-4]
14BE: 53 B3    MOV   [__r3],A
14C0: 52 FB    MOV   A,[X-5]
14C2: 53 B4    MOV   [__r2],A
14C4: 52 FC    MOV   A,[X-4]
14C6: 53 AF    MOV   [__r7],A
14C8: 52 FB    MOV   A,[X-5]
14CA: 53 B0    MOV   [__r6],A
14CC: 50 00    MOV   A,0
14CE: 08       PUSH  A
14CF: 08       PUSH  A
14D0: 51 B4    MOV   A,[__r2]
14D2: 08       PUSH  A
14D3: 51 B3    MOV   A,[__r3]
14D5: 08       PUSH  A
14D6: 50 00    MOV   A,0
14D8: 08       PUSH  A
14D9: 08       PUSH  A
14DA: 51 B0    MOV   A,[__r6]
14DC: 08       PUSH  A
14DD: 51 AF    MOV   A,[__r7]
14DF: 08       PUSH  A
14E0: 7C 57 3B LCALL __mul_32X32_32
14E3: 38 FC    ADD   SP,252
14E5: 18       POP   A
14E6: 53 B3    MOV   [__r3],A
14E8: 18       POP   A
14E9: 53 B4    MOV   [__r2],A
14EB: 18       POP   A
14EC: 53 B5    MOV   [__r1],A
14EE: 18       POP   A
14EF: 53 B6    MOV   [__r0],A
14F1: 06 B3 C4 ADD   [__r3],196
14F4: 0E B4 09 ADC   [__r2],9
14F7: 0E B5 00 ADC   [__r1],0
14FA: 0E B6 00 ADC   [__r0],0
14FD: 52 FA    MOV   A,[X-6]
14FF: 53 AF    MOV   [__r7],A
1501: 52 F9    MOV   A,[X-7]
1503: 53 B0    MOV   [__r6],A
1505: 50 00    MOV   A,0
1507: 08       PUSH  A
1508: 08       PUSH  A
1509: 51 B0    MOV   A,[__r6]
150B: 08       PUSH  A
150C: 51 AF    MOV   A,[__r7]
150E: 08       PUSH  A
150F: 51 B6    MOV   A,[__r0]
1511: 08       PUSH  A
1512: 51 B5    MOV   A,[__r1]
1514: 08       PUSH  A
1515: 51 B4    MOV   A,[__r2]
1517: 08       PUSH  A
1518: 51 B3    MOV   A,[__r3]
151A: 08       PUSH  A
151B: 7C 57 3B LCALL __mul_32X32_32
151E: 38 FC    ADD   SP,252
1520: 18       POP   A
1521: 54 03    MOV   [X+3],A
1523: 18       POP   A
1524: 54 02    MOV   [X+2],A
1526: 18       POP   A
1527: 54 01    MOV   [X+1],A
1529: 18       POP   A
152A: 54 00    MOV   [X+0],A
(0156) 
(0157) 	wR = dwNumerator/dwDenominator;
152C: 52 04    MOV   A,[X+4]
152E: 08       PUSH  A
152F: 52 05    MOV   A,[X+5]
1531: 08       PUSH  A
1532: 52 06    MOV   A,[X+6]
1534: 08       PUSH  A
1535: 52 07    MOV   A,[X+7]
1537: 08       PUSH  A
1538: 52 00    MOV   A,[X+0]
153A: 08       PUSH  A
153B: 52 01    MOV   A,[X+1]
153D: 08       PUSH  A
153E: 52 02    MOV   A,[X+2]
1540: 08       PUSH  A
1541: 52 03    MOV   A,[X+3]
1543: 08       PUSH  A
1544: 7C 55 EC LCALL __divmodu_32X32_32
1547: 18       POP   A
1548: 53 B3    MOV   [__r3],A
154A: 18       POP   A
154B: 53 B4    MOV   [__r2],A
154D: 18       POP   A
154E: 18       POP   A
154F: 38 FC    ADD   SP,252
1551: 51 B3    MOV   A,[__r3]
1553: 53 B5    MOV   [__r1],A
1555: 51 B4    MOV   A,[__r2]
1557: 53 B6    MOV   [__r0],A
1559: 51 B5    MOV   A,[__r1]
155B: 54 09    MOV   [X+9],A
155D: 51 B6    MOV   A,[__r0]
155F: 54 08    MOV   [X+8],A
(0158) 
(0159) 	return wR;
1561: 52 09    MOV   A,[X+9]
1563: 53 B5    MOV   [__r1],A
1565: 52 08    MOV   A,[X+8]
1567: 53 B6    MOV   [__r0],A
1569: 38 F6    ADD   SP,246
156B: 20       POP   X
156C: 7F       RET   
(0160) }
(0161) 
(0162) //-----------------------------------------------------------------------------
(0163) //  FUNCTION NAME:	Calculate_X
(0164) //
(0165) //  DESCRIPTION:
(0166) //
(0167) //	Calculates impedance
(0168) //
(0169) //           X = SQRT ( Z^2 - R^2 )
(0170) //
(0171) //  ARGUMENTS:
(0172) //     	wZ
(0173) //		wR
(0174) //
(0175) //  RETURNS:
(0176) //     X
(0177) //
(0178) //-----------------------------------------------------------------------------
(0179) WORD Calculate_X (WORD wZ, WORD wR)
(0180) {
_Calculate_X:
  wX                   --> X+4
  dwTemp               --> X+0
  wR                   --> X-7
  wZ                   --> X-5
156D: 10       PUSH  X
156E: 4F       MOV   X,SP
156F: 38 06    ADD   SP,6
(0181) 	DWORD dwTemp;
(0182) 	WORD wX;
(0183) 
(0184) 	if (((signed long)wZ-(signed long)wR)<=1)
1571: 62 D0 02 MOV   REG[208],2
1574: 52 FA    MOV   A,[X-6]
1576: 53 B3    MOV   [__r3],A
1578: 52 F9    MOV   A,[X-7]
157A: 53 B4    MOV   [__r2],A
157C: 55 B5 00 MOV   [__r1],0
157F: 55 B6 00 MOV   [__r0],0
1582: 52 FC    MOV   A,[X-4]
1584: 53 AF    MOV   [__r7],A
1586: 52 FB    MOV   A,[X-5]
1588: 53 B0    MOV   [__r6],A
158A: 51 AF    MOV   A,[__r7]
158C: 12 B3    SUB   A,[__r3]
158E: 53 B3    MOV   [__r3],A
1590: 51 B0    MOV   A,[__r6]
1592: 1A B4    SBB   A,[__r2]
1594: 53 B4    MOV   [__r2],A
1596: 50 00    MOV   A,0
1598: 1A B5    SBB   A,[__r1]
159A: 53 B5    MOV   [__r1],A
159C: 50 00    MOV   A,0
159E: 1A B6    SBB   A,[__r0]
15A0: 53 B6    MOV   [__r0],A
15A2: 50 01    MOV   A,1
15A4: 12 B3    SUB   A,[__r3]
15A6: 50 00    MOV   A,0
15A8: 1A B4    SBB   A,[__r2]
15AA: 50 00    MOV   A,0
15AC: 1A B5    SBB   A,[__r1]
15AE: 51 B6    MOV   A,[__r0]
15B0: 31 80    XOR   A,128
15B2: 53 AC    MOV   [__rX],A
15B4: 50 80    MOV   A,128
15B6: 1A AC    SBB   A,[__rX]
15B8: C0 0C    JC    0x15C5
(0185) 		return 0;
15BA: 62 D0 02 MOV   REG[208],2
15BD: 55 B5 00 MOV   [__r1],0
15C0: 55 B6 00 MOV   [__r0],0
15C3: 80 A9    JMP   0x166D
(0186) 	dwTemp = ((DWORD)wZ*wZ)-((DWORD)wR*wR);
15C5: 62 D0 02 MOV   REG[208],2
15C8: 52 FA    MOV   A,[X-6]
15CA: 53 B3    MOV   [__r3],A
15CC: 52 F9    MOV   A,[X-7]
15CE: 53 B4    MOV   [__r2],A
15D0: 52 FA    MOV   A,[X-6]
15D2: 53 AF    MOV   [__r7],A
15D4: 52 F9    MOV   A,[X-7]
15D6: 53 B0    MOV   [__r6],A
15D8: 50 00    MOV   A,0
15DA: 08       PUSH  A
15DB: 08       PUSH  A
15DC: 51 B4    MOV   A,[__r2]
15DE: 08       PUSH  A
15DF: 51 B3    MOV   A,[__r3]
15E1: 08       PUSH  A
15E2: 50 00    MOV   A,0
15E4: 08       PUSH  A
15E5: 08       PUSH  A
15E6: 51 B0    MOV   A,[__r6]
15E8: 08       PUSH  A
15E9: 51 AF    MOV   A,[__r7]
15EB: 08       PUSH  A
15EC: 7C 57 3B LCALL __mul_32X32_32
15EF: 38 FC    ADD   SP,252
15F1: 18       POP   A
15F2: 53 B3    MOV   [__r3],A
15F4: 18       POP   A
15F5: 53 B4    MOV   [__r2],A
15F7: 18       POP   A
15F8: 53 B5    MOV   [__r1],A
15FA: 18       POP   A
15FB: 53 B6    MOV   [__r0],A
15FD: 52 FC    MOV   A,[X-4]
15FF: 53 AF    MOV   [__r7],A
1601: 52 FB    MOV   A,[X-5]
1603: 53 B0    MOV   [__r6],A
1605: 52 FC    MOV   A,[X-4]
1607: 53 AD    MOV   [__r11],A
1609: 52 FB    MOV   A,[X-5]
160B: 53 AE    MOV   [__r10],A
160D: 50 00    MOV   A,0
160F: 08       PUSH  A
1610: 08       PUSH  A
1611: 51 B0    MOV   A,[__r6]
1613: 08       PUSH  A
1614: 51 AF    MOV   A,[__r7]
1616: 08       PUSH  A
1617: 50 00    MOV   A,0
1619: 08       PUSH  A
161A: 08       PUSH  A
161B: 51 AE    MOV   A,[__r10]
161D: 08       PUSH  A
161E: 51 AD    MOV   A,[__r11]
1620: 08       PUSH  A
1621: 7C 57 3B LCALL __mul_32X32_32
1624: 38 FC    ADD   SP,252
1626: 18       POP   A
1627: 53 AF    MOV   [__r7],A
1629: 18       POP   A
162A: 53 B0    MOV   [__r6],A
162C: 18       POP   A
162D: 53 B1    MOV   [__r5],A
162F: 18       POP   A
1630: 53 B2    MOV   [__r4],A
1632: 51 AF    MOV   A,[__r7]
1634: 12 B3    SUB   A,[__r3]
1636: 54 03    MOV   [X+3],A
1638: 51 B0    MOV   A,[__r6]
163A: 1A B4    SBB   A,[__r2]
163C: 54 02    MOV   [X+2],A
163E: 51 B1    MOV   A,[__r5]
1640: 1A B5    SBB   A,[__r1]
1642: 54 01    MOV   [X+1],A
1644: 51 B2    MOV   A,[__r4]
1646: 1A B6    SBB   A,[__r0]
1648: 54 00    MOV   [X+0],A
(0187) 
(0188) 	wX = Calc_Sqrt(dwTemp);
164A: 52 00    MOV   A,[X+0]
164C: 08       PUSH  A
164D: 52 01    MOV   A,[X+1]
164F: 08       PUSH  A
1650: 52 02    MOV   A,[X+2]
1652: 08       PUSH  A
1653: 52 03    MOV   A,[X+3]
1655: 08       PUSH  A
1656: 91 C6    CALL  _Calc_Sqrt
1658: 38 FC    ADD   SP,252
165A: 62 D0 02 MOV   REG[208],2
165D: 51 B5    MOV   A,[__r1]
165F: 54 05    MOV   [X+5],A
1661: 51 B6    MOV   A,[__r0]
1663: 54 04    MOV   [X+4],A
(0189) 
(0190) 	return wX;
1665: 52 05    MOV   A,[X+5]
1667: 53 B5    MOV   [__r1],A
1669: 52 04    MOV   A,[X+4]
166B: 53 B6    MOV   [__r0],A
166D: 38 FA    ADD   SP,250
166F: 20       POP   X
1670: 7F       RET   
(0191) }
(0192) 
(0193) //-----------------------------------------------------------------------------
(0194) //  FUNCTION NAME:	Calculate_L
(0195) //
(0196) //  DESCRIPTION:
(0197) //
(0198) //	Calculates inductance
(0199) //
(0200) //   	L=10^6*X/2*PI*freq
(0201) //
(0202) //  ARGUMENTS:
(0203) //     	wX
(0204) //		dwFreq
(0205) //
(0206) //  RETURNS:
(0207) //     Inductance value in *10 uH.
(0208) //
(0209) //-----------------------------------------------------------------------------
(0210) WORD Calculate_L (WORD wX, DWORD dwFreq)
(0211) {
_Calculate_L:
  dwTemp               --> X+0
  dwFreq               --> X-9
  wX                   --> X-5
1671: 10       PUSH  X
1672: 4F       MOV   X,SP
1673: 38 04    ADD   SP,4
(0212) 	DWORD dwTemp;
(0213) 
(0214) 	dwFreq /= 1000;						// Hz to Khz
1675: 50 00    MOV   A,0
1677: 08       PUSH  A
1678: 08       PUSH  A
1679: 50 03    MOV   A,3
167B: 08       PUSH  A
167C: 50 E8    MOV   A,232
167E: 08       PUSH  A
167F: 52 F7    MOV   A,[X-9]
1681: 08       PUSH  A
1682: 52 F8    MOV   A,[X-8]
1684: 08       PUSH  A
1685: 52 F9    MOV   A,[X-7]
1687: 08       PUSH  A
1688: 52 FA    MOV   A,[X-6]
168A: 08       PUSH  A
168B: 62 D0 02 MOV   REG[208],2
168E: 7C 55 EC LCALL __divmodu_32X32_32
1691: 18       POP   A
1692: 54 FA    MOV   [X-6],A
1694: 18       POP   A
1695: 54 F9    MOV   [X-7],A
1697: 18       POP   A
1698: 54 F8    MOV   [X-8],A
169A: 18       POP   A
169B: 54 F7    MOV   [X-9],A
169D: 38 FC    ADD   SP,252
(0215) 
(0216) 	dwTemp = ((DWORD)wX*100000)/63;
169F: 52 FC    MOV   A,[X-4]
16A1: 53 B3    MOV   [__r3],A
16A3: 52 FB    MOV   A,[X-5]
16A5: 53 B4    MOV   [__r2],A
16A7: 50 00    MOV   A,0
16A9: 08       PUSH  A
16AA: 08       PUSH  A
16AB: 51 B4    MOV   A,[__r2]
16AD: 08       PUSH  A
16AE: 51 B3    MOV   A,[__r3]
16B0: 08       PUSH  A
16B1: 50 00    MOV   A,0
16B3: 08       PUSH  A
16B4: 50 01    MOV   A,1
16B6: 08       PUSH  A
16B7: 50 86    MOV   A,134
16B9: 08       PUSH  A
16BA: 50 A0    MOV   A,160
16BC: 08       PUSH  A
16BD: 7C 57 3B LCALL __mul_32X32_32
16C0: 38 FC    ADD   SP,252
16C2: 18       POP   A
16C3: 53 B3    MOV   [__r3],A
16C5: 18       POP   A
16C6: 53 B4    MOV   [__r2],A
16C8: 18       POP   A
16C9: 53 B5    MOV   [__r1],A
16CB: 18       POP   A
16CC: 53 B6    MOV   [__r0],A
16CE: 50 00    MOV   A,0
16D0: 08       PUSH  A
16D1: 08       PUSH  A
16D2: 08       PUSH  A
16D3: 50 3F    MOV   A,63
16D5: 08       PUSH  A
16D6: 51 B6    MOV   A,[__r0]
16D8: 08       PUSH  A
16D9: 51 B5    MOV   A,[__r1]
16DB: 08       PUSH  A
16DC: 51 B4    MOV   A,[__r2]
16DE: 08       PUSH  A
16DF: 51 B3    MOV   A,[__r3]
16E1: 08       PUSH  A
16E2: 7C 55 EC LCALL __divmodu_32X32_32
16E5: 18       POP   A
16E6: 54 03    MOV   [X+3],A
16E8: 18       POP   A
16E9: 54 02    MOV   [X+2],A
16EB: 18       POP   A
16EC: 54 01    MOV   [X+1],A
16EE: 18       POP   A
16EF: 54 00    MOV   [X+0],A
16F1: 38 FC    ADD   SP,252
(0217) 	return dwTemp / dwFreq;
16F3: 52 F7    MOV   A,[X-9]
16F5: 08       PUSH  A
16F6: 52 F8    MOV   A,[X-8]
16F8: 08       PUSH  A
16F9: 52 F9    MOV   A,[X-7]
16FB: 08       PUSH  A
16FC: 52 FA    MOV   A,[X-6]
16FE: 08       PUSH  A
16FF: 52 00    MOV   A,[X+0]
1701: 08       PUSH  A
1702: 52 01    MOV   A,[X+1]
1704: 08       PUSH  A
1705: 52 02    MOV   A,[X+2]
1707: 08       PUSH  A
1708: 52 03    MOV   A,[X+3]
170A: 08       PUSH  A
170B: 7C 55 EC LCALL __divmodu_32X32_32
170E: 18       POP   A
170F: 53 B3    MOV   [__r3],A
1711: 18       POP   A
1712: 53 B4    MOV   [__r2],A
1714: 18       POP   A
1715: 18       POP   A
1716: 38 FC    ADD   SP,252
1718: 51 B3    MOV   A,[__r3]
171A: 53 B5    MOV   [__r1],A
171C: 51 B4    MOV   A,[__r2]
171E: 53 B6    MOV   [__r0],A
1720: 38 FC    ADD   SP,252
1722: 20       POP   X
1723: 7F       RET   
(0218) }
(0219) 
(0220) //-----------------------------------------------------------------------------
(0221) //  FUNCTION NAME:	Calculate_C
(0222) //
(0223) //  DESCRIPTION:
(0224) //
(0225) //	Calculates capacitance
(0226) //
(0227) //           C=10^12/(2*PI*freq*X)
(0228) //
(0229) //  ARGUMENTS:
(0230) //     	wX
(0231) //		dwFreq
(0232) //
(0233) //  RETURNS:
(0234) //     Capacitance value in x10 pf .
(0235) //
(0236) //-----------------------------------------------------------------------------
(0237) WORD Calculate_C (WORD wX, DWORD dwFreq)
(0238) {
_Calculate_C:
  dwFreq               --> X-9
  wX                   --> X-5
1724: 10       PUSH  X
1725: 4F       MOV   X,SP
(0239) 
(0240) 	if (wX==0)
1726: 3D FB 00 CMP   [X-5],0
1729: B0 11    JNZ   0x173B
172B: 3D FC 00 CMP   [X-4],0
172E: B0 0C    JNZ   0x173B
(0241) 		return 0;
1730: 62 D0 02 MOV   REG[208],2
1733: 55 B5 00 MOV   [__r1],0
1736: 55 B6 00 MOV   [__r0],0
1739: 80 E2    JMP   0x181C
(0242) 
(0243) 	dwFreq /= 1000;		//Hz to Khz
173B: 50 00    MOV   A,0
173D: 08       PUSH  A
173E: 08       PUSH  A
173F: 50 03    MOV   A,3
1741: 08       PUSH  A
1742: 50 E8    MOV   A,232
1744: 08       PUSH  A
1745: 52 F7    MOV   A,[X-9]
1747: 08       PUSH  A
1748: 52 F8    MOV   A,[X-8]
174A: 08       PUSH  A
174B: 52 F9    MOV   A,[X-7]
174D: 08       PUSH  A
174E: 52 FA    MOV   A,[X-6]
1750: 08       PUSH  A
1751: 62 D0 02 MOV   REG[208],2
1754: 7C 55 EC LCALL __divmodu_32X32_32
1757: 18       POP   A
1758: 54 FA    MOV   [X-6],A
175A: 18       POP   A
175B: 54 F9    MOV   [X-7],A
175D: 18       POP   A
175E: 54 F8    MOV   [X-8],A
1760: 18       POP   A
1761: 54 F7    MOV   [X-9],A
1763: 38 FC    ADD   SP,252
(0244) 	return ((DWORD)10000/63) * 	((DWORD)10000/dwFreq) * ((DWORD)10000/(wX*10));
1765: 52 F7    MOV   A,[X-9]
1767: 08       PUSH  A
1768: 52 F8    MOV   A,[X-8]
176A: 08       PUSH  A
176B: 52 F9    MOV   A,[X-7]
176D: 08       PUSH  A
176E: 52 FA    MOV   A,[X-6]
1770: 08       PUSH  A
1771: 50 00    MOV   A,0
1773: 08       PUSH  A
1774: 08       PUSH  A
1775: 50 27    MOV   A,39
1777: 08       PUSH  A
1778: 50 10    MOV   A,16
177A: 08       PUSH  A
177B: 7C 55 EC LCALL __divmodu_32X32_32
177E: 18       POP   A
177F: 53 B3    MOV   [__r3],A
1781: 18       POP   A
1782: 53 B4    MOV   [__r2],A
1784: 18       POP   A
1785: 53 B5    MOV   [__r1],A
1787: 18       POP   A
1788: 38 FC    ADD   SP,252
178A: 08       PUSH  A
178B: 51 B5    MOV   A,[__r1]
178D: 08       PUSH  A
178E: 51 B4    MOV   A,[__r2]
1790: 08       PUSH  A
1791: 51 B3    MOV   A,[__r3]
1793: 08       PUSH  A
1794: 50 00    MOV   A,0
1796: 08       PUSH  A
1797: 08       PUSH  A
1798: 08       PUSH  A
1799: 50 9E    MOV   A,158
179B: 08       PUSH  A
179C: 7C 57 3B LCALL __mul_32X32_32
179F: 38 FC    ADD   SP,252
17A1: 18       POP   A
17A2: 53 B3    MOV   [__r3],A
17A4: 18       POP   A
17A5: 53 B4    MOV   [__r2],A
17A7: 18       POP   A
17A8: 53 B5    MOV   [__r1],A
17AA: 18       POP   A
17AB: 53 B6    MOV   [__r0],A
17AD: 52 FB    MOV   A,[X-5]
17AF: 08       PUSH  A
17B0: 52 FC    MOV   A,[X-4]
17B2: 08       PUSH  A
17B3: 50 00    MOV   A,0
17B5: 08       PUSH  A
17B6: 50 0A    MOV   A,10
17B8: 08       PUSH  A
17B9: 7C 56 FD LCALL __mul16
17BC: 38 FC    ADD   SP,252
17BE: 51 AC    MOV   A,[__rX]
17C0: 53 B1    MOV   [__r5],A
17C2: 51 AB    MOV   A,[__rY]
17C4: 53 B2    MOV   [__r4],A
17C6: 51 B1    MOV   A,[__r5]
17C8: 53 AF    MOV   [__r7],A
17CA: 51 B2    MOV   A,[__r4]
17CC: 53 B0    MOV   [__r6],A
17CE: 50 00    MOV   A,0
17D0: 08       PUSH  A
17D1: 08       PUSH  A
17D2: 51 B0    MOV   A,[__r6]
17D4: 08       PUSH  A
17D5: 51 AF    MOV   A,[__r7]
17D7: 08       PUSH  A
17D8: 50 00    MOV   A,0
17DA: 08       PUSH  A
17DB: 08       PUSH  A
17DC: 50 27    MOV   A,39
17DE: 08       PUSH  A
17DF: 50 10    MOV   A,16
17E1: 08       PUSH  A
17E2: 7C 55 EC LCALL __divmodu_32X32_32
17E5: 18       POP   A
17E6: 53 AF    MOV   [__r7],A
17E8: 18       POP   A
17E9: 53 B0    MOV   [__r6],A
17EB: 18       POP   A
17EC: 53 B1    MOV   [__r5],A
17EE: 18       POP   A
17EF: 38 FC    ADD   SP,252
17F1: 08       PUSH  A
17F2: 51 B1    MOV   A,[__r5]
17F4: 08       PUSH  A
17F5: 51 B0    MOV   A,[__r6]
17F7: 08       PUSH  A
17F8: 51 AF    MOV   A,[__r7]
17FA: 08       PUSH  A
17FB: 51 B6    MOV   A,[__r0]
17FD: 08       PUSH  A
17FE: 51 B5    MOV   A,[__r1]
1800: 08       PUSH  A
1801: 51 B4    MOV   A,[__r2]
1803: 08       PUSH  A
1804: 51 B3    MOV   A,[__r3]
1806: 08       PUSH  A
1807: 7C 57 3B LCALL __mul_32X32_32
180A: 38 FC    ADD   SP,252
180C: 18       POP   A
180D: 53 B3    MOV   [__r3],A
180F: 18       POP   A
1810: 53 B4    MOV   [__r2],A
1812: 18       POP   A
1813: 18       POP   A
1814: 51 B3    MOV   A,[__r3]
1816: 53 B5    MOV   [__r1],A
1818: 51 B4    MOV   A,[__r2]
181A: 53 B6    MOV   [__r0],A
181C: 20       POP   X
181D: 7F       RET   
(0245) }
(0246) 
(0247) //-----------------------------------------------------------------------------
(0248) //  FUNCTION NAME:	Calc_Sqrt
(0249) //
(0250) //  DESCRIPTION:
(0251) //
(0252) //	Calculates square root fo integer number
(0253) //
(0254) //  ARGUMENTS:
(0255) //     dwN		Value to calculate
(0256) //
(0257) //  RETURNS:
(0258) //     Square root
(0259) //
(0260) //-----------------------------------------------------------------------------
(0261) static WORD Calc_Sqrt (DWORD dwN)
(0262) {
_Calc_Sqrt:
  ii                   --> X+8
  dwRem                --> X+4
  dwRoot               --> X+0
  dwN                  --> X-7
181E: 10       PUSH  X
181F: 4F       MOV   X,SP
1820: 38 09    ADD   SP,9
(0263) 	DWORD dwRem = 0;
1822: 56 04 00 MOV   [X+4],0
1825: 56 05 00 MOV   [X+5],0
1828: 56 06 00 MOV   [X+6],0
182B: 56 07 00 MOV   [X+7],0
(0264) 	DWORD dwRoot = 0;
182E: 56 00 00 MOV   [X+0],0
1831: 56 01 00 MOV   [X+1],0
1834: 56 02 00 MOV   [X+2],0
1837: 56 03 00 MOV   [X+3],0
(0265) 	BYTE ii;
(0266) 
(0267) 	for (ii=0;ii<16;ii++)
183A: 56 08 00 MOV   [X+8],0
183D: 80 E0    JMP   0x191E
(0268) 	{
(0269) 		dwRoot <<= 1;
183F: 66 03    ASL   [X+3]
1841: 6C 02    RLC   [X+2]
1843: 6C 01    RLC   [X+1]
1845: 6C 00    RLC   [X+0]
(0270) 		dwRem = ((dwRem<<2)+(dwN>>30));
1847: 62 D0 02 MOV   REG[208],2
184A: 52 F9    MOV   A,[X-7]
184C: 53 B6    MOV   [__r0],A
184E: 52 FA    MOV   A,[X-6]
1850: 53 B5    MOV   [__r1],A
1852: 52 FB    MOV   A,[X-5]
1854: 53 B4    MOV   [__r2],A
1856: 52 FC    MOV   A,[X-4]
1858: 53 B3    MOV   [__r3],A
185A: 50 1E    MOV   A,30
185C: 70 FB    AND   F,251
185E: 62 D0 02 MOV   REG[208],2
1861: 6E B6    RRC   [__r0]
1863: 6E B5    RRC   [__r1]
1865: 6E B4    RRC   [__r2]
1867: 6E B3    RRC   [__r3]
1869: 78       DEC   A
186A: BF F1    JNZ   0x185C
186C: 52 04    MOV   A,[X+4]
186E: 53 B2    MOV   [__r4],A
1870: 52 05    MOV   A,[X+5]
1872: 53 B1    MOV   [__r5],A
1874: 52 06    MOV   A,[X+6]
1876: 53 B0    MOV   [__r6],A
1878: 52 07    MOV   A,[X+7]
187A: 53 AF    MOV   [__r7],A
187C: 50 02    MOV   A,2
187E: 62 D0 02 MOV   REG[208],2
1881: 65 AF    ASL   [__r7]
1883: 6B B0    RLC   [__r6]
1885: 6B B1    RLC   [__r5]
1887: 6B B2    RLC   [__r4]
1889: 78       DEC   A
188A: BF F3    JNZ   0x187E
188C: 51 AF    MOV   A,[__r7]
188E: 02 B3    ADD   A,[__r3]
1890: 54 07    MOV   [X+7],A
1892: 51 B0    MOV   A,[__r6]
1894: 0A B4    ADC   A,[__r2]
1896: 54 06    MOV   [X+6],A
1898: 51 B1    MOV   A,[__r5]
189A: 0A B5    ADC   A,[__r1]
189C: 54 05    MOV   [X+5],A
189E: 51 B2    MOV   A,[__r4]
18A0: 0A B6    ADC   A,[__r0]
18A2: 54 04    MOV   [X+4],A
(0271) 		dwN <<= 2;
18A4: 52 F9    MOV   A,[X-7]
18A6: 53 B6    MOV   [__r0],A
18A8: 52 FA    MOV   A,[X-6]
18AA: 53 B5    MOV   [__r1],A
18AC: 52 FB    MOV   A,[X-5]
18AE: 53 B4    MOV   [__r2],A
18B0: 52 FC    MOV   A,[X-4]
18B2: 53 B3    MOV   [__r3],A
18B4: 50 02    MOV   A,2
18B6: 62 D0 02 MOV   REG[208],2
18B9: 65 B3    ASL   [__r3]
18BB: 6B B4    RLC   [__r2]
18BD: 6B B5    RLC   [__r1]
18BF: 6B B6    RLC   [__r0]
18C1: 78       DEC   A
18C2: BF F3    JNZ   0x18B6
18C4: 51 B6    MOV   A,[__r0]
18C6: 54 F9    MOV   [X-7],A
18C8: 51 B5    MOV   A,[__r1]
18CA: 54 FA    MOV   [X-6],A
18CC: 51 B4    MOV   A,[__r2]
18CE: 54 FB    MOV   [X-5],A
18D0: 51 B3    MOV   A,[__r3]
18D2: 54 FC    MOV   [X-4],A
(0272) 		dwRoot++;
18D4: 07 03 01 ADD   [X+3],1
18D7: 0F 02 00 ADC   [X+2],0
18DA: 0F 01 00 ADC   [X+1],0
18DD: 0F 00 00 ADC   [X+0],0
(0273) 		if (dwRoot<=dwRem)
18E0: 52 07    MOV   A,[X+7]
18E2: 13 03    SUB   A,[X+3]
18E4: 52 06    MOV   A,[X+6]
18E6: 1B 02    SBB   A,[X+2]
18E8: 52 05    MOV   A,[X+5]
18EA: 1B 01    SBB   A,[X+1]
18EC: 52 04    MOV   A,[X+4]
18EE: 1B 00    SBB   A,[X+0]
18F0: C0 1F    JC    0x1910
(0274) 		{
(0275) 			dwRem -= dwRoot;
18F2: 52 03    MOV   A,[X+3]
18F4: 15 07    SUB   [X+7],A
18F6: 52 02    MOV   A,[X+2]
18F8: 1D 06    SBB   [X+6],A
18FA: 52 01    MOV   A,[X+1]
18FC: 1D 05    SBB   [X+5],A
18FE: 52 00    MOV   A,[X+0]
1900: 1D 04    SBB   [X+4],A
(0276) 			dwRoot++;
1902: 07 03 01 ADD   [X+3],1
1905: 0F 02 00 ADC   [X+2],0
1908: 0F 01 00 ADC   [X+1],0
190B: 0F 00 00 ADC   [X+0],0
(0277) 		}
190E: 80 0D    JMP   0x191C
(0278) 		else
(0279) 		{
(0280) 			dwRoot--;
1910: 17 03 01 SUB   [X+3],1
1913: 1F 02 00 SBB   [X+2],0
1916: 1F 01 00 SBB   [X+1],0
1919: 1F 00 00 SBB   [X+0],0
191C: 77 08    INC   [X+8]
191E: 3D 08 10 CMP   [X+8],16
1921: CF 1D    JC    0x183F
(0281) 		}
(0282) 	}
(0283) 	return (WORD)(dwRoot>>1);
1923: 62 D0 02 MOV   REG[208],2
1926: 52 00    MOV   A,[X+0]
1928: 53 B6    MOV   [__r0],A
192A: 52 01    MOV   A,[X+1]
192C: 53 B5    MOV   [__r1],A
192E: 52 02    MOV   A,[X+2]
1930: 53 B4    MOV   [__r2],A
1932: 52 03    MOV   A,[X+3]
1934: 53 B3    MOV   [__r3],A
1936: 70 FB    AND   F,251
1938: 6E B6    RRC   [__r0]
193A: 6E B5    RRC   [__r1]
193C: 6E B4    RRC   [__r2]
193E: 6E B3    RRC   [__r3]
1940: 51 B3    MOV   A,[__r3]
1942: 53 B5    MOV   [__r1],A
1944: 51 B4    MOV   A,[__r2]
1946: 53 B6    MOV   [__r0],A
1948: 38 F7    ADD   SP,247
194A: 20       POP   X
194B: 7F       RET   

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\calibrate_reflectometer.c
(0001) //*****************************************************************************/
(0002) //  This file is a part of the "SARK100 SWR Analyzer firmware"
(0003) //
(0004) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
(0005) //  Melchor Varela, Madrid, Spain.
(0006) //  melchor.varela@gmail.com
(0007) //
(0008) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0009) //  and/or modify it under the terms of the GNU General Public License as
(0010) //  published by the Free Software Foundation, either version 3 of the License,
(0011) //  or (at your option) any later version.
(0012) //
(0013) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
(0014) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0015) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
(0016) //  GNU General Public License for more details.
(0017) //
(0018) //  You should have received a copy of the GNU General Public License
(0019) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0020) //  see <http://www.gnu.org/licenses/>.
(0021) //*****************************************************************************/
(0022) //*****************************************************************************/
(0023) //
(0024) //	PROJECT:	SARK100 SWR Analyzer
(0025) // 	FILE NAME: 	CALIBRATE_REFRECTOMETER.C
(0026) // 	AUTHOR:		EA4FRB - Melchor Varela
(0027) //
(0028) // 	DESCRIPTION
(0029) //
(0030) //	Calibration routines
(0031) //
(0032) // 	HISTORY
(0033) //
(0034) //	NAME   	DATE		REMARKS
(0035) //
(0036) //	MVM	   	DEC 2009	Creation
(0037) //
(0038) //*****************************************************************************/
(0039) 
(0040) #include <m8c.h>        				// Part specific constants and macros
(0041) #include "PSoCAPI.h"
(0042) #include "Lcd.h"
(0043) 
(0044) #include "dds.h"
(0045) #include "util.h"
(0046) #include "glb_data.h"
(0047) #include "keypad.h"
(0048) #include "msg_generic.h"
(0049) #include "buzzer.h"
(0050) #include "storage.h"
(0051) #include "display.h"
(0052) #include "calibrate_reflectometer.h"
(0053) #include "calcs.h"
(0054) 
(0055) //#define DEBUG	1						// Uncomment to debug calibration results on USB
(0056) 
(0057) //-----------------------------------------------------------------------------
(0058) //  Typedefs
(0059) //-----------------------------------------------------------------------------
(0060) typedef struct							// Two-point calibration vector
(0061) {
(0062) 	WORD wX0;
(0063) 	WORD wX1;
(0064) 	WORD wY0;
(0065) 	WORD wY1;
(0066) } CALIB_VECTOR;
(0067) 
(0068) //-----------------------------------------------------------------------------
(0069) //  Defines
(0070) //-----------------------------------------------------------------------------
(0071) #define SLOPE_CORRECT		10000
(0072) #define VF_REFERENCE_LEVEL	(4010)		// Full scale value
(0073) #define SWR_274_LOAD		548			// Expected SWR at 274-ohm load
(0074) #define SWR_150_LOAD		300			// Expected SWR at 150-ohm load
(0075) #define WAIT_TIME_MEASURE	500			// Estabilizing time for measurement (ms)
(0076) 
(0077) //-----------------------------------------------------------------------------
(0078) //  Prototypes
(0079) //-----------------------------------------------------------------------------
(0080) static void Calc_Correct (CORRECT_DATA *pxCorr, CALIB_VECTOR *pxVect);
(0081) static WORD Correct_Measure(CORRECT_DATA *pxCorr, WORD wX);
(0082) static BOOL WaitLoadUser (const char *pszText);
(0083) 
(0084) //-----------------------------------------------------------------------------
(0085) //  Private data
(0086) //-----------------------------------------------------------------------------
(0087) static CALIB_VECTOR xCalVz[BAND_MAX];
(0088) static CALIB_VECTOR xCalVr[BAND_MAX];
(0089) static CALIB_VECTOR xCalVa[BAND_MAX];
(0090) 
(0091) //-----------------------------------------------------------------------------
(0092) //  FUNCTION NAME:	Calibrate_Reflectometer()
(0093) //
(0094) //  DESCRIPTION:
(0095) //
(0096) //	Calibration routine
(0097) //
(0098) //  ARGUMENTS:
(0099) //     none.
(0100) //
(0101) //  RETURNS:
(0102) //     none.
(0103) //
(0104) //-----------------------------------------------------------------------------
(0105) void Calibrate_Reflectometer (void)
(0106) {
_Calibrate_Reflectometer:
  ii                   --> X+3
  bGainIdx             --> X+3
  wZero                --> X+1
  bBand                --> X+0
194C: 10       PUSH  X
194D: 4F       MOV   X,SP
194E: 38 04    ADD   SP,4
(0107) 	BYTE bBand;
(0108) 	WORD wZero;
(0109) 
(0110) 	do
(0111) 	{
(0112) 		DISP_Clear();
1950: 7C 32 83 LCALL _DISP_Clear
(0113) 
(0114) 		DDS_Set(0);
1953: 50 00    MOV   A,0
1955: 08       PUSH  A
1956: 08       PUSH  A
1957: 08       PUSH  A
1958: 08       PUSH  A
1959: 7C 28 DC LCALL _DDS_Set
195C: 38 FC    ADD   SP,252
(0115) 		Delay_Ms(WAIT_TIME_MEASURE);
195E: 50 01    MOV   A,1
1960: 08       PUSH  A
1961: 50 F4    MOV   A,244
1963: 08       PUSH  A
1964: 7C 53 01 LCALL _Delay_Ms
(0116) 										// No signal, no load
(0117) 										// Get offset readings
(0118) 		if (!WaitLoadUser(gOpenLoadStr))
1967: 50 04    MOV   A,4
1969: 08       PUSH  A
196A: 50 2C    MOV   A,44
196C: 08       PUSH  A
196D: 7C 28 48 LCALL _WaitLoadUser
1970: 38 FC    ADD   SP,252
1972: 62 D0 02 MOV   REG[208],2
1975: 39 00    CMP   A,0
1977: B0 04    JNZ   0x197C
(0119) 			break;
1979: 7D 23 ED LJMP  0x23ED
(0120) 
(0121) 		DDS_Set(10000000);
197C: 50 00    MOV   A,0
197E: 08       PUSH  A
197F: 50 98    MOV   A,152
1981: 08       PUSH  A
1982: 50 96    MOV   A,150
1984: 08       PUSH  A
1985: 50 80    MOV   A,128
1987: 08       PUSH  A
1988: 7C 28 DC LCALL _DDS_Set
(0122) 		Delay_Ms(WAIT_TIME_MEASURE);
198B: 50 01    MOV   A,1
198D: 08       PUSH  A
198E: 50 F4    MOV   A,244
1990: 08       PUSH  A
1991: 7C 53 01 LCALL _Delay_Ms
1994: 38 FA    ADD   SP,250
(0123) 
(0124) 										// Measures zero level
(0125) 		PGA_ADC_GAIN_CR1 &= ~1;			// Set input to RefLO
1996: 41 72 FE AND   REG[114],254
(0126) 		ADCINC12_GetSamples(1);
1999: 10       PUSH  X
199A: 50 01    MOV   A,1
199C: 7C 10 2D LCALL 0x102D
199F: 20       POP   X
(0127) 										// Wait for data to be ready.
(0128) 		while(ADCINC12_fIsDataAvailable() == 0);
19A0: 10       PUSH  X
19A1: 7C 10 69 LCALL 0x1069
19A4: 62 D0 02 MOV   REG[208],2
19A7: 20       POP   X
19A8: 39 00    CMP   A,0
19AA: AF F5    JZ    0x19A0
(0129) 		wZero = (ADCINC12_iGetData()+2048);
19AC: 10       PUSH  X
19AD: 7C 10 6F LCALL 0x106F
19B0: 62 D0 02 MOV   REG[208],2
19B3: 53 B5    MOV   [__r1],A
19B5: 5A B6    MOV   [__r0],X
19B7: 20       POP   X
19B8: 06 B5 00 ADD   [__r1],0
19BB: 0E B6 08 ADC   [__r0],8
19BE: 51 B5    MOV   A,[__r1]
19C0: 54 02    MOV   [X+2],A
19C2: 51 B6    MOV   A,[__r0]
19C4: 54 01    MOV   [X+1],A
(0130) 		ADCINC12_ClearFlag();
19C6: 10       PUSH  X
19C7: 7C 10 77 LCALL 0x1077
19CA: 20       POP   X
(0131) 
(0132) 		PGA_ADC_GAIN_CR1 |= 1;			// Set input to PortInp
19CB: 43 72 01 OR    REG[114],1
(0133) 
(0134) 										//
(0135) 										// Adjust Vf
(0136) 		for (bBand=0; bBand<BAND_MAX;bBand++)
19CE: 56 00 00 MOV   [X+0],0
19D1: 81 53    JMP   0x1B25
(0137) 		{
(0138) 			BYTE bGainIdx;
(0139) 
(0140) 			DDS_Set(g_xBandLimits[bBand].middle * BAND_FREQ_MULT);
19D3: 62 D0 02 MOV   REG[208],2
19D6: 52 00    MOV   A,[X+0]
19D8: 53 B5    MOV   [__r1],A
19DA: 50 00    MOV   A,0
19DC: 08       PUSH  A
19DD: 51 B5    MOV   A,[__r1]
19DF: 08       PUSH  A
19E0: 50 00    MOV   A,0
19E2: 08       PUSH  A
19E3: 50 06    MOV   A,6
19E5: 08       PUSH  A
19E6: 7C 56 FD LCALL __mul16
19E9: 38 FC    ADD   SP,252
19EB: 51 AC    MOV   A,[__rX]
19ED: 53 B5    MOV   [__r1],A
19EF: 51 AB    MOV   A,[__rY]
19F1: 53 B6    MOV   [__r0],A
19F3: 06 B5 C4 ADD   [__r1],196
19F6: 0E B6 01 ADC   [__r0],1
19F9: 51 B6    MOV   A,[__r0]
19FB: 10       PUSH  X
19FC: 08       PUSH  A
19FD: 58 B5    MOV   X,[__r1]
19FF: 28       ROMX  
1A00: 53 B6    MOV   [__r0],A
1A02: 18       POP   A
1A03: 75       INC   X
1A04: 09 00    ADC   A,0
1A06: 28       ROMX  
1A07: 20       POP   X
1A08: 53 B3    MOV   [__r3],A
1A0A: 51 B6    MOV   A,[__r0]
1A0C: 53 B4    MOV   [__r2],A
1A0E: 50 00    MOV   A,0
1A10: 08       PUSH  A
1A11: 08       PUSH  A
1A12: 51 B4    MOV   A,[__r2]
1A14: 08       PUSH  A
1A15: 51 B3    MOV   A,[__r3]
1A17: 08       PUSH  A
1A18: 50 00    MOV   A,0
1A1A: 08       PUSH  A
1A1B: 50 01    MOV   A,1
1A1D: 08       PUSH  A
1A1E: 50 86    MOV   A,134
1A20: 08       PUSH  A
1A21: 50 A0    MOV   A,160
1A23: 08       PUSH  A
1A24: 7C 57 3B LCALL __mul_32X32_32
1A27: 38 FC    ADD   SP,252
1A29: 18       POP   A
1A2A: 53 B3    MOV   [__r3],A
1A2C: 18       POP   A
1A2D: 53 B4    MOV   [__r2],A
1A2F: 18       POP   A
1A30: 53 B5    MOV   [__r1],A
1A32: 18       POP   A
1A33: 08       PUSH  A
1A34: 51 B5    MOV   A,[__r1]
1A36: 08       PUSH  A
1A37: 51 B4    MOV   A,[__r2]
1A39: 08       PUSH  A
1A3A: 51 B3    MOV   A,[__r3]
1A3C: 08       PUSH  A
1A3D: 7C 28 DC LCALL _DDS_Set
(0141) 			Delay_Ms(WAIT_TIME_MEASURE);
1A40: 50 01    MOV   A,1
1A42: 08       PUSH  A
1A43: 50 F4    MOV   A,244
1A45: 08       PUSH  A
1A46: 7C 53 01 LCALL _Delay_Ms
1A49: 38 FA    ADD   SP,250
(0142) 			for (bGainIdx=0;bGainIdx<GAIN_SETTINGS_MAX;bGainIdx++)
1A4B: 56 03 00 MOV   [X+3],0
1A4E: 80 B2    JMP   0x1B01
(0143) 			{
(0144) 				PGA_DDS_1_SetGain(g_xGainDds[bGainIdx].bGain1);
1A50: 62 D0 02 MOV   REG[208],2
1A53: 52 03    MOV   A,[X+3]
1A55: 53 B5    MOV   [__r1],A
1A57: 55 B6 00 MOV   [__r0],0
1A5A: 65 B5    ASL   [__r1]
1A5C: 6B B6    RLC   [__r0]
1A5E: 06 B5 16 ADD   [__r1],22
1A61: 0E B6 02 ADC   [__r0],2
1A64: 51 B6    MOV   A,[__r0]
1A66: 10       PUSH  X
1A67: 58 B5    MOV   X,[__r1]
1A69: 28       ROMX  
1A6A: 20       POP   X
1A6B: 10       PUSH  X
1A6C: 7C 0C 6B LCALL 0x0C6B
1A6F: 20       POP   X
(0145) 				PGA_DDS_2_SetGain(g_xGainDds[bGainIdx].bGain2);
1A70: 62 D0 02 MOV   REG[208],2
1A73: 52 03    MOV   A,[X+3]
1A75: 53 B5    MOV   [__r1],A
1A77: 55 B6 00 MOV   [__r0],0
1A7A: 65 B5    ASL   [__r1]
1A7C: 6B B6    RLC   [__r0]
1A7E: 06 B5 17 ADD   [__r1],23
1A81: 0E B6 02 ADC   [__r0],2
1A84: 51 B6    MOV   A,[__r0]
1A86: 10       PUSH  X
1A87: 58 B5    MOV   X,[__r1]
1A89: 28       ROMX  
1A8A: 20       POP   X
1A8B: 10       PUSH  X
1A8C: 7C 0C 2B LCALL 0x0C2B
1A8F: 20       POP   X
(0146) 				Delay_Ms(100);
1A90: 50 00    MOV   A,0
1A92: 08       PUSH  A
1A93: 50 64    MOV   A,100
1A95: 08       PUSH  A
1A96: 7C 53 01 LCALL _Delay_Ms
1A99: 38 FE    ADD   SP,254
(0147) 				Do_Measure();
1A9B: 7C 47 0E LCALL _Do_Measure
(0148) 				if (g_xBridgeMeasure.Vf >= (VF_REFERENCE_LEVEL-wZero))
1A9E: 62 D0 02 MOV   REG[208],2
1AA1: 50 AA    MOV   A,170
1AA3: 13 02    SUB   A,[X+2]
1AA5: 53 B5    MOV   [__r1],A
1AA7: 50 0F    MOV   A,15
1AA9: 1B 01    SBB   A,[X+1]
1AAB: 53 B6    MOV   [__r0],A
1AAD: 51 B5    MOV   A,[__r1]
1AAF: 53 B3    MOV   [__r3],A
1AB1: 51 B6    MOV   A,[__r0]
1AB3: 53 B4    MOV   [__r2],A
1AB5: 55 B5 00 MOV   [__r1],0
1AB8: 55 B6 00 MOV   [__r0],0
1ABB: 62 D0 02 MOV   REG[208],2
1ABE: 51 8F    MOV   A,[g_xBridgeMeasure+3]
1AC0: 62 D0 02 MOV   REG[208],2
1AC3: 12 B3    SUB   A,[__r3]
1AC5: 62 D0 02 MOV   REG[208],2
1AC8: 51 8E    MOV   A,[g_xBridgeMeasure+2]
1ACA: 62 D0 02 MOV   REG[208],2
1ACD: 1A B4    SBB   A,[__r2]
1ACF: 62 D0 02 MOV   REG[208],2
1AD2: 51 8D    MOV   A,[g_xBridgeMeasure+1]
1AD4: 62 D0 02 MOV   REG[208],2
1AD7: 1A B5    SBB   A,[__r1]
1AD9: 62 D0 02 MOV   REG[208],2
1ADC: 51 8C    MOV   A,[g_xBridgeMeasure]
1ADE: 62 D0 02 MOV   REG[208],2
1AE1: 1A B6    SBB   A,[__r0]
1AE3: C0 1B    JC    0x1AFF
(0149) 				{
(0150) 					g_bGainDDS[bBand] = bGainIdx;
1AE5: 62 D0 02 MOV   REG[208],2
1AE8: 52 00    MOV   A,[X+0]
1AEA: 53 B5    MOV   [__r1],A
1AEC: 55 B6 00 MOV   [__r0],0
1AEF: 06 B5 9C ADD   [__r1],156
1AF2: 0E B6 02 ADC   [__r0],2
1AF5: 51 B6    MOV   A,[__r0]
1AF7: 60 D5    MOV   REG[213],A
1AF9: 52 03    MOV   A,[X+3]
1AFB: 3F B5    MVI   [__r1],A
(0151) 					break;
1AFD: 80 08    JMP   0x1B06
1AFF: 77 03    INC   [X+3]
1B01: 3D 03 11 CMP   [X+3],17
1B04: CF 4B    JC    0x1A50
(0152) 				}
(0153) 			}
(0154) 			if (bGainIdx==GAIN_SETTINGS_MAX)
1B06: 3D 03 11 CMP   [X+3],17
1B09: B0 19    JNZ   0x1B23
(0155) 			{
(0156) 				g_bGainDDS[bBand] = GAIN_SETTINGS_MAX-1;
1B0B: 62 D0 02 MOV   REG[208],2
1B0E: 52 00    MOV   A,[X+0]
1B10: 53 B5    MOV   [__r1],A
1B12: 55 B6 00 MOV   [__r0],0
1B15: 06 B5 9C ADD   [__r1],156
1B18: 0E B6 02 ADC   [__r0],2
1B1B: 51 B6    MOV   A,[__r0]
1B1D: 60 D5    MOV   REG[213],A
1B1F: 50 10    MOV   A,16
1B21: 3F B5    MVI   [__r1],A
1B23: 77 00    INC   [X+0]
1B25: 3D 00 0E CMP   [X+0],14
1B28: CE AA    JC    0x19D3
(0157) 			}
(0158) 		}
(0159) 										//
(0160) 										// 50ohm load
(0161) 		if (!WaitLoadUser(g50OhmLoadStr))
1B2A: 50 04    MOV   A,4
1B2C: 08       PUSH  A
1B2D: 50 4B    MOV   A,75
1B2F: 08       PUSH  A
1B30: 7C 28 48 LCALL _WaitLoadUser
1B33: 38 FE    ADD   SP,254
1B35: 62 D0 02 MOV   REG[208],2
1B38: 39 00    CMP   A,0
1B3A: B0 04    JNZ   0x1B3F
(0162) 			break;
1B3C: 7D 23 ED LJMP  0x23ED
(0163) 										// At each band frequency, ...
(0164)         								// Determine correction factor for Vz and Va to be 1/2 Vf (using 50-ohm load)
(0165) 		for (bBand=0; bBand<BAND_MAX;bBand++)
1B3F: 56 00 00 MOV   [X+0],0
1B42: 82 3E    JMP   0x1D81
(0166) 		{
(0167) 			Adjust_Dds_Gain(bBand);
1B44: 52 00    MOV   A,[X+0]
1B46: 08       PUSH  A
1B47: 7C 25 35 LCALL _Adjust_Dds_Gain
1B4A: 38 FF    ADD   SP,255
(0168) 			DDS_Set(g_xBandLimits[bBand].middle * BAND_FREQ_MULT);
1B4C: 62 D0 02 MOV   REG[208],2
1B4F: 52 00    MOV   A,[X+0]
1B51: 53 B5    MOV   [__r1],A
1B53: 50 00    MOV   A,0
1B55: 08       PUSH  A
1B56: 51 B5    MOV   A,[__r1]
1B58: 08       PUSH  A
1B59: 50 00    MOV   A,0
1B5B: 08       PUSH  A
1B5C: 50 06    MOV   A,6
1B5E: 08       PUSH  A
1B5F: 7C 56 FD LCALL __mul16
1B62: 38 FC    ADD   SP,252
1B64: 51 AC    MOV   A,[__rX]
1B66: 53 B5    MOV   [__r1],A
1B68: 51 AB    MOV   A,[__rY]
1B6A: 53 B6    MOV   [__r0],A
1B6C: 06 B5 C4 ADD   [__r1],196
1B6F: 0E B6 01 ADC   [__r0],1
1B72: 51 B6    MOV   A,[__r0]
1B74: 10       PUSH  X
1B75: 08       PUSH  A
1B76: 58 B5    MOV   X,[__r1]
1B78: 28       ROMX  
1B79: 53 B6    MOV   [__r0],A
1B7B: 18       POP   A
1B7C: 75       INC   X
1B7D: 09 00    ADC   A,0
1B7F: 28       ROMX  
1B80: 20       POP   X
1B81: 53 B3    MOV   [__r3],A
1B83: 51 B6    MOV   A,[__r0]
1B85: 53 B4    MOV   [__r2],A
1B87: 50 00    MOV   A,0
1B89: 08       PUSH  A
1B8A: 08       PUSH  A
1B8B: 51 B4    MOV   A,[__r2]
1B8D: 08       PUSH  A
1B8E: 51 B3    MOV   A,[__r3]
1B90: 08       PUSH  A
1B91: 50 00    MOV   A,0
1B93: 08       PUSH  A
1B94: 50 01    MOV   A,1
1B96: 08       PUSH  A
1B97: 50 86    MOV   A,134
1B99: 08       PUSH  A
1B9A: 50 A0    MOV   A,160
1B9C: 08       PUSH  A
1B9D: 7C 57 3B LCALL __mul_32X32_32
1BA0: 38 FC    ADD   SP,252
1BA2: 18       POP   A
1BA3: 53 B3    MOV   [__r3],A
1BA5: 18       POP   A
1BA6: 53 B4    MOV   [__r2],A
1BA8: 18       POP   A
1BA9: 53 B5    MOV   [__r1],A
1BAB: 18       POP   A
1BAC: 08       PUSH  A
1BAD: 51 B5    MOV   A,[__r1]
1BAF: 08       PUSH  A
1BB0: 51 B4    MOV   A,[__r2]
1BB2: 08       PUSH  A
1BB3: 51 B3    MOV   A,[__r3]
1BB5: 08       PUSH  A
1BB6: 7C 28 DC LCALL _DDS_Set
(0169) 			Delay_Ms(WAIT_TIME_MEASURE);
1BB9: 50 01    MOV   A,1
1BBB: 08       PUSH  A
1BBC: 50 F4    MOV   A,244
1BBE: 08       PUSH  A
1BBF: 7C 53 01 LCALL _Delay_Ms
1BC2: 38 FA    ADD   SP,250
(0170) 			Do_Measure();
1BC4: 7C 47 0E LCALL _Do_Measure
(0171) 
(0172) 			xCalVz[bBand].wX0 = g_xBridgeMeasure.Vz;
1BC7: 62 D0 02 MOV   REG[208],2
1BCA: 51 9B    MOV   A,[155]
1BCC: 62 D0 02 MOV   REG[208],2
1BCF: 53 B5    MOV   [__r1],A
1BD1: 62 D0 02 MOV   REG[208],2
1BD4: 51 9A    MOV   A,[154]
1BD6: 62 D0 02 MOV   REG[208],2
1BD9: 53 B6    MOV   [__r0],A
1BDB: 52 00    MOV   A,[X+0]
1BDD: 53 B3    MOV   [__r3],A
1BDF: 55 B4 00 MOV   [__r2],0
1BE2: 65 B3    ASL   [__r3]
1BE4: 6B B4    RLC   [__r2]
1BE6: 65 B3    ASL   [__r3]
1BE8: 6B B4    RLC   [__r2]
1BEA: 65 B3    ASL   [__r3]
1BEC: 6B B4    RLC   [__r2]
1BEE: 06 B3 00 ADD   [__r3],0
1BF1: 0E B4 01 ADC   [__r2],1
1BF4: 51 B4    MOV   A,[__r2]
1BF6: 60 D5    MOV   REG[213],A
1BF8: 51 B6    MOV   A,[__r0]
1BFA: 3F B3    MVI   [__r3],A
1BFC: 51 B5    MOV   A,[__r1]
1BFE: 3F B3    MVI   [__r3],A
(0173) 			xCalVz[bBand].wY0 = (DWORD)((DWORD)g_xBridgeMeasure.Vf*CORRECTION_FACTOR)/(DWORD)(2*g_xBridgeMeasure.Vz);
1C00: 62 D0 02 MOV   REG[208],2
1C03: 51 98    MOV   A,[152]
1C05: 08       PUSH  A
1C06: 51 99    MOV   A,[153]
1C08: 08       PUSH  A
1C09: 51 9A    MOV   A,[154]
1C0B: 08       PUSH  A
1C0C: 51 9B    MOV   A,[155]
1C0E: 62 D0 02 MOV   REG[208],2
1C11: 53 B3    MOV   [__r3],A
1C13: 18       POP   A
1C14: 53 B4    MOV   [__r2],A
1C16: 18       POP   A
1C17: 53 B5    MOV   [__r1],A
1C19: 18       POP   A
1C1A: 53 B6    MOV   [__r0],A
1C1C: 65 B3    ASL   [__r3]
1C1E: 6B B4    RLC   [__r2]
1C20: 6B B5    RLC   [__r1]
1C22: 6B B6    RLC   [__r0]
1C24: 62 D0 02 MOV   REG[208],2
1C27: 51 8C    MOV   A,[g_xBridgeMeasure]
1C29: 08       PUSH  A
1C2A: 51 8D    MOV   A,[g_xBridgeMeasure+1]
1C2C: 08       PUSH  A
1C2D: 51 8E    MOV   A,[g_xBridgeMeasure+2]
1C2F: 08       PUSH  A
1C30: 51 8F    MOV   A,[g_xBridgeMeasure+3]
1C32: 08       PUSH  A
1C33: 50 00    MOV   A,0
1C35: 08       PUSH  A
1C36: 08       PUSH  A
1C37: 50 03    MOV   A,3
1C39: 08       PUSH  A
1C3A: 50 E8    MOV   A,232
1C3C: 08       PUSH  A
1C3D: 62 D0 02 MOV   REG[208],2
1C40: 7C 57 3B LCALL __mul_32X32_32
1C43: 38 FC    ADD   SP,252
1C45: 18       POP   A
1C46: 53 AF    MOV   [__r7],A
1C48: 18       POP   A
1C49: 53 B0    MOV   [__r6],A
1C4B: 18       POP   A
1C4C: 53 B1    MOV   [__r5],A
1C4E: 18       POP   A
1C4F: 53 B2    MOV   [__r4],A
1C51: 51 B6    MOV   A,[__r0]
1C53: 08       PUSH  A
1C54: 51 B5    MOV   A,[__r1]
1C56: 08       PUSH  A
1C57: 51 B4    MOV   A,[__r2]
1C59: 08       PUSH  A
1C5A: 51 B3    MOV   A,[__r3]
1C5C: 08       PUSH  A
1C5D: 51 B2    MOV   A,[__r4]
1C5F: 08       PUSH  A
1C60: 51 B1    MOV   A,[__r5]
1C62: 08       PUSH  A
1C63: 51 B0    MOV   A,[__r6]
1C65: 08       PUSH  A
1C66: 51 AF    MOV   A,[__r7]
1C68: 08       PUSH  A
1C69: 7C 55 EC LCALL __divmodu_32X32_32
1C6C: 18       POP   A
1C6D: 53 B3    MOV   [__r3],A
1C6F: 18       POP   A
1C70: 53 B4    MOV   [__r2],A
1C72: 18       POP   A
1C73: 18       POP   A
1C74: 38 FC    ADD   SP,252
1C76: 51 B3    MOV   A,[__r3]
1C78: 53 B5    MOV   [__r1],A
1C7A: 51 B4    MOV   A,[__r2]
1C7C: 53 B6    MOV   [__r0],A
1C7E: 52 00    MOV   A,[X+0]
1C80: 53 B3    MOV   [__r3],A
1C82: 55 B4 00 MOV   [__r2],0
1C85: 65 B3    ASL   [__r3]
1C87: 6B B4    RLC   [__r2]
1C89: 65 B3    ASL   [__r3]
1C8B: 6B B4    RLC   [__r2]
1C8D: 65 B3    ASL   [__r3]
1C8F: 6B B4    RLC   [__r2]
1C91: 06 B3 04 ADD   [__r3],4
1C94: 0E B4 01 ADC   [__r2],1
1C97: 51 B4    MOV   A,[__r2]
1C99: 60 D5    MOV   REG[213],A
1C9B: 51 B6    MOV   A,[__r0]
1C9D: 3F B3    MVI   [__r3],A
1C9F: 51 B5    MOV   A,[__r1]
1CA1: 3F B3    MVI   [__r3],A
(0174) 			xCalVa[bBand].wX0 = g_xBridgeMeasure.Va;
1CA3: 62 D0 02 MOV   REG[208],2
1CA6: 51 97    MOV   A,[151]
1CA8: 62 D0 02 MOV   REG[208],2
1CAB: 53 B5    MOV   [__r1],A
1CAD: 62 D0 02 MOV   REG[208],2
1CB0: 51 96    MOV   A,[150]
1CB2: 62 D0 02 MOV   REG[208],2
1CB5: 53 B6    MOV   [__r0],A
1CB7: 52 00    MOV   A,[X+0]
1CB9: 53 B3    MOV   [__r3],A
1CBB: 55 B4 00 MOV   [__r2],0
1CBE: 65 B3    ASL   [__r3]
1CC0: 6B B4    RLC   [__r2]
1CC2: 65 B3    ASL   [__r3]
1CC4: 6B B4    RLC   [__r2]
1CC6: 65 B3    ASL   [__r3]
1CC8: 6B B4    RLC   [__r2]
1CCA: 06 B3 70 ADD   [__r3],112
1CCD: 0E B4 01 ADC   [__r2],1
1CD0: 51 B4    MOV   A,[__r2]
1CD2: 60 D5    MOV   REG[213],A
1CD4: 51 B6    MOV   A,[__r0]
1CD6: 3F B3    MVI   [__r3],A
1CD8: 51 B5    MOV   A,[__r1]
1CDA: 3F B3    MVI   [__r3],A
(0175) 			xCalVa[bBand].wY0 = (DWORD)((DWORD)g_xBridgeMeasure.Vf*CORRECTION_FACTOR)/(DWORD)(2*g_xBridgeMeasure.Va);
1CDC: 62 D0 02 MOV   REG[208],2
1CDF: 51 94    MOV   A,[148]
1CE1: 08       PUSH  A
1CE2: 51 95    MOV   A,[149]
1CE4: 08       PUSH  A
1CE5: 51 96    MOV   A,[150]
1CE7: 08       PUSH  A
1CE8: 51 97    MOV   A,[151]
1CEA: 62 D0 02 MOV   REG[208],2
1CED: 53 B3    MOV   [__r3],A
1CEF: 18       POP   A
1CF0: 53 B4    MOV   [__r2],A
1CF2: 18       POP   A
1CF3: 53 B5    MOV   [__r1],A
1CF5: 18       POP   A
1CF6: 53 B6    MOV   [__r0],A
1CF8: 65 B3    ASL   [__r3]
1CFA: 6B B4    RLC   [__r2]
1CFC: 6B B5    RLC   [__r1]
1CFE: 6B B6    RLC   [__r0]
1D00: 62 D0 02 MOV   REG[208],2
1D03: 51 8C    MOV   A,[g_xBridgeMeasure]
1D05: 08       PUSH  A
1D06: 51 8D    MOV   A,[g_xBridgeMeasure+1]
1D08: 08       PUSH  A
1D09: 51 8E    MOV   A,[g_xBridgeMeasure+2]
1D0B: 08       PUSH  A
1D0C: 51 8F    MOV   A,[g_xBridgeMeasure+3]
1D0E: 08       PUSH  A
1D0F: 50 00    MOV   A,0
1D11: 08       PUSH  A
1D12: 08       PUSH  A
1D13: 50 03    MOV   A,3
1D15: 08       PUSH  A
1D16: 50 E8    MOV   A,232
1D18: 08       PUSH  A
1D19: 62 D0 02 MOV   REG[208],2
1D1C: 7C 57 3B LCALL __mul_32X32_32
1D1F: 38 FC    ADD   SP,252
1D21: 18       POP   A
1D22: 53 AF    MOV   [__r7],A
1D24: 18       POP   A
1D25: 53 B0    MOV   [__r6],A
1D27: 18       POP   A
1D28: 53 B1    MOV   [__r5],A
1D2A: 18       POP   A
1D2B: 53 B2    MOV   [__r4],A
1D2D: 51 B6    MOV   A,[__r0]
1D2F: 08       PUSH  A
1D30: 51 B5    MOV   A,[__r1]
1D32: 08       PUSH  A
1D33: 51 B4    MOV   A,[__r2]
1D35: 08       PUSH  A
1D36: 51 B3    MOV   A,[__r3]
1D38: 08       PUSH  A
1D39: 51 B2    MOV   A,[__r4]
1D3B: 08       PUSH  A
1D3C: 51 B1    MOV   A,[__r5]
1D3E: 08       PUSH  A
1D3F: 51 B0    MOV   A,[__r6]
1D41: 08       PUSH  A
1D42: 51 AF    MOV   A,[__r7]
1D44: 08       PUSH  A
1D45: 7C 55 EC LCALL __divmodu_32X32_32
1D48: 18       POP   A
1D49: 53 B3    MOV   [__r3],A
1D4B: 18       POP   A
1D4C: 53 B4    MOV   [__r2],A
1D4E: 18       POP   A
1D4F: 18       POP   A
1D50: 38 FC    ADD   SP,252
1D52: 51 B3    MOV   A,[__r3]
1D54: 53 B5    MOV   [__r1],A
1D56: 51 B4    MOV   A,[__r2]
1D58: 53 B6    MOV   [__r0],A
1D5A: 52 00    MOV   A,[X+0]
1D5C: 53 B3    MOV   [__r3],A
1D5E: 55 B4 00 MOV   [__r2],0
1D61: 65 B3    ASL   [__r3]
1D63: 6B B4    RLC   [__r2]
1D65: 65 B3    ASL   [__r3]
1D67: 6B B4    RLC   [__r2]
1D69: 65 B3    ASL   [__r3]
1D6B: 6B B4    RLC   [__r2]
1D6D: 06 B3 74 ADD   [__r3],116
1D70: 0E B4 01 ADC   [__r2],1
1D73: 51 B4    MOV   A,[__r2]
1D75: 60 D5    MOV   REG[213],A
1D77: 51 B6    MOV   A,[__r0]
1D79: 3F B3    MVI   [__r3],A
1D7B: 51 B5    MOV   A,[__r1]
1D7D: 3F B3    MVI   [__r3],A
1D7F: 77 00    INC   [X+0]
1D81: 3D 00 0E CMP   [X+0],14
1D84: CD BF    JC    0x1B44
(0176)         }
(0177) 										//
(0178) 										// 150ohm load
(0179) 		if (!WaitLoadUser(g150OhmLoadStr))
1D86: 50 04    MOV   A,4
1D88: 08       PUSH  A
1D89: 50 5C    MOV   A,92
1D8B: 08       PUSH  A
1D8C: 7C 28 48 LCALL _WaitLoadUser
1D8F: 38 FE    ADD   SP,254
1D91: 62 D0 02 MOV   REG[208],2
1D94: 39 00    CMP   A,0
1D96: B0 03    JNZ   0x1D9A
(0180) 			break;
1D98: 86 54    JMP   0x23ED
(0181) 										// At each band frequency, ...
(0182)         								// Determine correction factor for Vz to be 3/4 Vf and Va to be 1/4 Vf (using 150-ohm load)
(0183) 										// Determine correction factor for Vr --> SWR:300
(0184) 		for (bBand=0; bBand<BAND_MAX;bBand++)
1D9A: 56 00 00 MOV   [X+0],0
1D9D: 83 74    JMP   0x2112
(0185) 		{
(0186) 			Adjust_Dds_Gain(bBand);
1D9F: 52 00    MOV   A,[X+0]
1DA1: 08       PUSH  A
1DA2: 97 91    CALL  _Adjust_Dds_Gain
1DA4: 38 FF    ADD   SP,255
(0187) 			DDS_Set(g_xBandLimits[bBand].middle * BAND_FREQ_MULT);
1DA6: 62 D0 02 MOV   REG[208],2
1DA9: 52 00    MOV   A,[X+0]
1DAB: 53 B5    MOV   [__r1],A
1DAD: 50 00    MOV   A,0
1DAF: 08       PUSH  A
1DB0: 51 B5    MOV   A,[__r1]
1DB2: 08       PUSH  A
1DB3: 50 00    MOV   A,0
1DB5: 08       PUSH  A
1DB6: 50 06    MOV   A,6
1DB8: 08       PUSH  A
1DB9: 7C 56 FD LCALL __mul16
1DBC: 38 FC    ADD   SP,252
1DBE: 51 AC    MOV   A,[__rX]
1DC0: 53 B5    MOV   [__r1],A
1DC2: 51 AB    MOV   A,[__rY]
1DC4: 53 B6    MOV   [__r0],A
1DC6: 06 B5 C4 ADD   [__r1],196
1DC9: 0E B6 01 ADC   [__r0],1
1DCC: 51 B6    MOV   A,[__r0]
1DCE: 10       PUSH  X
1DCF: 08       PUSH  A
1DD0: 58 B5    MOV   X,[__r1]
1DD2: 28       ROMX  
1DD3: 53 B6    MOV   [__r0],A
1DD5: 18       POP   A
1DD6: 75       INC   X
1DD7: 09 00    ADC   A,0
1DD9: 28       ROMX  
1DDA: 20       POP   X
1DDB: 53 B3    MOV   [__r3],A
1DDD: 51 B6    MOV   A,[__r0]
1DDF: 53 B4    MOV   [__r2],A
1DE1: 50 00    MOV   A,0
1DE3: 08       PUSH  A
1DE4: 08       PUSH  A
1DE5: 51 B4    MOV   A,[__r2]
1DE7: 08       PUSH  A
1DE8: 51 B3    MOV   A,[__r3]
1DEA: 08       PUSH  A
1DEB: 50 00    MOV   A,0
1DED: 08       PUSH  A
1DEE: 50 01    MOV   A,1
1DF0: 08       PUSH  A
1DF1: 50 86    MOV   A,134
1DF3: 08       PUSH  A
1DF4: 50 A0    MOV   A,160
1DF6: 08       PUSH  A
1DF7: 7C 57 3B LCALL __mul_32X32_32
1DFA: 38 FC    ADD   SP,252
1DFC: 18       POP   A
1DFD: 53 B3    MOV   [__r3],A
1DFF: 18       POP   A
1E00: 53 B4    MOV   [__r2],A
1E02: 18       POP   A
1E03: 53 B5    MOV   [__r1],A
1E05: 18       POP   A
1E06: 08       PUSH  A
1E07: 51 B5    MOV   A,[__r1]
1E09: 08       PUSH  A
1E0A: 51 B4    MOV   A,[__r2]
1E0C: 08       PUSH  A
1E0D: 51 B3    MOV   A,[__r3]
1E0F: 08       PUSH  A
1E10: 7C 28 DC LCALL _DDS_Set
(0188) 			Delay_Ms(WAIT_TIME_MEASURE);
1E13: 50 01    MOV   A,1
1E15: 08       PUSH  A
1E16: 50 F4    MOV   A,244
1E18: 08       PUSH  A
1E19: 7C 53 01 LCALL _Delay_Ms
1E1C: 38 FA    ADD   SP,250
(0189) 			Do_Measure();
1E1E: 7C 47 0E LCALL _Do_Measure
(0190) 
(0191) 			xCalVz[bBand].wX1 = g_xBridgeMeasure.Vz;
1E21: 62 D0 02 MOV   REG[208],2
1E24: 51 9B    MOV   A,[155]
1E26: 62 D0 02 MOV   REG[208],2
1E29: 53 B5    MOV   [__r1],A
1E2B: 62 D0 02 MOV   REG[208],2
1E2E: 51 9A    MOV   A,[154]
1E30: 62 D0 02 MOV   REG[208],2
1E33: 53 B6    MOV   [__r0],A
1E35: 52 00    MOV   A,[X+0]
1E37: 53 B3    MOV   [__r3],A
1E39: 55 B4 00 MOV   [__r2],0
1E3C: 65 B3    ASL   [__r3]
1E3E: 6B B4    RLC   [__r2]
1E40: 65 B3    ASL   [__r3]
1E42: 6B B4    RLC   [__r2]
1E44: 65 B3    ASL   [__r3]
1E46: 6B B4    RLC   [__r2]
1E48: 06 B3 02 ADD   [__r3],2
1E4B: 0E B4 01 ADC   [__r2],1
1E4E: 51 B4    MOV   A,[__r2]
1E50: 60 D5    MOV   REG[213],A
1E52: 51 B6    MOV   A,[__r0]
1E54: 3F B3    MVI   [__r3],A
1E56: 51 B5    MOV   A,[__r1]
1E58: 3F B3    MVI   [__r3],A
(0192) 			xCalVz[bBand].wY1 = (DWORD)((DWORD)g_xBridgeMeasure.Vf*CORRECTION_FACTOR*3)/(DWORD)(4*g_xBridgeMeasure.Vz);
1E5A: 62 D0 02 MOV   REG[208],2
1E5D: 51 98    MOV   A,[152]
1E5F: 08       PUSH  A
1E60: 51 99    MOV   A,[153]
1E62: 08       PUSH  A
1E63: 51 9A    MOV   A,[154]
1E65: 08       PUSH  A
1E66: 51 9B    MOV   A,[155]
1E68: 62 D0 02 MOV   REG[208],2
1E6B: 53 B3    MOV   [__r3],A
1E6D: 18       POP   A
1E6E: 53 B4    MOV   [__r2],A
1E70: 18       POP   A
1E71: 53 B5    MOV   [__r1],A
1E73: 18       POP   A
1E74: 53 B6    MOV   [__r0],A
1E76: 50 02    MOV   A,2
1E78: 62 D0 02 MOV   REG[208],2
1E7B: 65 B3    ASL   [__r3]
1E7D: 6B B4    RLC   [__r2]
1E7F: 6B B5    RLC   [__r1]
1E81: 6B B6    RLC   [__r0]
1E83: 78       DEC   A
1E84: BF F3    JNZ   0x1E78
1E86: 62 D0 02 MOV   REG[208],2
1E89: 51 8C    MOV   A,[g_xBridgeMeasure]
1E8B: 08       PUSH  A
1E8C: 51 8D    MOV   A,[g_xBridgeMeasure+1]
1E8E: 08       PUSH  A
1E8F: 51 8E    MOV   A,[g_xBridgeMeasure+2]
1E91: 08       PUSH  A
1E92: 51 8F    MOV   A,[g_xBridgeMeasure+3]
1E94: 08       PUSH  A
1E95: 50 00    MOV   A,0
1E97: 08       PUSH  A
1E98: 08       PUSH  A
1E99: 50 03    MOV   A,3
1E9B: 08       PUSH  A
1E9C: 50 E8    MOV   A,232
1E9E: 08       PUSH  A
1E9F: 62 D0 02 MOV   REG[208],2
1EA2: 7C 57 3B LCALL __mul_32X32_32
1EA5: 38 FC    ADD   SP,252
1EA7: 18       POP   A
1EA8: 53 AF    MOV   [__r7],A
1EAA: 18       POP   A
1EAB: 53 B0    MOV   [__r6],A
1EAD: 18       POP   A
1EAE: 53 B1    MOV   [__r5],A
1EB0: 18       POP   A
1EB1: 08       PUSH  A
1EB2: 51 B1    MOV   A,[__r5]
1EB4: 08       PUSH  A
1EB5: 51 B0    MOV   A,[__r6]
1EB7: 08       PUSH  A
1EB8: 51 AF    MOV   A,[__r7]
1EBA: 08       PUSH  A
1EBB: 50 00    MOV   A,0
1EBD: 08       PUSH  A
1EBE: 08       PUSH  A
1EBF: 08       PUSH  A
1EC0: 50 03    MOV   A,3
1EC2: 08       PUSH  A
1EC3: 7C 57 3B LCALL __mul_32X32_32
1EC6: 38 FC    ADD   SP,252
1EC8: 18       POP   A
1EC9: 53 AF    MOV   [__r7],A
1ECB: 18       POP   A
1ECC: 53 B0    MOV   [__r6],A
1ECE: 18       POP   A
1ECF: 53 B1    MOV   [__r5],A
1ED1: 18       POP   A
1ED2: 53 B2    MOV   [__r4],A
1ED4: 51 B6    MOV   A,[__r0]
1ED6: 08       PUSH  A
1ED7: 51 B5    MOV   A,[__r1]
1ED9: 08       PUSH  A
1EDA: 51 B4    MOV   A,[__r2]
1EDC: 08       PUSH  A
1EDD: 51 B3    MOV   A,[__r3]
1EDF: 08       PUSH  A
1EE0: 51 B2    MOV   A,[__r4]
1EE2: 08       PUSH  A
1EE3: 51 B1    MOV   A,[__r5]
1EE5: 08       PUSH  A
1EE6: 51 B0    MOV   A,[__r6]
1EE8: 08       PUSH  A
1EE9: 51 AF    MOV   A,[__r7]
1EEB: 08       PUSH  A
1EEC: 7C 55 EC LCALL __divmodu_32X32_32
1EEF: 18       POP   A
1EF0: 53 B3    MOV   [__r3],A
1EF2: 18       POP   A
1EF3: 53 B4    MOV   [__r2],A
1EF5: 18       POP   A
1EF6: 18       POP   A
1EF7: 38 FC    ADD   SP,252
1EF9: 51 B3    MOV   A,[__r3]
1EFB: 53 B5    MOV   [__r1],A
1EFD: 51 B4    MOV   A,[__r2]
1EFF: 53 B6    MOV   [__r0],A
1F01: 52 00    MOV   A,[X+0]
1F03: 53 B3    MOV   [__r3],A
1F05: 55 B4 00 MOV   [__r2],0
1F08: 65 B3    ASL   [__r3]
1F0A: 6B B4    RLC   [__r2]
1F0C: 65 B3    ASL   [__r3]
1F0E: 6B B4    RLC   [__r2]
1F10: 65 B3    ASL   [__r3]
1F12: 6B B4    RLC   [__r2]
1F14: 06 B3 06 ADD   [__r3],6
1F17: 0E B4 01 ADC   [__r2],1
1F1A: 51 B4    MOV   A,[__r2]
1F1C: 60 D5    MOV   REG[213],A
1F1E: 51 B6    MOV   A,[__r0]
1F20: 3F B3    MVI   [__r3],A
1F22: 51 B5    MOV   A,[__r1]
1F24: 3F B3    MVI   [__r3],A
(0193) 			xCalVa[bBand].wX1 = g_xBridgeMeasure.Va;
1F26: 62 D0 02 MOV   REG[208],2
1F29: 51 97    MOV   A,[151]
1F2B: 62 D0 02 MOV   REG[208],2
1F2E: 53 B5    MOV   [__r1],A
1F30: 62 D0 02 MOV   REG[208],2
1F33: 51 96    MOV   A,[150]
1F35: 62 D0 02 MOV   REG[208],2
1F38: 53 B6    MOV   [__r0],A
1F3A: 52 00    MOV   A,[X+0]
1F3C: 53 B3    MOV   [__r3],A
1F3E: 55 B4 00 MOV   [__r2],0
1F41: 65 B3    ASL   [__r3]
1F43: 6B B4    RLC   [__r2]
1F45: 65 B3    ASL   [__r3]
1F47: 6B B4    RLC   [__r2]
1F49: 65 B3    ASL   [__r3]
1F4B: 6B B4    RLC   [__r2]
1F4D: 06 B3 72 ADD   [__r3],114
1F50: 0E B4 01 ADC   [__r2],1
1F53: 51 B4    MOV   A,[__r2]
1F55: 60 D5    MOV   REG[213],A
1F57: 51 B6    MOV   A,[__r0]
1F59: 3F B3    MVI   [__r3],A
1F5B: 51 B5    MOV   A,[__r1]
1F5D: 3F B3    MVI   [__r3],A
(0194) 			xCalVa[bBand].wY1 = (DWORD)((DWORD)g_xBridgeMeasure.Vf*CORRECTION_FACTOR)/(DWORD)(4*g_xBridgeMeasure.Va);
1F5F: 62 D0 02 MOV   REG[208],2
1F62: 51 94    MOV   A,[148]
1F64: 08       PUSH  A
1F65: 51 95    MOV   A,[149]
1F67: 08       PUSH  A
1F68: 51 96    MOV   A,[150]
1F6A: 08       PUSH  A
1F6B: 51 97    MOV   A,[151]
1F6D: 62 D0 02 MOV   REG[208],2
1F70: 53 B3    MOV   [__r3],A
1F72: 18       POP   A
1F73: 53 B4    MOV   [__r2],A
1F75: 18       POP   A
1F76: 53 B5    MOV   [__r1],A
1F78: 18       POP   A
1F79: 53 B6    MOV   [__r0],A
1F7B: 50 02    MOV   A,2
1F7D: 62 D0 02 MOV   REG[208],2
1F80: 65 B3    ASL   [__r3]
1F82: 6B B4    RLC   [__r2]
1F84: 6B B5    RLC   [__r1]
1F86: 6B B6    RLC   [__r0]
1F88: 78       DEC   A
1F89: BF F3    JNZ   0x1F7D
1F8B: 62 D0 02 MOV   REG[208],2
1F8E: 51 8C    MOV   A,[g_xBridgeMeasure]
1F90: 08       PUSH  A
1F91: 51 8D    MOV   A,[g_xBridgeMeasure+1]
1F93: 08       PUSH  A
1F94: 51 8E    MOV   A,[g_xBridgeMeasure+2]
1F96: 08       PUSH  A
1F97: 51 8F    MOV   A,[g_xBridgeMeasure+3]
1F99: 08       PUSH  A
1F9A: 50 00    MOV   A,0
1F9C: 08       PUSH  A
1F9D: 08       PUSH  A
1F9E: 50 03    MOV   A,3
1FA0: 08       PUSH  A
1FA1: 50 E8    MOV   A,232
1FA3: 08       PUSH  A
1FA4: 62 D0 02 MOV   REG[208],2
1FA7: 7C 57 3B LCALL __mul_32X32_32
1FAA: 38 FC    ADD   SP,252
1FAC: 18       POP   A
1FAD: 53 AF    MOV   [__r7],A
1FAF: 18       POP   A
1FB0: 53 B0    MOV   [__r6],A
1FB2: 18       POP   A
1FB3: 53 B1    MOV   [__r5],A
1FB5: 18       POP   A
1FB6: 53 B2    MOV   [__r4],A
1FB8: 51 B6    MOV   A,[__r0]
1FBA: 08       PUSH  A
1FBB: 51 B5    MOV   A,[__r1]
1FBD: 08       PUSH  A
1FBE: 51 B4    MOV   A,[__r2]
1FC0: 08       PUSH  A
1FC1: 51 B3    MOV   A,[__r3]
1FC3: 08       PUSH  A
1FC4: 51 B2    MOV   A,[__r4]
1FC6: 08       PUSH  A
1FC7: 51 B1    MOV   A,[__r5]
1FC9: 08       PUSH  A
1FCA: 51 B0    MOV   A,[__r6]
1FCC: 08       PUSH  A
1FCD: 51 AF    MOV   A,[__r7]
1FCF: 08       PUSH  A
1FD0: 7C 55 EC LCALL __divmodu_32X32_32
1FD3: 18       POP   A
1FD4: 53 B3    MOV   [__r3],A
1FD6: 18       POP   A
1FD7: 53 B4    MOV   [__r2],A
1FD9: 18       POP   A
1FDA: 18       POP   A
1FDB: 38 FC    ADD   SP,252
1FDD: 51 B3    MOV   A,[__r3]
1FDF: 53 B5    MOV   [__r1],A
1FE1: 51 B4    MOV   A,[__r2]
1FE3: 53 B6    MOV   [__r0],A
1FE5: 52 00    MOV   A,[X+0]
1FE7: 53 B3    MOV   [__r3],A
1FE9: 55 B4 00 MOV   [__r2],0
1FEC: 65 B3    ASL   [__r3]
1FEE: 6B B4    RLC   [__r2]
1FF0: 65 B3    ASL   [__r3]
1FF2: 6B B4    RLC   [__r2]
1FF4: 65 B3    ASL   [__r3]
1FF6: 6B B4    RLC   [__r2]
1FF8: 06 B3 76 ADD   [__r3],118
1FFB: 0E B4 01 ADC   [__r2],1
1FFE: 51 B4    MOV   A,[__r2]
2000: 60 D5    MOV   REG[213],A
2002: 51 B6    MOV   A,[__r0]
2004: 3F B3    MVI   [__r3],A
2006: 51 B5    MOV   A,[__r1]
2008: 3F B3    MVI   [__r3],A
(0195) 
(0196) 			xCalVr[bBand].wX0 = g_xBridgeMeasure.Vr;
200A: 62 D0 02 MOV   REG[208],2
200D: 51 93    MOV   A,[147]
200F: 62 D0 02 MOV   REG[208],2
2012: 53 B5    MOV   [__r1],A
2014: 62 D0 02 MOV   REG[208],2
2017: 51 92    MOV   A,[146]
2019: 62 D0 02 MOV   REG[208],2
201C: 53 B6    MOV   [__r0],A
201E: 52 00    MOV   A,[X+0]
2020: 53 B3    MOV   [__r3],A
2022: 55 B4 00 MOV   [__r2],0
2025: 65 B3    ASL   [__r3]
2027: 6B B4    RLC   [__r2]
2029: 65 B3    ASL   [__r3]
202B: 6B B4    RLC   [__r2]
202D: 65 B3    ASL   [__r3]
202F: 6B B4    RLC   [__r2]
2031: 06 B3 00 ADD   [__r3],0
2034: 0E B4 02 ADC   [__r2],2
2037: 51 B4    MOV   A,[__r2]
2039: 60 D5    MOV   REG[213],A
203B: 51 B6    MOV   A,[__r0]
203D: 3F B3    MVI   [__r3],A
203F: 51 B5    MOV   A,[__r1]
2041: 3F B3    MVI   [__r3],A
(0197) 			xCalVr[bBand].wY0 = ((DWORD)(((SWR_150_LOAD-100)*g_xBridgeMeasure.Vf)/(SWR_150_LOAD+100))*CORRECTION_FACTOR)/(DWORD)g_xBridgeMeasure.Vr;
2043: 62 D0 02 MOV   REG[208],2
2046: 51 8C    MOV   A,[g_xBridgeMeasure]
2048: 08       PUSH  A
2049: 51 8D    MOV   A,[g_xBridgeMeasure+1]
204B: 08       PUSH  A
204C: 51 8E    MOV   A,[g_xBridgeMeasure+2]
204E: 08       PUSH  A
204F: 51 8F    MOV   A,[g_xBridgeMeasure+3]
2051: 08       PUSH  A
2052: 50 00    MOV   A,0
2054: 08       PUSH  A
2055: 08       PUSH  A
2056: 08       PUSH  A
2057: 50 C8    MOV   A,200
2059: 08       PUSH  A
205A: 62 D0 02 MOV   REG[208],2
205D: 7C 57 3B LCALL __mul_32X32_32
2060: 38 FC    ADD   SP,252
2062: 18       POP   A
2063: 53 B3    MOV   [__r3],A
2065: 18       POP   A
2066: 53 B4    MOV   [__r2],A
2068: 18       POP   A
2069: 53 B5    MOV   [__r1],A
206B: 18       POP   A
206C: 53 B6    MOV   [__r0],A
206E: 50 00    MOV   A,0
2070: 08       PUSH  A
2071: 08       PUSH  A
2072: 50 01    MOV   A,1
2074: 08       PUSH  A
2075: 50 90    MOV   A,144
2077: 08       PUSH  A
2078: 51 B6    MOV   A,[__r0]
207A: 08       PUSH  A
207B: 51 B5    MOV   A,[__r1]
207D: 08       PUSH  A
207E: 51 B4    MOV   A,[__r2]
2080: 08       PUSH  A
2081: 51 B3    MOV   A,[__r3]
2083: 08       PUSH  A
2084: 7C 55 EC LCALL __divmodu_32X32_32
2087: 18       POP   A
2088: 53 B3    MOV   [__r3],A
208A: 18       POP   A
208B: 53 B4    MOV   [__r2],A
208D: 18       POP   A
208E: 53 B5    MOV   [__r1],A
2090: 18       POP   A
2091: 38 FC    ADD   SP,252
2093: 08       PUSH  A
2094: 51 B5    MOV   A,[__r1]
2096: 08       PUSH  A
2097: 51 B4    MOV   A,[__r2]
2099: 08       PUSH  A
209A: 51 B3    MOV   A,[__r3]
209C: 08       PUSH  A
209D: 50 00    MOV   A,0
209F: 08       PUSH  A
20A0: 08       PUSH  A
20A1: 50 03    MOV   A,3
20A3: 08       PUSH  A
20A4: 50 E8    MOV   A,232
20A6: 08       PUSH  A
20A7: 7C 57 3B LCALL __mul_32X32_32
20AA: 38 FC    ADD   SP,252
20AC: 18       POP   A
20AD: 53 B3    MOV   [__r3],A
20AF: 18       POP   A
20B0: 53 B4    MOV   [__r2],A
20B2: 18       POP   A
20B3: 53 B5    MOV   [__r1],A
20B5: 18       POP   A
20B6: 53 B6    MOV   [__r0],A
20B8: 62 D0 02 MOV   REG[208],2
20BB: 51 90    MOV   A,[144]
20BD: 08       PUSH  A
20BE: 51 91    MOV   A,[145]
20C0: 08       PUSH  A
20C1: 51 92    MOV   A,[146]
20C3: 08       PUSH  A
20C4: 51 93    MOV   A,[147]
20C6: 08       PUSH  A
20C7: 62 D0 02 MOV   REG[208],2
20CA: 51 B6    MOV   A,[__r0]
20CC: 08       PUSH  A
20CD: 51 B5    MOV   A,[__r1]
20CF: 08       PUSH  A
20D0: 51 B4    MOV   A,[__r2]
20D2: 08       PUSH  A
20D3: 51 B3    MOV   A,[__r3]
20D5: 08       PUSH  A
20D6: 7C 55 EC LCALL __divmodu_32X32_32
20D9: 18       POP   A
20DA: 53 B3    MOV   [__r3],A
20DC: 18       POP   A
20DD: 53 B4    MOV   [__r2],A
20DF: 18       POP   A
20E0: 18       POP   A
20E1: 38 FC    ADD   SP,252
20E3: 51 B3    MOV   A,[__r3]
20E5: 53 B5    MOV   [__r1],A
20E7: 51 B4    MOV   A,[__r2]
20E9: 53 B6    MOV   [__r0],A
20EB: 52 00    MOV   A,[X+0]
20ED: 53 B3    MOV   [__r3],A
20EF: 55 B4 00 MOV   [__r2],0
20F2: 65 B3    ASL   [__r3]
20F4: 6B B4    RLC   [__r2]
20F6: 65 B3    ASL   [__r3]
20F8: 6B B4    RLC   [__r2]
20FA: 65 B3    ASL   [__r3]
20FC: 6B B4    RLC   [__r2]
20FE: 06 B3 04 ADD   [__r3],4
2101: 0E B4 02 ADC   [__r2],2
2104: 51 B4    MOV   A,[__r2]
2106: 60 D5    MOV   REG[213],A
2108: 51 B6    MOV   A,[__r0]
210A: 3F B3    MVI   [__r3],A
210C: 51 B5    MOV   A,[__r1]
210E: 3F B3    MVI   [__r3],A
2110: 77 00    INC   [X+0]
2112: 3D 00 0E CMP   [X+0],14
2115: CC 89    JC    0x1D9F
(0198)         }
(0199) 
(0200) 										// 274ohm load
(0201) 		if (!WaitLoadUser(g274OhmLoadStr))
2117: 50 04    MOV   A,4
2119: 08       PUSH  A
211A: 50 6D    MOV   A,109
211C: 08       PUSH  A
211D: 97 29    CALL  _WaitLoadUser
211F: 38 FE    ADD   SP,254
2121: 62 D0 02 MOV   REG[208],2
2124: 39 00    CMP   A,0
2126: B0 03    JNZ   0x212A
(0202) 			break;
2128: 82 C4    JMP   0x23ED
(0203) 										// At each band frequency, ...
(0204)         								// Determine correction factor for Vr to get a SWR of 548 (using 274-ohm load)
(0205) 		for (bBand=0; bBand<BAND_MAX;bBand++)
212A: 56 00 00 MOV   [X+0],0
212D: 82 77    JMP   0x23A5
(0206) 		{
(0207) 			BYTE ii;
(0208) 
(0209) 			Adjust_Dds_Gain(bBand);
212F: 52 00    MOV   A,[X+0]
2131: 08       PUSH  A
2132: 94 01    CALL  _Adjust_Dds_Gain
2134: 38 FF    ADD   SP,255
(0210) 			DDS_Set(g_xBandLimits[bBand].middle * BAND_FREQ_MULT);
2136: 62 D0 02 MOV   REG[208],2
2139: 52 00    MOV   A,[X+0]
213B: 53 B5    MOV   [__r1],A
213D: 50 00    MOV   A,0
213F: 08       PUSH  A
2140: 51 B5    MOV   A,[__r1]
2142: 08       PUSH  A
2143: 50 00    MOV   A,0
2145: 08       PUSH  A
2146: 50 06    MOV   A,6
2148: 08       PUSH  A
2149: 7C 56 FD LCALL __mul16
214C: 38 FC    ADD   SP,252
214E: 51 AC    MOV   A,[__rX]
2150: 53 B5    MOV   [__r1],A
2152: 51 AB    MOV   A,[__rY]
2154: 53 B6    MOV   [__r0],A
2156: 06 B5 C4 ADD   [__r1],196
2159: 0E B6 01 ADC   [__r0],1
215C: 51 B6    MOV   A,[__r0]
215E: 10       PUSH  X
215F: 08       PUSH  A
2160: 58 B5    MOV   X,[__r1]
2162: 28       ROMX  
2163: 53 B6    MOV   [__r0],A
2165: 18       POP   A
2166: 75       INC   X
2167: 09 00    ADC   A,0
2169: 28       ROMX  
216A: 20       POP   X
216B: 53 B3    MOV   [__r3],A
216D: 51 B6    MOV   A,[__r0]
216F: 53 B4    MOV   [__r2],A
2171: 50 00    MOV   A,0
2173: 08       PUSH  A
2174: 08       PUSH  A
2175: 51 B4    MOV   A,[__r2]
2177: 08       PUSH  A
2178: 51 B3    MOV   A,[__r3]
217A: 08       PUSH  A
217B: 50 00    MOV   A,0
217D: 08       PUSH  A
217E: 50 01    MOV   A,1
2180: 08       PUSH  A
2181: 50 86    MOV   A,134
2183: 08       PUSH  A
2184: 50 A0    MOV   A,160
2186: 08       PUSH  A
2187: 7C 57 3B LCALL __mul_32X32_32
218A: 38 FC    ADD   SP,252
218C: 18       POP   A
218D: 53 B3    MOV   [__r3],A
218F: 18       POP   A
2190: 53 B4    MOV   [__r2],A
2192: 18       POP   A
2193: 53 B5    MOV   [__r1],A
2195: 18       POP   A
2196: 08       PUSH  A
2197: 51 B5    MOV   A,[__r1]
2199: 08       PUSH  A
219A: 51 B4    MOV   A,[__r2]
219C: 08       PUSH  A
219D: 51 B3    MOV   A,[__r3]
219F: 08       PUSH  A
21A0: 7C 28 DC LCALL _DDS_Set
(0211) 			Delay_Ms(WAIT_TIME_MEASURE);
21A3: 50 01    MOV   A,1
21A5: 08       PUSH  A
21A6: 50 F4    MOV   A,244
21A8: 08       PUSH  A
21A9: 7C 53 01 LCALL _Delay_Ms
21AC: 38 FA    ADD   SP,250
(0212) 			Do_Measure();
21AE: 7C 47 0E LCALL _Do_Measure
(0213) 
(0214) 			xCalVr[bBand].wX1 = g_xBridgeMeasure.Vr;
21B1: 62 D0 02 MOV   REG[208],2
21B4: 51 93    MOV   A,[147]
21B6: 62 D0 02 MOV   REG[208],2
21B9: 53 B5    MOV   [__r1],A
21BB: 62 D0 02 MOV   REG[208],2
21BE: 51 92    MOV   A,[146]
21C0: 62 D0 02 MOV   REG[208],2
21C3: 53 B6    MOV   [__r0],A
21C5: 52 00    MOV   A,[X+0]
21C7: 53 B3    MOV   [__r3],A
21C9: 55 B4 00 MOV   [__r2],0
21CC: 65 B3    ASL   [__r3]
21CE: 6B B4    RLC   [__r2]
21D0: 65 B3    ASL   [__r3]
21D2: 6B B4    RLC   [__r2]
21D4: 65 B3    ASL   [__r3]
21D6: 6B B4    RLC   [__r2]
21D8: 06 B3 02 ADD   [__r3],2
21DB: 0E B4 02 ADC   [__r2],2
21DE: 51 B4    MOV   A,[__r2]
21E0: 60 D5    MOV   REG[213],A
21E2: 51 B6    MOV   A,[__r0]
21E4: 3F B3    MVI   [__r3],A
21E6: 51 B5    MOV   A,[__r1]
21E8: 3F B3    MVI   [__r3],A
(0215) 			xCalVr[bBand].wY1 = ((DWORD)(((SWR_274_LOAD-100)*g_xBridgeMeasure.Vf)/(SWR_274_LOAD+100))*CORRECTION_FACTOR)/(DWORD)g_xBridgeMeasure.Vr;
21EA: 62 D0 02 MOV   REG[208],2
21ED: 51 8C    MOV   A,[g_xBridgeMeasure]
21EF: 08       PUSH  A
21F0: 51 8D    MOV   A,[g_xBridgeMeasure+1]
21F2: 08       PUSH  A
21F3: 51 8E    MOV   A,[g_xBridgeMeasure+2]
21F5: 08       PUSH  A
21F6: 51 8F    MOV   A,[g_xBridgeMeasure+3]
21F8: 08       PUSH  A
21F9: 50 00    MOV   A,0
21FB: 08       PUSH  A
21FC: 08       PUSH  A
21FD: 50 01    MOV   A,1
21FF: 08       PUSH  A
2200: 50 C0    MOV   A,192
2202: 08       PUSH  A
2203: 62 D0 02 MOV   REG[208],2
2206: 7C 57 3B LCALL __mul_32X32_32
2209: 38 FC    ADD   SP,252
220B: 18       POP   A
220C: 53 B3    MOV   [__r3],A
220E: 18       POP   A
220F: 53 B4    MOV   [__r2],A
2211: 18       POP   A
2212: 53 B5    MOV   [__r1],A
2214: 18       POP   A
2215: 53 B6    MOV   [__r0],A
2217: 50 00    MOV   A,0
2219: 08       PUSH  A
221A: 08       PUSH  A
221B: 50 02    MOV   A,2
221D: 08       PUSH  A
221E: 50 88    MOV   A,136
2220: 08       PUSH  A
2221: 51 B6    MOV   A,[__r0]
2223: 08       PUSH  A
2224: 51 B5    MOV   A,[__r1]
2226: 08       PUSH  A
2227: 51 B4    MOV   A,[__r2]
2229: 08       PUSH  A
222A: 51 B3    MOV   A,[__r3]
222C: 08       PUSH  A
222D: 7C 55 EC LCALL __divmodu_32X32_32
2230: 18       POP   A
2231: 53 B3    MOV   [__r3],A
2233: 18       POP   A
2234: 53 B4    MOV   [__r2],A
2236: 18       POP   A
2237: 53 B5    MOV   [__r1],A
2239: 18       POP   A
223A: 38 FC    ADD   SP,252
223C: 08       PUSH  A
223D: 51 B5    MOV   A,[__r1]
223F: 08       PUSH  A
2240: 51 B4    MOV   A,[__r2]
2242: 08       PUSH  A
2243: 51 B3    MOV   A,[__r3]
2245: 08       PUSH  A
2246: 50 00    MOV   A,0
2248: 08       PUSH  A
2249: 08       PUSH  A
224A: 50 03    MOV   A,3
224C: 08       PUSH  A
224D: 50 E8    MOV   A,232
224F: 08       PUSH  A
2250: 7C 57 3B LCALL __mul_32X32_32
2253: 38 FC    ADD   SP,252
2255: 18       POP   A
2256: 53 B3    MOV   [__r3],A
2258: 18       POP   A
2259: 53 B4    MOV   [__r2],A
225B: 18       POP   A
225C: 53 B5    MOV   [__r1],A
225E: 18       POP   A
225F: 53 B6    MOV   [__r0],A
2261: 62 D0 02 MOV   REG[208],2
2264: 51 90    MOV   A,[144]
2266: 08       PUSH  A
2267: 51 91    MOV   A,[145]
2269: 08       PUSH  A
226A: 51 92    MOV   A,[146]
226C: 08       PUSH  A
226D: 51 93    MOV   A,[147]
226F: 08       PUSH  A
2270: 62 D0 02 MOV   REG[208],2
2273: 51 B6    MOV   A,[__r0]
2275: 08       PUSH  A
2276: 51 B5    MOV   A,[__r1]
2278: 08       PUSH  A
2279: 51 B4    MOV   A,[__r2]
227B: 08       PUSH  A
227C: 51 B3    MOV   A,[__r3]
227E: 08       PUSH  A
227F: 7C 55 EC LCALL __divmodu_32X32_32
2282: 18       POP   A
2283: 53 B3    MOV   [__r3],A
2285: 18       POP   A
2286: 53 B4    MOV   [__r2],A
2288: 18       POP   A
2289: 18       POP   A
228A: 38 FC    ADD   SP,252
228C: 51 B3    MOV   A,[__r3]
228E: 53 B5    MOV   [__r1],A
2290: 51 B4    MOV   A,[__r2]
2292: 53 B6    MOV   [__r0],A
2294: 52 00    MOV   A,[X+0]
2296: 53 B3    MOV   [__r3],A
2298: 55 B4 00 MOV   [__r2],0
229B: 65 B3    ASL   [__r3]
229D: 6B B4    RLC   [__r2]
229F: 65 B3    ASL   [__r3]
22A1: 6B B4    RLC   [__r2]
22A3: 65 B3    ASL   [__r3]
22A5: 6B B4    RLC   [__r2]
22A7: 06 B3 06 ADD   [__r3],6
22AA: 0E B4 02 ADC   [__r2],2
22AD: 51 B4    MOV   A,[__r2]
22AF: 60 D5    MOV   REG[213],A
22B1: 51 B6    MOV   A,[__r0]
22B3: 3F B3    MVI   [__r3],A
22B5: 51 B5    MOV   A,[__r1]
22B7: 3F B3    MVI   [__r3],A
(0216) 
(0217) 										// Convert calibration factor to slope and offset
(0218) 			Calc_Correct(&g_xBandCorrFactor[bBand].xVz, &xCalVz[bBand]);
22B9: 52 00    MOV   A,[X+0]
22BB: 53 B5    MOV   [__r1],A
22BD: 55 B6 00 MOV   [__r0],0
22C0: 65 B5    ASL   [__r1]
22C2: 6B B6    RLC   [__r0]
22C4: 65 B5    ASL   [__r1]
22C6: 6B B6    RLC   [__r0]
22C8: 65 B5    ASL   [__r1]
22CA: 6B B6    RLC   [__r0]
22CC: 06 B5 00 ADD   [__r1],0
22CF: 0E B6 01 ADC   [__r0],1
22D2: 51 B6    MOV   A,[__r0]
22D4: 08       PUSH  A
22D5: 51 B5    MOV   A,[__r1]
22D7: 08       PUSH  A
22D8: 52 00    MOV   A,[X+0]
22DA: 53 B5    MOV   [__r1],A
22DC: 50 00    MOV   A,0
22DE: 08       PUSH  A
22DF: 51 B5    MOV   A,[__r1]
22E1: 08       PUSH  A
22E2: 50 00    MOV   A,0
22E4: 08       PUSH  A
22E5: 50 0C    MOV   A,12
22E7: 08       PUSH  A
22E8: 7C 56 FD LCALL __mul16
22EB: 38 FC    ADD   SP,252
22ED: 51 AC    MOV   A,[__rX]
22EF: 53 B5    MOV   [__r1],A
22F1: 51 AB    MOV   A,[__rY]
22F3: 53 B6    MOV   [__r0],A
22F5: 06 B5 0F ADD   [__r1],15
22F8: 0E B6 00 ADC   [__r0],0
22FB: 51 B6    MOV   A,[__r0]
22FD: 08       PUSH  A
22FE: 51 B5    MOV   A,[__r1]
2300: 08       PUSH  A
2301: 93 6B    CALL  _Calc_Correct
2303: 38 FC    ADD   SP,252
(0219) 			Calc_Correct(&g_xBandCorrFactor[bBand].xVa, &xCalVa[bBand]);
2305: 62 D0 02 MOV   REG[208],2
2308: 52 00    MOV   A,[X+0]
230A: 53 B5    MOV   [__r1],A
230C: 55 B6 00 MOV   [__r0],0
230F: 65 B5    ASL   [__r1]
2311: 6B B6    RLC   [__r0]
2313: 65 B5    ASL   [__r1]
2315: 6B B6    RLC   [__r0]
2317: 65 B5    ASL   [__r1]
2319: 6B B6    RLC   [__r0]
231B: 06 B5 70 ADD   [__r1],112
231E: 0E B6 01 ADC   [__r0],1
2321: 51 B6    MOV   A,[__r0]
2323: 08       PUSH  A
2324: 51 B5    MOV   A,[__r1]
2326: 08       PUSH  A
2327: 52 00    MOV   A,[X+0]
2329: 53 B5    MOV   [__r1],A
232B: 50 00    MOV   A,0
232D: 08       PUSH  A
232E: 51 B5    MOV   A,[__r1]
2330: 08       PUSH  A
2331: 50 00    MOV   A,0
2333: 08       PUSH  A
2334: 50 0C    MOV   A,12
2336: 08       PUSH  A
2337: 7C 56 FD LCALL __mul16
233A: 38 FC    ADD   SP,252
233C: 51 AC    MOV   A,[__rX]
233E: 53 B5    MOV   [__r1],A
2340: 51 AB    MOV   A,[__rY]
2342: 53 B6    MOV   [__r0],A
2344: 06 B5 13 ADD   [__r1],19
2347: 0E B6 00 ADC   [__r0],0
234A: 51 B6    MOV   A,[__r0]
234C: 08       PUSH  A
234D: 51 B5    MOV   A,[__r1]
234F: 08       PUSH  A
2350: 93 1C    CALL  _Calc_Correct
2352: 38 FC    ADD   SP,252
(0220) 			Calc_Correct(&g_xBandCorrFactor[bBand].xVr, &xCalVr[bBand]);
2354: 62 D0 02 MOV   REG[208],2
2357: 52 00    MOV   A,[X+0]
2359: 53 B5    MOV   [__r1],A
235B: 55 B6 00 MOV   [__r0],0
235E: 65 B5    ASL   [__r1]
2360: 6B B6    RLC   [__r0]
2362: 65 B5    ASL   [__r1]
2364: 6B B6    RLC   [__r0]
2366: 65 B5    ASL   [__r1]
2368: 6B B6    RLC   [__r0]
236A: 06 B5 00 ADD   [__r1],0
236D: 0E B6 02 ADC   [__r0],2
2370: 51 B6    MOV   A,[__r0]
2372: 08       PUSH  A
2373: 51 B5    MOV   A,[__r1]
2375: 08       PUSH  A
2376: 52 00    MOV   A,[X+0]
2378: 53 B5    MOV   [__r1],A
237A: 50 00    MOV   A,0
237C: 08       PUSH  A
237D: 51 B5    MOV   A,[__r1]
237F: 08       PUSH  A
2380: 50 00    MOV   A,0
2382: 08       PUSH  A
2383: 50 0C    MOV   A,12
2385: 08       PUSH  A
2386: 7C 56 FD LCALL __mul16
2389: 38 FC    ADD   SP,252
238B: 51 AC    MOV   A,[__rX]
238D: 53 B5    MOV   [__r1],A
238F: 51 AB    MOV   A,[__rY]
2391: 53 B6    MOV   [__r0],A
2393: 06 B5 0B ADD   [__r1],11
2396: 0E B6 00 ADC   [__r0],0
2399: 51 B6    MOV   A,[__r0]
239B: 08       PUSH  A
239C: 51 B5    MOV   A,[__r1]
239E: 08       PUSH  A
239F: 92 CD    CALL  _Calc_Correct
23A1: 38 FC    ADD   SP,252
23A3: 77 00    INC   [X+0]
23A5: 3D 00 0E CMP   [X+0],14
23A8: CD 86    JC    0x212F
(0221)         }
(0222) 
(0223) 										// Store data
(0224) 		g_bIsCalibrated = TRUE;
23AA: 62 D0 02 MOV   REG[208],2
23AD: 55 F5 01 MOV   [g_bIsCalibrated],1
(0225) 		STR_SaveCalibration();
23B0: 7C 50 FB LCALL _STR_SaveCalibration
(0226) 
(0227) 										// Finish, alert user
(0228) 		DISP_Clear();
23B3: 7C 32 83 LCALL _DISP_Clear
(0229) 		LCD_Position(0, 0);
23B6: 10       PUSH  X
23B7: 50 00    MOV   A,0
23B9: 5C       MOV   X,A
23BA: 7C 0E 5E LCALL 0x0E5E
23BD: 20       POP   X
(0230) 		LCD_PrCString(gConfigCalibStr);
23BE: 10       PUSH  X
23BF: 50 03    MOV   A,3
23C1: 08       PUSH  A
23C2: 50 66    MOV   A,102
23C4: 5C       MOV   X,A
23C5: 18       POP   A
23C6: 7C 0C D9 LCALL 0x0CD9
23C9: 20       POP   X
(0231) 		LCD_Position(1, 0);
23CA: 10       PUSH  X
23CB: 57 00    MOV   X,0
23CD: 50 01    MOV   A,1
23CF: 7C 0E 5E LCALL 0x0E5E
23D2: 20       POP   X
(0232) 		LCD_PrCString(gDoneStr);
23D3: 10       PUSH  X
23D4: 50 04    MOV   A,4
23D6: 08       PUSH  A
23D7: 50 1D    MOV   A,29
23D9: 5C       MOV   X,A
23DA: 18       POP   A
23DB: 7C 0C D9 LCALL 0x0CD9
23DE: 20       POP   X
(0233) 		BUZZ_Beep();
23DF: 7C 12 76 LCALL _BUZZ_Beep
(0234) 		KEYPAD_WaitKey(TIME_WAIT_KEY_S);
23E2: 50 1E    MOV   A,30
23E4: 08       PUSH  A
23E5: 7C 33 12 LCALL _KEYPAD_WaitKey
23E8: 38 FF    ADD   SP,255
23EA: 62 D0 02 MOV   REG[208],2
(0235) 	}
(0236) 	while (FALSE);
23ED: 38 FC    ADD   SP,252
23EF: 20       POP   X
23F0: 7F       RET   
(0237) 
(0238) #ifdef DEBUG
(0239) {
(0240) 	BYTE szMsg[20];
(0241) 
(0242) 	UART_CmdReset(); 					// Initialize receiver/cmd buffer
(0243) 	UART_IntCntl(UART_ENABLE_RX_INT); 	// Enable RX interrupts
(0244) 	UART_Start(UART_PARITY_NONE); 		// Enable UART
(0245) 	M8C_EnableGInt ;
(0246) 	UART_PutChar(12); 					// Clear the screen
(0247) 
(0248) 	UART_CPutString("Zero:");
(0249) 	itoa(szMsg, wZero, 10);
(0250) 	UART_PutString(szMsg);
(0251) 	UART_PutCRLF();
(0252) 										// Print correction factors
(0253) 	for (bBand=0; bBand<BAND_MAX;bBand++)
(0254) 	{
(0255) 		UART_CPutString("Band:");
(0256) 		itoa(szMsg, bBand, 10);
(0257) 		UART_PutString(szMsg);
(0258) 
(0259) 		UART_CPutString("\t G=");
(0260) 		itoa(szMsg, g_bGainDDS[bBand], 10);
(0261) 		UART_PutString(szMsg);
(0262) 
(0263) 		UART_CPutString("\t VR.S=");
(0264) 		ltoa(szMsg, g_xBandCorrFactor[bBand].xVr.iSlope, 10);
(0265) 		UART_PutString(szMsg);
(0266) 
(0267) 		UART_CPutString("\t VR.O=");
(0268) 		ltoa(szMsg, g_xBandCorrFactor[bBand].xVr.iOffset, 10);
(0269) 		UART_PutString(szMsg);
(0270) 
(0271) 		UART_CPutString("\t VZ.S=");
(0272) 		ltoa(szMsg, g_xBandCorrFactor[bBand].xVz.iSlope, 10);
(0273) 		UART_PutString(szMsg);
(0274) 
(0275) 		UART_CPutString("\t VZ.O=");
(0276) 		ltoa(szMsg, g_xBandCorrFactor[bBand].xVz.iOffset, 10);
(0277) 		UART_PutString(szMsg);
(0278) 
(0279) 		UART_CPutString("\t VA.S=");
(0280) 		ltoa(szMsg, g_xBandCorrFactor[bBand].xVa.iSlope, 10);
(0281) 		UART_PutString(szMsg);
(0282) 
(0283) 		UART_CPutString("\t VA.O=");
(0284) 		ltoa(szMsg, g_xBandCorrFactor[bBand].xVa.iOffset, 10);
(0285) 		UART_PutString(szMsg);
(0286) 
(0287) 		UART_PutCRLF();
(0288) 	}
(0289) 	UART_Stop();
(0290) }
(0291) #endif
(0292) }
(0293) 
(0294) //-----------------------------------------------------------------------------
(0295) //  FUNCTION NAME:	Do_Correct()
(0296) //
(0297) //  DESCRIPTION:
(0298) //
(0299) //	Do the complete adjustment of the measurement based on two-point calibration data
(0300) //
(0301) //  ARGUMENTS:
(0302) //  	none
(0303) //
(0304) //  RETURNS:
(0305) //     none.
(0306) //
(0307) //-----------------------------------------------------------------------------
(0308) void Do_Correct (void)
(0309) {
(0310) 	g_xBridgeMeasure.Vf *= CORRECTION_FACTOR;
_Do_Correct:
23F1: 62 D0 02 MOV   REG[208],2
23F4: 51 8C    MOV   A,[g_xBridgeMeasure]
23F6: 08       PUSH  A
23F7: 51 8D    MOV   A,[g_xBridgeMeasure+1]
23F9: 08       PUSH  A
23FA: 51 8E    MOV   A,[g_xBridgeMeasure+2]
23FC: 08       PUSH  A
23FD: 51 8F    MOV   A,[g_xBridgeMeasure+3]
23FF: 08       PUSH  A
2400: 50 00    MOV   A,0
2402: 08       PUSH  A
2403: 08       PUSH  A
2404: 50 03    MOV   A,3
2406: 08       PUSH  A
2407: 50 E8    MOV   A,232
2409: 08       PUSH  A
240A: 62 D0 02 MOV   REG[208],2
240D: 7C 57 3B LCALL __mul_32X32_32
2410: 38 FC    ADD   SP,252
2412: 18       POP   A
2413: 62 D0 02 MOV   REG[208],2
2416: 53 8F    MOV   [g_xBridgeMeasure+3],A
2418: 18       POP   A
2419: 53 8E    MOV   [g_xBridgeMeasure+2],A
241B: 18       POP   A
241C: 53 8D    MOV   [g_xBridgeMeasure+1],A
241E: 18       POP   A
241F: 53 8C    MOV   [g_xBridgeMeasure],A
(0311) 	g_xBridgeMeasure.Vr *= Correct_Measure(&g_xBridgeCorrect.xVr, g_xBridgeMeasure.Vr);
2421: 51 93    MOV   A,[147]
2423: 62 D0 02 MOV   REG[208],2
2426: 53 B5    MOV   [__r1],A
2428: 62 D0 02 MOV   REG[208],2
242B: 51 92    MOV   A,[146]
242D: 62 D0 02 MOV   REG[208],2
2430: 08       PUSH  A
2431: 51 B5    MOV   A,[__r1]
2433: 08       PUSH  A
2434: 50 00    MOV   A,0
2436: 08       PUSH  A
2437: 50 EB    MOV   A,235
2439: 08       PUSH  A
243A: 91 5F    CALL  _Correct_Measure
243C: 38 FC    ADD   SP,252
243E: 62 D0 02 MOV   REG[208],2
2441: 51 B5    MOV   A,[__r1]
2443: 53 B3    MOV   [__r3],A
2445: 51 B6    MOV   A,[__r0]
2447: 53 B4    MOV   [__r2],A
2449: 50 00    MOV   A,0
244B: 08       PUSH  A
244C: 08       PUSH  A
244D: 51 B4    MOV   A,[__r2]
244F: 08       PUSH  A
2450: 51 B3    MOV   A,[__r3]
2452: 08       PUSH  A
2453: 62 D0 02 MOV   REG[208],2
2456: 51 90    MOV   A,[144]
2458: 08       PUSH  A
2459: 51 91    MOV   A,[145]
245B: 08       PUSH  A
245C: 51 92    MOV   A,[146]
245E: 08       PUSH  A
245F: 51 93    MOV   A,[147]
2461: 08       PUSH  A
2462: 62 D0 02 MOV   REG[208],2
2465: 7C 57 3B LCALL __mul_32X32_32
2468: 38 FC    ADD   SP,252
246A: 18       POP   A
246B: 62 D0 02 MOV   REG[208],2
246E: 53 93    MOV   [147],A
2470: 18       POP   A
2471: 53 92    MOV   [146],A
2473: 18       POP   A
2474: 53 91    MOV   [145],A
2476: 18       POP   A
2477: 53 90    MOV   [144],A
(0312) 	if (g_bScanning == FALSE)
2479: 62 D0 02 MOV   REG[208],2
247C: 3C F4 00 CMP   [g_bScanning],0
247F: B0 B4    JNZ   0x2534
(0313) 	{
(0314) 		g_xBridgeMeasure.Vz *= Correct_Measure(&g_xBridgeCorrect.xVz, g_xBridgeMeasure.Vz);
2481: 62 D0 02 MOV   REG[208],2
2484: 51 9B    MOV   A,[155]
2486: 62 D0 02 MOV   REG[208],2
2489: 53 B5    MOV   [__r1],A
248B: 62 D0 02 MOV   REG[208],2
248E: 51 9A    MOV   A,[154]
2490: 62 D0 02 MOV   REG[208],2
2493: 08       PUSH  A
2494: 51 B5    MOV   A,[__r1]
2496: 08       PUSH  A
2497: 50 00    MOV   A,0
2499: 08       PUSH  A
249A: 50 EF    MOV   A,239
249C: 08       PUSH  A
249D: 90 FC    CALL  _Correct_Measure
249F: 38 FC    ADD   SP,252
24A1: 62 D0 02 MOV   REG[208],2
24A4: 51 B5    MOV   A,[__r1]
24A6: 53 B3    MOV   [__r3],A
24A8: 51 B6    MOV   A,[__r0]
24AA: 53 B4    MOV   [__r2],A
24AC: 50 00    MOV   A,0
24AE: 08       PUSH  A
24AF: 08       PUSH  A
24B0: 51 B4    MOV   A,[__r2]
24B2: 08       PUSH  A
24B3: 51 B3    MOV   A,[__r3]
24B5: 08       PUSH  A
24B6: 62 D0 02 MOV   REG[208],2
24B9: 51 98    MOV   A,[152]
24BB: 08       PUSH  A
24BC: 51 99    MOV   A,[153]
24BE: 08       PUSH  A
24BF: 51 9A    MOV   A,[154]
24C1: 08       PUSH  A
24C2: 51 9B    MOV   A,[155]
24C4: 08       PUSH  A
24C5: 62 D0 02 MOV   REG[208],2
24C8: 7C 57 3B LCALL __mul_32X32_32
24CB: 38 FC    ADD   SP,252
24CD: 18       POP   A
24CE: 62 D0 02 MOV   REG[208],2
24D1: 53 9B    MOV   [155],A
24D3: 18       POP   A
24D4: 53 9A    MOV   [154],A
24D6: 18       POP   A
24D7: 53 99    MOV   [153],A
24D9: 18       POP   A
24DA: 53 98    MOV   [152],A
(0315) 		g_xBridgeMeasure.Va *= Correct_Measure(&g_xBridgeCorrect.xVa, g_xBridgeMeasure.Va);
24DC: 51 97    MOV   A,[151]
24DE: 62 D0 02 MOV   REG[208],2
24E1: 53 B5    MOV   [__r1],A
24E3: 62 D0 02 MOV   REG[208],2
24E6: 51 96    MOV   A,[150]
24E8: 62 D0 02 MOV   REG[208],2
24EB: 08       PUSH  A
24EC: 51 B5    MOV   A,[__r1]
24EE: 08       PUSH  A
24EF: 50 00    MOV   A,0
24F1: 08       PUSH  A
24F2: 50 F3    MOV   A,243
24F4: 08       PUSH  A
24F5: 90 A4    CALL  _Correct_Measure
24F7: 38 FC    ADD   SP,252
24F9: 62 D0 02 MOV   REG[208],2
24FC: 51 B5    MOV   A,[__r1]
24FE: 53 B3    MOV   [__r3],A
2500: 51 B6    MOV   A,[__r0]
2502: 53 B4    MOV   [__r2],A
2504: 50 00    MOV   A,0
2506: 08       PUSH  A
2507: 08       PUSH  A
2508: 51 B4    MOV   A,[__r2]
250A: 08       PUSH  A
250B: 51 B3    MOV   A,[__r3]
250D: 08       PUSH  A
250E: 62 D0 02 MOV   REG[208],2
2511: 51 94    MOV   A,[148]
2513: 08       PUSH  A
2514: 51 95    MOV   A,[149]
2516: 08       PUSH  A
2517: 51 96    MOV   A,[150]
2519: 08       PUSH  A
251A: 51 97    MOV   A,[151]
251C: 08       PUSH  A
251D: 62 D0 02 MOV   REG[208],2
2520: 7C 57 3B LCALL __mul_32X32_32
2523: 38 FC    ADD   SP,252
2525: 18       POP   A
2526: 62 D0 02 MOV   REG[208],2
2529: 53 97    MOV   [151],A
252B: 18       POP   A
252C: 53 96    MOV   [150],A
252E: 18       POP   A
252F: 53 95    MOV   [149],A
2531: 18       POP   A
2532: 53 94    MOV   [148],A
(0316) 	}
2534: 7F       RET   
(0317) }
(0318) 
(0319) //-----------------------------------------------------------------------------
(0320) //  FUNCTION NAME:	Adjust_Dds_Gain()
(0321) //
(0322) //  DESCRIPTION:
(0323) //
(0324) //	Adjust PGA's gain for setting right DDS level
(0325) //
(0326) //  ARGUMENTS:
(0327) //  	bBand	Integer describing band number
(0328) //
(0329) //  RETURNS:
(0330) //     none.
(0331) //
(0332) //-----------------------------------------------------------------------------
(0333) void Adjust_Dds_Gain (BYTE bBand)
(0334) {
_Adjust_Dds_Gain:
  bBand                --> X-4
2535: 10       PUSH  X
2536: 4F       MOV   X,SP
(0335) 	PGA_DDS_1_SetGain(g_xGainDds[g_bGainDDS[bBand]].bGain1);
2537: 62 D0 02 MOV   REG[208],2
253A: 52 FC    MOV   A,[X-4]
253C: 53 B5    MOV   [__r1],A
253E: 55 B6 00 MOV   [__r0],0
2541: 06 B5 9C ADD   [__r1],156
2544: 0E B6 02 ADC   [__r0],2
2547: 51 B6    MOV   A,[__r0]
2549: 60 D4    MOV   REG[212],A
254B: 3E B5    MVI   A,[__r1]
254D: 53 B5    MOV   [__r1],A
254F: 55 B6 00 MOV   [__r0],0
2552: 65 B5    ASL   [__r1]
2554: 6B B6    RLC   [__r0]
2556: 06 B5 16 ADD   [__r1],22
2559: 0E B6 02 ADC   [__r0],2
255C: 51 B6    MOV   A,[__r0]
255E: 10       PUSH  X
255F: 58 B5    MOV   X,[__r1]
2561: 28       ROMX  
2562: 20       POP   X
2563: 10       PUSH  X
2564: 7C 0C 6B LCALL 0x0C6B
2567: 20       POP   X
(0336) 	PGA_DDS_2_SetGain(g_xGainDds[g_bGainDDS[bBand]].bGain2);
2568: 62 D0 02 MOV   REG[208],2
256B: 52 FC    MOV   A,[X-4]
256D: 53 B5    MOV   [__r1],A
256F: 55 B6 00 MOV   [__r0],0
2572: 06 B5 9C ADD   [__r1],156
2575: 0E B6 02 ADC   [__r0],2
2578: 51 B6    MOV   A,[__r0]
257A: 60 D4    MOV   REG[212],A
257C: 3E B5    MVI   A,[__r1]
257E: 53 B5    MOV   [__r1],A
2580: 55 B6 00 MOV   [__r0],0
2583: 65 B5    ASL   [__r1]
2585: 6B B6    RLC   [__r0]
2587: 06 B5 17 ADD   [__r1],23
258A: 0E B6 02 ADC   [__r0],2
258D: 51 B6    MOV   A,[__r0]
258F: 10       PUSH  X
2590: 58 B5    MOV   X,[__r1]
2592: 28       ROMX  
2593: 20       POP   X
2594: 10       PUSH  X
2595: 7C 0C 2B LCALL 0x0C2B
2598: 20       POP   X
2599: 20       POP   X
259A: 7F       RET   
(0337) }
(0338) 
(0339) //-----------------------------------------------------------------------------
(0340) //  FUNCTION NAME:	Correct_Measure()
(0341) //
(0342) //  DESCRIPTION:
(0343) //
(0344) //	Corrects measurement: y=mx+b
(0345) //
(0346) //  ARGUMENTS:
(0347) //  	pxCorr	Correction data (slope and offset)
(0348) //		wX		Data to correct
(0349) //
(0350) //  RETURNS:
(0351) //     none.
(0352) //
(0353) //-----------------------------------------------------------------------------
(0354) static WORD Correct_Measure(CORRECT_DATA *pxCorr, WORD wX)
(0355) {
_Correct_Measure:
  wX                   --> X-7
  pxCorr               --> X-5
259B: 10       PUSH  X
259C: 4F       MOV   X,SP
(0356) 	return (((LONG)pxCorr->iSlope*(LONG)wX)/SLOPE_CORRECT)+pxCorr->iOffset;
259D: 62 D0 02 MOV   REG[208],2
25A0: 52 FC    MOV   A,[X-4]
25A2: 53 B5    MOV   [__r1],A
25A4: 52 FB    MOV   A,[X-5]
25A6: 60 D4    MOV   REG[212],A
25A8: 3E B5    MVI   A,[__r1]
25AA: 53 B6    MOV   [__r0],A
25AC: 3E B5    MVI   A,[__r1]
25AE: 53 B3    MOV   [__r3],A
25B0: 51 B6    MOV   A,[__r0]
25B2: 53 B4    MOV   [__r2],A
25B4: 47 B4 80 TST   [__r2],128
25B7: A0 09    JZ    0x25C1
25B9: 55 B5 FF MOV   [__r1],255
25BC: 55 B6 FF MOV   [__r0],255
25BF: 80 0A    JMP   0x25CA
25C1: 62 D0 02 MOV   REG[208],2
25C4: 55 B5 00 MOV   [__r1],0
25C7: 55 B6 00 MOV   [__r0],0
25CA: 62 D0 02 MOV   REG[208],2
25CD: 52 FA    MOV   A,[X-6]
25CF: 53 AF    MOV   [__r7],A
25D1: 52 F9    MOV   A,[X-7]
25D3: 53 B0    MOV   [__r6],A
25D5: 50 00    MOV   A,0
25D7: 08       PUSH  A
25D8: 08       PUSH  A
25D9: 51 B0    MOV   A,[__r6]
25DB: 08       PUSH  A
25DC: 51 AF    MOV   A,[__r7]
25DE: 08       PUSH  A
25DF: 51 B6    MOV   A,[__r0]
25E1: 08       PUSH  A
25E2: 51 B5    MOV   A,[__r1]
25E4: 08       PUSH  A
25E5: 51 B4    MOV   A,[__r2]
25E7: 08       PUSH  A
25E8: 51 B3    MOV   A,[__r3]
25EA: 08       PUSH  A
25EB: 7C 57 3B LCALL __mul_32X32_32
25EE: 38 FC    ADD   SP,252
25F0: 18       POP   A
25F1: 53 B3    MOV   [__r3],A
25F3: 18       POP   A
25F4: 53 B4    MOV   [__r2],A
25F6: 18       POP   A
25F7: 53 B5    MOV   [__r1],A
25F9: 18       POP   A
25FA: 53 B6    MOV   [__r0],A
25FC: 50 00    MOV   A,0
25FE: 08       PUSH  A
25FF: 08       PUSH  A
2600: 50 27    MOV   A,39
2602: 08       PUSH  A
2603: 50 10    MOV   A,16
2605: 08       PUSH  A
2606: 51 B6    MOV   A,[__r0]
2608: 08       PUSH  A
2609: 51 B5    MOV   A,[__r1]
260B: 08       PUSH  A
260C: 51 B4    MOV   A,[__r2]
260E: 08       PUSH  A
260F: 51 B3    MOV   A,[__r3]
2611: 08       PUSH  A
2612: 7C 55 A4 LCALL __divmod_32X32_32
2615: 18       POP   A
2616: 53 B3    MOV   [__r3],A
2618: 18       POP   A
2619: 53 B4    MOV   [__r2],A
261B: 18       POP   A
261C: 53 B5    MOV   [__r1],A
261E: 18       POP   A
261F: 53 B6    MOV   [__r0],A
2621: 38 FC    ADD   SP,252
2623: 52 FC    MOV   A,[X-4]
2625: 01 02    ADD   A,2
2627: 53 B1    MOV   [__r5],A
2629: 52 FB    MOV   A,[X-5]
262B: 09 00    ADC   A,0
262D: 60 D4    MOV   REG[212],A
262F: 3E B1    MVI   A,[__r5]
2631: 53 B2    MOV   [__r4],A
2633: 3E B1    MVI   A,[__r5]
2635: 53 AF    MOV   [__r7],A
2637: 51 B2    MOV   A,[__r4]
2639: 53 B0    MOV   [__r6],A
263B: 47 B0 80 TST   [__r6],128
263E: A0 09    JZ    0x2648
2640: 55 B1 FF MOV   [__r5],255
2643: 55 B2 FF MOV   [__r4],255
2646: 80 0A    JMP   0x2651
2648: 62 D0 02 MOV   REG[208],2
264B: 55 B1 00 MOV   [__r5],0
264E: 55 B2 00 MOV   [__r4],0
2651: 62 D0 02 MOV   REG[208],2
2654: 51 AF    MOV   A,[__r7]
2656: 04 B3    ADD   [__r3],A
2658: 51 B0    MOV   A,[__r6]
265A: 0C B4    ADC   [__r2],A
265C: 51 B1    MOV   A,[__r5]
265E: 0C B5    ADC   [__r1],A
2660: 51 B2    MOV   A,[__r4]
2662: 0C B6    ADC   [__r0],A
2664: 51 B3    MOV   A,[__r3]
2666: 53 B5    MOV   [__r1],A
2668: 51 B4    MOV   A,[__r2]
266A: 53 B6    MOV   [__r0],A
266C: 20       POP   X
266D: 7F       RET   
(0357) }
(0358) 
(0359) //-----------------------------------------------------------------------------
(0360) //  FUNCTION NAME:	Calc_Correct()
(0361) //
(0362) //  DESCRIPTION:
(0363) //
(0364) //	Converts two-point calibration vector to slope and offset
(0365) //
(0366) //  ARGUMENTS:
(0367) //  	pxCorr	Correction data (slope and offset)
(0368) //		pxVect	Calibration vector
(0369) //
(0370) //  RETURNS:
(0371) //     none.
(0372) //
(0373) //-----------------------------------------------------------------------------
(0374) static void Calc_Correct (CORRECT_DATA *pxCorr, CALIB_VECTOR *pxVect)
(0375) {
_Calc_Correct:
  lTmp                 --> X+0
  pxVect               --> X-7
  pxCorr               --> X-5
266E: 10       PUSH  X
266F: 4F       MOV   X,SP
2670: 38 04    ADD   SP,4
(0376) 	LONG lTmp;
(0377) 	lTmp = (LONG)pxVect->wY1-(LONG)pxVect->wY0;
2672: 62 D0 02 MOV   REG[208],2
2675: 52 FA    MOV   A,[X-6]
2677: 01 04    ADD   A,4
2679: 53 B5    MOV   [__r1],A
267B: 52 F9    MOV   A,[X-7]
267D: 09 00    ADC   A,0
267F: 60 D4    MOV   REG[212],A
2681: 3E B5    MVI   A,[__r1]
2683: 53 B6    MOV   [__r0],A
2685: 3E B5    MVI   A,[__r1]
2687: 53 B3    MOV   [__r3],A
2689: 51 B6    MOV   A,[__r0]
268B: 53 B4    MOV   [__r2],A
268D: 55 B5 00 MOV   [__r1],0
2690: 55 B6 00 MOV   [__r0],0
2693: 52 FA    MOV   A,[X-6]
2695: 01 06    ADD   A,6
2697: 53 B1    MOV   [__r5],A
2699: 52 F9    MOV   A,[X-7]
269B: 09 00    ADC   A,0
269D: 60 D4    MOV   REG[212],A
269F: 3E B1    MVI   A,[__r5]
26A1: 53 B2    MOV   [__r4],A
26A3: 3E B1    MVI   A,[__r5]
26A5: 53 AF    MOV   [__r7],A
26A7: 51 B2    MOV   A,[__r4]
26A9: 53 B0    MOV   [__r6],A
26AB: 51 AF    MOV   A,[__r7]
26AD: 12 B3    SUB   A,[__r3]
26AF: 54 03    MOV   [X+3],A
26B1: 51 B0    MOV   A,[__r6]
26B3: 1A B4    SBB   A,[__r2]
26B5: 54 02    MOV   [X+2],A
26B7: 50 00    MOV   A,0
26B9: 1A B5    SBB   A,[__r1]
26BB: 54 01    MOV   [X+1],A
26BD: 50 00    MOV   A,0
26BF: 1A B6    SBB   A,[__r0]
26C1: 54 00    MOV   [X+0],A
(0378) 	lTmp *= (LONG)SLOPE_CORRECT;
26C3: 52 00    MOV   A,[X+0]
26C5: 08       PUSH  A
26C6: 52 01    MOV   A,[X+1]
26C8: 08       PUSH  A
26C9: 52 02    MOV   A,[X+2]
26CB: 08       PUSH  A
26CC: 52 03    MOV   A,[X+3]
26CE: 08       PUSH  A
26CF: 50 00    MOV   A,0
26D1: 08       PUSH  A
26D2: 08       PUSH  A
26D3: 50 27    MOV   A,39
26D5: 08       PUSH  A
26D6: 50 10    MOV   A,16
26D8: 08       PUSH  A
26D9: 7C 57 3B LCALL __mul_32X32_32
26DC: 38 FC    ADD   SP,252
26DE: 18       POP   A
26DF: 54 03    MOV   [X+3],A
26E1: 18       POP   A
26E2: 54 02    MOV   [X+2],A
26E4: 18       POP   A
26E5: 54 01    MOV   [X+1],A
26E7: 18       POP   A
26E8: 54 00    MOV   [X+0],A
(0379) 	pxCorr->iSlope = lTmp/((LONG)pxVect->wX1-(LONG)pxVect->wX0);
26EA: 52 FA    MOV   A,[X-6]
26EC: 53 B5    MOV   [__r1],A
26EE: 52 F9    MOV   A,[X-7]
26F0: 60 D4    MOV   REG[212],A
26F2: 3E B5    MVI   A,[__r1]
26F4: 53 B6    MOV   [__r0],A
26F6: 3E B5    MVI   A,[__r1]
26F8: 53 B3    MOV   [__r3],A
26FA: 51 B6    MOV   A,[__r0]
26FC: 53 B4    MOV   [__r2],A
26FE: 55 B5 00 MOV   [__r1],0
2701: 55 B6 00 MOV   [__r0],0
2704: 52 FA    MOV   A,[X-6]
2706: 01 02    ADD   A,2
2708: 53 B1    MOV   [__r5],A
270A: 52 F9    MOV   A,[X-7]
270C: 09 00    ADC   A,0
270E: 60 D4    MOV   REG[212],A
2710: 3E B1    MVI   A,[__r5]
2712: 53 B2    MOV   [__r4],A
2714: 3E B1    MVI   A,[__r5]
2716: 53 AF    MOV   [__r7],A
2718: 51 B2    MOV   A,[__r4]
271A: 53 B0    MOV   [__r6],A
271C: 51 AF    MOV   A,[__r7]
271E: 12 B3    SUB   A,[__r3]
2720: 53 B3    MOV   [__r3],A
2722: 51 B0    MOV   A,[__r6]
2724: 1A B4    SBB   A,[__r2]
2726: 53 B4    MOV   [__r2],A
2728: 50 00    MOV   A,0
272A: 1A B5    SBB   A,[__r1]
272C: 53 B5    MOV   [__r1],A
272E: 50 00    MOV   A,0
2730: 1A B6    SBB   A,[__r0]
2732: 08       PUSH  A
2733: 51 B5    MOV   A,[__r1]
2735: 08       PUSH  A
2736: 51 B4    MOV   A,[__r2]
2738: 08       PUSH  A
2739: 51 B3    MOV   A,[__r3]
273B: 08       PUSH  A
273C: 52 00    MOV   A,[X+0]
273E: 08       PUSH  A
273F: 52 01    MOV   A,[X+1]
2741: 08       PUSH  A
2742: 52 02    MOV   A,[X+2]
2744: 08       PUSH  A
2745: 52 03    MOV   A,[X+3]
2747: 08       PUSH  A
2748: 7C 55 A4 LCALL __divmod_32X32_32
274B: 18       POP   A
274C: 53 B3    MOV   [__r3],A
274E: 18       POP   A
274F: 53 B4    MOV   [__r2],A
2751: 18       POP   A
2752: 18       POP   A
2753: 38 FC    ADD   SP,252
2755: 51 B3    MOV   A,[__r3]
2757: 53 B5    MOV   [__r1],A
2759: 51 B4    MOV   A,[__r2]
275B: 53 B6    MOV   [__r0],A
275D: 52 FC    MOV   A,[X-4]
275F: 53 B3    MOV   [__r3],A
2761: 52 FB    MOV   A,[X-5]
2763: 60 D5    MOV   REG[213],A
2765: 51 B6    MOV   A,[__r0]
2767: 3F B3    MVI   [__r3],A
2769: 51 B5    MOV   A,[__r1]
276B: 3F B3    MVI   [__r3],A
(0380) 	pxCorr->iOffset = (LONG)pxVect->wY1-((LONG)((LONG)pxCorr->iSlope*pxVect->wX1)/(LONG)SLOPE_CORRECT);
276D: 52 FA    MOV   A,[X-6]
276F: 01 02    ADD   A,2
2771: 53 B5    MOV   [__r1],A
2773: 52 F9    MOV   A,[X-7]
2775: 09 00    ADC   A,0
2777: 60 D4    MOV   REG[212],A
2779: 3E B5    MVI   A,[__r1]
277B: 53 B6    MOV   [__r0],A
277D: 3E B5    MVI   A,[__r1]
277F: 53 B3    MOV   [__r3],A
2781: 51 B6    MOV   A,[__r0]
2783: 53 B4    MOV   [__r2],A
2785: 55 B5 00 MOV   [__r1],0
2788: 55 B6 00 MOV   [__r0],0
278B: 52 FC    MOV   A,[X-4]
278D: 53 B1    MOV   [__r5],A
278F: 52 FB    MOV   A,[X-5]
2791: 60 D4    MOV   REG[212],A
2793: 3E B1    MVI   A,[__r5]
2795: 53 B2    MOV   [__r4],A
2797: 3E B1    MVI   A,[__r5]
2799: 53 AF    MOV   [__r7],A
279B: 51 B2    MOV   A,[__r4]
279D: 53 B0    MOV   [__r6],A
279F: 47 B0 80 TST   [__r6],128
27A2: A0 09    JZ    0x27AC
27A4: 55 B1 FF MOV   [__r5],255
27A7: 55 B2 FF MOV   [__r4],255
27AA: 80 0A    JMP   0x27B5
27AC: 62 D0 02 MOV   REG[208],2
27AF: 55 B1 00 MOV   [__r5],0
27B2: 55 B2 00 MOV   [__r4],0
27B5: 62 D0 02 MOV   REG[208],2
27B8: 51 B6    MOV   A,[__r0]
27BA: 08       PUSH  A
27BB: 51 B5    MOV   A,[__r1]
27BD: 08       PUSH  A
27BE: 51 B4    MOV   A,[__r2]
27C0: 08       PUSH  A
27C1: 51 B3    MOV   A,[__r3]
27C3: 08       PUSH  A
27C4: 51 B2    MOV   A,[__r4]
27C6: 08       PUSH  A
27C7: 51 B1    MOV   A,[__r5]
27C9: 08       PUSH  A
27CA: 51 B0    MOV   A,[__r6]
27CC: 08       PUSH  A
27CD: 51 AF    MOV   A,[__r7]
27CF: 08       PUSH  A
27D0: 7C 57 3B LCALL __mul_32X32_32
27D3: 38 FC    ADD   SP,252
27D5: 18       POP   A
27D6: 53 B3    MOV   [__r3],A
27D8: 18       POP   A
27D9: 53 B4    MOV   [__r2],A
27DB: 18       POP   A
27DC: 53 B5    MOV   [__r1],A
27DE: 18       POP   A
27DF: 53 B6    MOV   [__r0],A
27E1: 50 00    MOV   A,0
27E3: 08       PUSH  A
27E4: 08       PUSH  A
27E5: 50 27    MOV   A,39
27E7: 08       PUSH  A
27E8: 50 10    MOV   A,16
27EA: 08       PUSH  A
27EB: 51 B6    MOV   A,[__r0]
27ED: 08       PUSH  A
27EE: 51 B5    MOV   A,[__r1]
27F0: 08       PUSH  A
27F1: 51 B4    MOV   A,[__r2]
27F3: 08       PUSH  A
27F4: 51 B3    MOV   A,[__r3]
27F6: 08       PUSH  A
27F7: 7C 55 A4 LCALL __divmod_32X32_32
27FA: 18       POP   A
27FB: 53 B3    MOV   [__r3],A
27FD: 18       POP   A
27FE: 53 B4    MOV   [__r2],A
2800: 18       POP   A
2801: 18       POP   A
2802: 38 FC    ADD   SP,252
2804: 52 FA    MOV   A,[X-6]
2806: 01 06    ADD   A,6
2808: 53 B1    MOV   [__r5],A
280A: 52 F9    MOV   A,[X-7]
280C: 09 00    ADC   A,0
280E: 60 D4    MOV   REG[212],A
2810: 3E B1    MVI   A,[__r5]
2812: 53 B2    MOV   [__r4],A
2814: 3E B1    MVI   A,[__r5]
2816: 53 AF    MOV   [__r7],A
2818: 51 B2    MOV   A,[__r4]
281A: 53 B0    MOV   [__r6],A
281C: 51 AF    MOV   A,[__r7]
281E: 12 B3    SUB   A,[__r3]
2820: 53 B3    MOV   [__r3],A
2822: 51 B0    MOV   A,[__r6]
2824: 1A B4    SBB   A,[__r2]
2826: 53 B4    MOV   [__r2],A
2828: 51 B3    MOV   A,[__r3]
282A: 53 B5    MOV   [__r1],A
282C: 51 B4    MOV   A,[__r2]
282E: 53 B6    MOV   [__r0],A
2830: 52 FC    MOV   A,[X-4]
2832: 01 02    ADD   A,2
2834: 53 B3    MOV   [__r3],A
2836: 52 FB    MOV   A,[X-5]
2838: 09 00    ADC   A,0
283A: 60 D5    MOV   REG[213],A
283C: 51 B6    MOV   A,[__r0]
283E: 3F B3    MVI   [__r3],A
2840: 51 B5    MOV   A,[__r1]
2842: 3F B3    MVI   [__r3],A
2844: 38 FC    ADD   SP,252
2846: 20       POP   X
2847: 7F       RET   
(0381) }
(0382) 
(0383) //-----------------------------------------------------------------------------
(0384) //  FUNCTION NAME:	WaitLoadUser()
(0385) //
(0386) //  DESCRIPTION:
(0387) //
(0388) //	Wait for load and user action
(0389) //
(0390) //  ARGUMENTS:
(0391) //  	pszText	Text in display
(0392) //
(0393) //  RETURNS:
(0394) //     FALSE user abort
(0395) //
(0396) //-----------------------------------------------------------------------------
(0397) static BOOL WaitLoadUser (const char *pszText)
(0398) {
_WaitLoadUser:
  pszText              --> X-5
2848: 10       PUSH  X
2849: 4F       MOV   X,SP
(0399) 	LCD_Position(0, 0);
284A: 10       PUSH  X
284B: 50 00    MOV   A,0
284D: 5C       MOV   X,A
284E: 7C 0E 5E LCALL 0x0E5E
2851: 20       POP   X
(0400) 	LCD_PrCString(gConfigCalibStr);
2852: 10       PUSH  X
2853: 50 03    MOV   A,3
2855: 08       PUSH  A
2856: 50 66    MOV   A,102
2858: 5C       MOV   X,A
2859: 18       POP   A
285A: 7C 0C D9 LCALL 0x0CD9
285D: 20       POP   X
(0401) 	LCD_Position(1, 0);
285E: 10       PUSH  X
285F: 57 00    MOV   X,0
2861: 50 01    MOV   A,1
2863: 7C 0E 5E LCALL 0x0E5E
2866: 20       POP   X
(0402) 	LCD_PrCString(pszText);
2867: 10       PUSH  X
2868: 52 FB    MOV   A,[X-5]
286A: 08       PUSH  A
286B: 52 FC    MOV   A,[X-4]
286D: 5C       MOV   X,A
286E: 18       POP   A
286F: 7C 0C D9 LCALL 0x0CD9
2872: 20       POP   X
(0403) 	BUZZ_Beep();
2873: 7C 12 76 LCALL _BUZZ_Beep
(0404) 	if ( KEYPAD_WaitKey(TIME_WAIT_KEY_S) == KBD_UP )
2876: 50 1E    MOV   A,30
2878: 08       PUSH  A
2879: 7C 33 12 LCALL _KEYPAD_WaitKey
287C: 38 FF    ADD   SP,255
287E: 62 D0 02 MOV   REG[208],2
2881: 39 05    CMP   A,5
2883: B0 05    JNZ   0x2889
(0405) 		return FALSE;
2885: 50 00    MOV   A,0
2887: 80 32    JMP   0x28BA
(0406) 	DISP_Clear();
2889: 7C 32 83 LCALL _DISP_Clear
(0407) 	LCD_Position(0, 0);
288C: 10       PUSH  X
288D: 50 00    MOV   A,0
288F: 5C       MOV   X,A
2890: 7C 0E 5E LCALL 0x0E5E
2893: 20       POP   X
(0408) 	LCD_PrCString(gConfigCalibStr);
2894: 10       PUSH  X
2895: 50 03    MOV   A,3
2897: 08       PUSH  A
2898: 50 66    MOV   A,102
289A: 5C       MOV   X,A
289B: 18       POP   A
289C: 7C 0C D9 LCALL 0x0CD9
289F: 20       POP   X
(0409) 	LCD_Position(1, 0);
28A0: 10       PUSH  X
28A1: 57 00    MOV   X,0
28A3: 50 01    MOV   A,1
28A5: 7C 0E 5E LCALL 0x0E5E
28A8: 20       POP   X
(0410) 	LCD_PrCString(gInProgressStr);
28A9: 10       PUSH  X
28AA: 50 04    MOV   A,4
28AC: 08       PUSH  A
28AD: 50 0E    MOV   A,14
28AF: 5C       MOV   X,A
28B0: 18       POP   A
28B1: 7C 0C D9 LCALL 0x0CD9
28B4: 20       POP   X
(0411) 
(0412) 	return TRUE;
28B5: 62 D0 02 MOV   REG[208],2
28B8: 50 01    MOV   A,1
28BA: 20       POP   X
28BB: 7F       RET   

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\dds.c
(0001) //*****************************************************************************/
(0002) //  This file is a part of the "SARK100 SWR Analyzer firmware"
(0003) //
(0004) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
(0005) //  Melchor Varela, Madrid, Spain.
(0006) //  melchor.varela@gmail.com
(0007) //
(0008) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0009) //  and/or modify it under the terms of the GNU General Public License as
(0010) //  published by the Free Software Foundation, either version 3 of the License,
(0011) //  or (at your option) any later version.
(0012) //
(0013) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
(0014) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0015) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
(0016) //  GNU General Public License for more details.
(0017) //
(0018) //  You should have received a copy of the GNU General Public License
(0019) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0020) //  see <http://www.gnu.org/licenses/>.
(0021) //*****************************************************************************/
(0022) //*****************************************************************************/
(0023) //
(0024) //	PROJECT:	SARK100 SWR Analyzer
(0025) // 	FILE NAME: 	DDS.C
(0026) // 	AUTHOR:		EA4FRB - Melchor Varela
(0027) //
(0028) // 	DESCRIPTION
(0029) //
(0030) //	DDS driver
(0031) //
(0032) // 	HISTORY
(0033) //
(0034) //	NAME   	DATE		REMARKS
(0035) //
(0036) //	MVM	   	DEC 2009	Creation
(0037) //
(0038) //*****************************************************************************/
(0039) 
(0040) #include <m8c.h>        				// Part specific constants and macros
(0041) #include "PSoCAPI.h"    				// PSoC API definitions for all User Modules
(0042) #include "psocgpioint.h"
(0043) 
(0044) #include "dds.h"
(0045) 
(0046) //-----------------------------------------------------------------------------
(0047) //  Defines
(0048) //-----------------------------------------------------------------------------
(0049) //#define REF_FREQUENCY	(4294967296/180000000)	//30Mhz ref clock times 6
(0050) #define REF_FREQUENCY_NUM	(42949673)			//30Mhz ref clock times 6
(0051) #define REF_FREQUENCY_DEN	(1800000)			//30Mhz ref clock times 6
(0052) 
(0053) //-----------------------------------------------------------------------------
(0054) //  Prototypes
(0055) //-----------------------------------------------------------------------------
(0056) static DWORD divluh1(DWORD x, DWORD y, DWORD z) ;
(0057) static void muldwu1(DWORD w[], DWORD u, DWORD v);
(0058) 
(0059) //-----------------------------------------------------------------------------
(0060) //  FUNCTION NAME:	DDS_Init
(0061) //
(0062) //  DESCRIPTION:
(0063) //
(0064) //	Initializes DDS driver
(0065) //
(0066) //  ARGUMENTS:
(0067) //     none.
(0068) //
(0069) //  RETURNS:
(0070) //     none.
(0071) //
(0072) //-----------------------------------------------------------------------------
(0073) void DDS_Init(void)
(0074) {
(0075) 	DDS_CLK_Data_ADDR &= ~DDS_CLK_MASK;
_DDS_Init:
28BC: 41 04 BF AND   REG[4],191
(0076) 	DDS_DATA_Data_ADDR &= ~DDS_DATA_MASK;
28BF: 41 04 EF AND   REG[4],239
(0077) 	DDS_LOAD_Data_ADDR &= ~DDS_LOAD_MASK;
28C2: 41 04 FB AND   REG[4],251
(0078) 
(0079) 	DDS_CLK_Data_ADDR |= DDS_CLK_MASK;		// Strobe Clock to get hardware bits D0, D1 and D2 into the input reg
28C5: 43 04 40 OR    REG[4],64
(0080) 	DDS_CLK_Data_ADDR &= ~DDS_CLK_MASK;
28C8: 41 04 BF AND   REG[4],191
(0081) 	DDS_LOAD_Data_ADDR |= DDS_LOAD_MASK;	// and raise Load to get them into the bControl reg
28CB: 43 04 04 OR    REG[4],4
(0082) 	DDS_LOAD_Data_ADDR &= ~DDS_LOAD_MASK;
28CE: 41 04 FB AND   REG[4],251
(0083) 
(0084) 	DDS_Set(0);								// Write 32 zeros to AD9851 with 6x PLL enabled
28D1: 50 00    MOV   A,0
28D3: 08       PUSH  A
28D4: 08       PUSH  A
28D5: 08       PUSH  A
28D6: 08       PUSH  A
28D7: 90 03    CALL  _DDS_Set
28D9: 38 FC    ADD   SP,252
28DB: 7F       RET   
(0085) }
(0086) 
(0087) //-----------------------------------------------------------------------------
(0088) //  FUNCTION NAME:	DDS_Set
(0089) //
(0090) //  DESCRIPTION:
(0091) //
(0092) //	Set DDS frequency
(0093) //
(0094) //  ARGUMENTS:
(0095) //     dwFreq	Frequency in Hz
(0096) //
(0097) //  RETURNS:
(0098) //     none.
(0099) //
(0100) //-----------------------------------------------------------------------------
(0101) void DDS_Set(DWORD dwFreq)
(0102) {
_DDS_Set:
  dwOp                 --> X+2
  bControl             --> X+1
  bBitCnt              --> X+0
  dwFreq               --> X-7
28DC: 10       PUSH  X
28DD: 4F       MOV   X,SP
28DE: 38 0A    ADD   SP,10
(0103) 	BYTE bBitCnt;
(0104) 	BYTE bControl;
(0105) 	DWORD dwOp[2];
(0106) 										// Drop DDS_Load signal to start the programming sequence
(0107) 	DDS_LOAD_Data_ADDR &= ~DDS_LOAD_MASK;
28E0: 41 04 FB AND   REG[4],251
(0108) 
(0109) 										// Transfer frequency bits
(0110) 	if (dwFreq!=0)
28E3: 3D F9 00 CMP   [X-7],0
28E6: B0 10    JNZ   0x28F7
28E8: 3D FA 00 CMP   [X-6],0
28EB: B0 0B    JNZ   0x28F7
28ED: 3D FB 00 CMP   [X-5],0
28F0: B0 06    JNZ   0x28F7
28F2: 3D FC 00 CMP   [X-4],0
28F5: A0 64    JZ    0x295A
(0111) 	{									// Needs extended multiply
(0112) 		muldwu1(dwOp, dwFreq, REF_FREQUENCY_NUM);
28F7: 50 02    MOV   A,2
28F9: 08       PUSH  A
28FA: 50 8F    MOV   A,143
28FC: 08       PUSH  A
28FD: 50 5C    MOV   A,92
28FF: 08       PUSH  A
2900: 50 29    MOV   A,41
2902: 08       PUSH  A
2903: 52 F9    MOV   A,[X-7]
2905: 08       PUSH  A
2906: 52 FA    MOV   A,[X-6]
2908: 08       PUSH  A
2909: 52 FB    MOV   A,[X-5]
290B: 08       PUSH  A
290C: 52 FC    MOV   A,[X-4]
290E: 08       PUSH  A
290F: 62 D0 02 MOV   REG[208],2
2912: 5A B5    MOV   [__r1],X
2914: 06 B5 02 ADD   [__r1],2
2917: 50 07    MOV   A,7
2919: 08       PUSH  A
291A: 51 B5    MOV   A,[__r1]
291C: 08       PUSH  A
291D: 93 27    CALL  _muldwu1
(0113) 		dwFreq = divluh1(dwOp[0], dwOp[1], REF_FREQUENCY_DEN);
291F: 50 00    MOV   A,0
2921: 08       PUSH  A
2922: 50 1B    MOV   A,27
2924: 08       PUSH  A
2925: 50 77    MOV   A,119
2927: 08       PUSH  A
2928: 50 40    MOV   A,64
292A: 08       PUSH  A
292B: 52 06    MOV   A,[X+6]
292D: 08       PUSH  A
292E: 52 07    MOV   A,[X+7]
2930: 08       PUSH  A
2931: 52 08    MOV   A,[X+8]
2933: 08       PUSH  A
2934: 52 09    MOV   A,[X+9]
2936: 08       PUSH  A
2937: 52 02    MOV   A,[X+2]
2939: 08       PUSH  A
293A: 52 03    MOV   A,[X+3]
293C: 08       PUSH  A
293D: 52 04    MOV   A,[X+4]
293F: 08       PUSH  A
2940: 52 05    MOV   A,[X+5]
2942: 08       PUSH  A
2943: 90 95    CALL  _divluh1
2945: 38 EA    ADD   SP,234
2947: 62 D0 02 MOV   REG[208],2
294A: 51 B6    MOV   A,[__r0]
294C: 54 F9    MOV   [X-7],A
294E: 51 B5    MOV   A,[__r1]
2950: 54 FA    MOV   [X-6],A
2952: 51 B4    MOV   A,[__r2]
2954: 54 FB    MOV   [X-5],A
2956: 51 B3    MOV   A,[__r3]
2958: 54 FC    MOV   [X-4],A
(0114) 	}
(0115) 
(0116) 	for (bBitCnt=0; bBitCnt<(sizeof(dwFreq)*8); bBitCnt++, dwFreq>>=1)
295A: 56 00 00 MOV   [X+0],0
295D: 80 47    JMP   0x29A5
(0117) 	{
(0118) 		if ((dwFreq&1)!=0)
295F: 62 D0 02 MOV   REG[208],2
2962: 52 FC    MOV   A,[X-4]
2964: 21 01    AND   A,1
2966: 53 B3    MOV   [__r3],A
2968: 52 FB    MOV   A,[X-5]
296A: 21 00    AND   A,0
296C: 53 B4    MOV   [__r2],A
296E: 52 FA    MOV   A,[X-6]
2970: 21 00    AND   A,0
2972: 53 B5    MOV   [__r1],A
2974: 52 F9    MOV   A,[X-7]
2976: 21 00    AND   A,0
2978: 39 00    CMP   A,0
297A: B0 10    JNZ   0x298B
297C: 3C B5 00 CMP   [__r1],0
297F: B0 0B    JNZ   0x298B
2981: 3C B4 00 CMP   [__r2],0
2984: B0 06    JNZ   0x298B
2986: 3C B3 00 CMP   [__r3],0
2989: A0 06    JZ    0x2990
(0119) 			DDS_DATA_Data_ADDR |= DDS_DATA_MASK;
298B: 43 04 10 OR    REG[4],16
298E: 80 04    JMP   0x2993
(0120) 		else
(0121) 			DDS_DATA_Data_ADDR &= ~DDS_DATA_MASK;
2990: 41 04 EF AND   REG[4],239
(0122) 										// Toggle write clock
(0123) 		DDS_CLK_Data_ADDR |= DDS_CLK_MASK;
2993: 43 04 40 OR    REG[4],64
(0124) 		DDS_CLK_Data_ADDR &= ~DDS_CLK_MASK;
2996: 41 04 BF AND   REG[4],191
2999: 77 00    INC   [X+0]
299B: 70 FB    AND   F,251
299D: 6F F9    RRC   [X-7]
299F: 6F FA    RRC   [X-6]
29A1: 6F FB    RRC   [X-5]
29A3: 6F FC    RRC   [X-4]
29A5: 3D 00 20 CMP   [X+0],32
29A8: CF B6    JC    0x295F
(0125) 	}
(0126) 
(0127) 										// Transfer bControl word
(0128) 	bControl=0x1;						// 6x PLL enabled, no phase shift
29AA: 56 01 01 MOV   [X+1],1
(0129) 	for (bBitCnt=0; bBitCnt<(sizeof(bControl)*8); bBitCnt++, bControl>>=1)
29AD: 56 00 00 MOV   [X+0],0
29B0: 80 1A    JMP   0x29CB
(0130) 	{
(0131) 		if ((bControl&1)!=0)
29B2: 48 01 01 TST   [X+1],1
29B5: A0 06    JZ    0x29BC
(0132) 			DDS_DATA_Data_ADDR |= DDS_DATA_MASK;
29B7: 43 04 10 OR    REG[4],16
29BA: 80 04    JMP   0x29BF
(0133) 		else
(0134) 			DDS_DATA_Data_ADDR &= ~DDS_DATA_MASK;
29BC: 41 04 EF AND   REG[4],239
(0135) 										// Toggle write clock
(0136) 		DDS_CLK_Data_ADDR |= DDS_CLK_MASK;
29BF: 43 04 40 OR    REG[4],64
(0137) 		DDS_CLK_Data_ADDR &= ~DDS_CLK_MASK;
29C2: 41 04 BF AND   REG[4],191
29C5: 77 00    INC   [X+0]
29C7: 70 FB    AND   F,251
29C9: 6F 01    RRC   [X+1]
29CB: 3D 00 08 CMP   [X+0],8
29CE: CF E3    JC    0x29B2
(0138) 	}
(0139) 										// Raise Load signal to load the DDS registers
(0140) 	DDS_LOAD_Data_ADDR |= DDS_LOAD_MASK;
29D0: 43 04 04 OR    REG[4],4
(0141) 	DDS_LOAD_Data_ADDR &= ~DDS_LOAD_MASK;
29D3: 41 04 FB AND   REG[4],251
29D6: 38 F6    ADD   SP,246
29D8: 20       POP   X
29D9: 7F       RET   
(0142) }
(0143) 
(0144) //-----------------------------------------------------------------------------
(0145) //  FUNCTION NAME:	64bit math routines
(0146) //
(0147) //  DESCRIPTION:
(0148) //
(0149) //
(0150) //  ARGUMENTS:
(0151) //     none.
(0152) //
(0153) //  RETURNS:
(0154) //     none.
(0155) //
(0156) //-----------------------------------------------------------------------------
(0157) static DWORD divluh1(DWORD x, DWORD y, DWORD z)
(0158) {
_divluh1:
  i                    --> X+4
  c                    --> X+0
  z                    --> X-15
  y                    --> X-11
  x                    --> X-7
29DA: 10       PUSH  X
29DB: 4F       MOV   X,SP
29DC: 38 08    ADD   SP,8
(0159)    										// Divides (x || y) by z.
(0160)    int i;
(0161)    DWORD c;
(0162) 
(0163)    c = 0;
29DE: 56 00 00 MOV   [X+0],0
29E1: 56 01 00 MOV   [X+1],0
29E4: 56 02 00 MOV   [X+2],0
29E7: 56 03 00 MOV   [X+3],0
(0164)    for (i = 1; i <= 32; i++)
29EA: 56 05 01 MOV   [X+5],1
29ED: 56 04 00 MOV   [X+4],0
(0165)    {
(0166)       if (c == 0)
29F0: 3D 00 00 CMP   [X+0],0
29F3: B1 05    JNZ   0x2AF9
29F5: 3D 01 00 CMP   [X+1],0
29F8: B1 00    JNZ   0x2AF9
29FA: 3D 02 00 CMP   [X+2],0
29FD: B0 FB    JNZ   0x2AF9
29FF: 3D 03 00 CMP   [X+3],0
2A02: B0 F6    JNZ   0x2AF9
(0167)       {
(0168)          c = x >> 31;
2A04: 62 D0 02 MOV   REG[208],2
2A07: 52 F9    MOV   A,[X-7]
2A09: 53 B6    MOV   [__r0],A
2A0B: 52 FA    MOV   A,[X-6]
2A0D: 53 B5    MOV   [__r1],A
2A0F: 52 FB    MOV   A,[X-5]
2A11: 53 B4    MOV   [__r2],A
2A13: 52 FC    MOV   A,[X-4]
2A15: 53 B3    MOV   [__r3],A
2A17: 50 1F    MOV   A,31
2A19: 70 FB    AND   F,251
2A1B: 62 D0 02 MOV   REG[208],2
2A1E: 6E B6    RRC   [__r0]
2A20: 6E B5    RRC   [__r1]
2A22: 6E B4    RRC   [__r2]
2A24: 6E B3    RRC   [__r3]
2A26: 78       DEC   A
2A27: BF F1    JNZ   0x2A19
2A29: 51 B6    MOV   A,[__r0]
2A2B: 54 00    MOV   [X+0],A
2A2D: 51 B5    MOV   A,[__r1]
2A2F: 54 01    MOV   [X+1],A
2A31: 51 B4    MOV   A,[__r2]
2A33: 54 02    MOV   [X+2],A
2A35: 51 B3    MOV   A,[__r3]
2A37: 54 03    MOV   [X+3],A
(0169)          x = (x << 1) | (y >> 31); 		// Shift x || y left
2A39: 52 F5    MOV   A,[X-11]
2A3B: 53 B6    MOV   [__r0],A
2A3D: 52 F6    MOV   A,[X-10]
2A3F: 53 B5    MOV   [__r1],A
2A41: 52 F7    MOV   A,[X-9]
2A43: 53 B4    MOV   [__r2],A
2A45: 52 F8    MOV   A,[X-8]
2A47: 53 B3    MOV   [__r3],A
2A49: 50 1F    MOV   A,31
2A4B: 70 FB    AND   F,251
2A4D: 62 D0 02 MOV   REG[208],2
2A50: 6E B6    RRC   [__r0]
2A52: 6E B5    RRC   [__r1]
2A54: 6E B4    RRC   [__r2]
2A56: 6E B3    RRC   [__r3]
2A58: 78       DEC   A
2A59: BF F1    JNZ   0x2A4B
2A5B: 52 F9    MOV   A,[X-7]
2A5D: 53 B2    MOV   [__r4],A
2A5F: 52 FA    MOV   A,[X-6]
2A61: 53 B1    MOV   [__r5],A
2A63: 52 FB    MOV   A,[X-5]
2A65: 53 B0    MOV   [__r6],A
2A67: 52 FC    MOV   A,[X-4]
2A69: 53 AF    MOV   [__r7],A
2A6B: 65 AF    ASL   [__r7]
2A6D: 6B B0    RLC   [__r6]
2A6F: 6B B1    RLC   [__r5]
2A71: 6B B2    RLC   [__r4]
2A73: 51 AF    MOV   A,[__r7]
2A75: 2A B3    OR    A,[__r3]
2A77: 54 FC    MOV   [X-4],A
2A79: 51 B0    MOV   A,[__r6]
2A7B: 2A B4    OR    A,[__r2]
2A7D: 54 FB    MOV   [X-5],A
2A7F: 51 B1    MOV   A,[__r5]
2A81: 2A B5    OR    A,[__r1]
2A83: 54 FA    MOV   [X-6],A
2A85: 51 B2    MOV   A,[__r4]
2A87: 2A B6    OR    A,[__r0]
2A89: 54 F9    MOV   [X-7],A
(0170)          y = y << 1;               		// one bit.
2A8B: 66 F8    ASL   [X-8]
2A8D: 6C F7    RLC   [X-9]
2A8F: 6C F6    RLC   [X-10]
2A91: 6C F5    RLC   [X-11]
(0171)          c = c ^ (x < z);
2A93: 52 FC    MOV   A,[X-4]
2A95: 13 F4    SUB   A,[X-12]
2A97: 52 FB    MOV   A,[X-5]
2A99: 1B F3    SBB   A,[X-13]
2A9B: 52 FA    MOV   A,[X-6]
2A9D: 1B F2    SBB   A,[X-14]
2A9F: 52 F9    MOV   A,[X-7]
2AA1: 1B F1    SBB   A,[X-15]
2AA3: D0 09    JNC   0x2AAD
2AA5: 56 07 01 MOV   [X+7],1
2AA8: 56 06 00 MOV   [X+6],0
2AAB: 80 07    JMP   0x2AB3
2AAD: 56 07 00 MOV   [X+7],0
2AB0: 56 06 00 MOV   [X+6],0
2AB3: 62 D0 02 MOV   REG[208],2
2AB6: 52 07    MOV   A,[X+7]
2AB8: 53 B3    MOV   [__r3],A
2ABA: 52 06    MOV   A,[X+6]
2ABC: 53 B4    MOV   [__r2],A
2ABE: 47 B4 80 TST   [__r2],128
2AC1: A0 09    JZ    0x2ACB
2AC3: 55 B5 FF MOV   [__r1],255
2AC6: 55 B6 FF MOV   [__r0],255
2AC9: 80 0A    JMP   0x2AD4
2ACB: 62 D0 02 MOV   REG[208],2
2ACE: 55 B5 00 MOV   [__r1],0
2AD1: 55 B6 00 MOV   [__r0],0
2AD4: 62 D0 02 MOV   REG[208],2
2AD7: 51 B3    MOV   A,[__r3]
2AD9: 35 03    XOR   [X+3],A
2ADB: 51 B4    MOV   A,[__r2]
2ADD: 35 02    XOR   [X+2],A
2ADF: 51 B5    MOV   A,[__r1]
2AE1: 35 01    XOR   [X+1],A
2AE3: 51 B6    MOV   A,[__r0]
2AE5: 35 00    XOR   [X+0],A
(0172)          x = x - z;
2AE7: 52 F4    MOV   A,[X-12]
2AE9: 15 FC    SUB   [X-4],A
2AEB: 52 F3    MOV   A,[X-13]
2AED: 1D FB    SBB   [X-5],A
2AEF: 52 F2    MOV   A,[X-14]
2AF1: 1D FA    SBB   [X-6],A
2AF3: 52 F1    MOV   A,[X-15]
2AF5: 1D F9    SBB   [X-7],A
(0173)       }
2AF7: 80 F4    JMP   0x2BEC
(0174)       else
(0175)       {
(0176)          c = x >> 31;
2AF9: 62 D0 02 MOV   REG[208],2
2AFC: 52 F9    MOV   A,[X-7]
2AFE: 53 B6    MOV   [__r0],A
2B00: 52 FA    MOV   A,[X-6]
2B02: 53 B5    MOV   [__r1],A
2B04: 52 FB    MOV   A,[X-5]
2B06: 53 B4    MOV   [__r2],A
2B08: 52 FC    MOV   A,[X-4]
2B0A: 53 B3    MOV   [__r3],A
2B0C: 50 1F    MOV   A,31
2B0E: 70 FB    AND   F,251
2B10: 62 D0 02 MOV   REG[208],2
2B13: 6E B6    RRC   [__r0]
2B15: 6E B5    RRC   [__r1]
2B17: 6E B4    RRC   [__r2]
2B19: 6E B3    RRC   [__r3]
2B1B: 78       DEC   A
2B1C: BF F1    JNZ   0x2B0E
2B1E: 51 B6    MOV   A,[__r0]
2B20: 54 00    MOV   [X+0],A
2B22: 51 B5    MOV   A,[__r1]
2B24: 54 01    MOV   [X+1],A
2B26: 51 B4    MOV   A,[__r2]
2B28: 54 02    MOV   [X+2],A
2B2A: 51 B3    MOV   A,[__r3]
2B2C: 54 03    MOV   [X+3],A
(0177)          x = (x << 1) | (y >> 31); 		// Shift x || y left
2B2E: 52 F5    MOV   A,[X-11]
2B30: 53 B6    MOV   [__r0],A
2B32: 52 F6    MOV   A,[X-10]
2B34: 53 B5    MOV   [__r1],A
2B36: 52 F7    MOV   A,[X-9]
2B38: 53 B4    MOV   [__r2],A
2B3A: 52 F8    MOV   A,[X-8]
2B3C: 53 B3    MOV   [__r3],A
2B3E: 50 1F    MOV   A,31
2B40: 70 FB    AND   F,251
2B42: 62 D0 02 MOV   REG[208],2
2B45: 6E B6    RRC   [__r0]
2B47: 6E B5    RRC   [__r1]
2B49: 6E B4    RRC   [__r2]
2B4B: 6E B3    RRC   [__r3]
2B4D: 78       DEC   A
2B4E: BF F1    JNZ   0x2B40
2B50: 52 F9    MOV   A,[X-7]
2B52: 53 B2    MOV   [__r4],A
2B54: 52 FA    MOV   A,[X-6]
2B56: 53 B1    MOV   [__r5],A
2B58: 52 FB    MOV   A,[X-5]
2B5A: 53 B0    MOV   [__r6],A
2B5C: 52 FC    MOV   A,[X-4]
2B5E: 53 AF    MOV   [__r7],A
2B60: 65 AF    ASL   [__r7]
2B62: 6B B0    RLC   [__r6]
2B64: 6B B1    RLC   [__r5]
2B66: 6B B2    RLC   [__r4]
2B68: 51 AF    MOV   A,[__r7]
2B6A: 2A B3    OR    A,[__r3]
2B6C: 54 FC    MOV   [X-4],A
2B6E: 51 B0    MOV   A,[__r6]
2B70: 2A B4    OR    A,[__r2]
2B72: 54 FB    MOV   [X-5],A
2B74: 51 B1    MOV   A,[__r5]
2B76: 2A B5    OR    A,[__r1]
2B78: 54 FA    MOV   [X-6],A
2B7A: 51 B2    MOV   A,[__r4]
2B7C: 2A B6    OR    A,[__r0]
2B7E: 54 F9    MOV   [X-7],A
(0178)          y = y << 1;               		// one bit.
2B80: 66 F8    ASL   [X-8]
2B82: 6C F7    RLC   [X-9]
2B84: 6C F6    RLC   [X-10]
2B86: 6C F5    RLC   [X-11]
(0179)          x = x + z;
2B88: 52 F4    MOV   A,[X-12]
2B8A: 05 FC    ADD   [X-4],A
2B8C: 52 F3    MOV   A,[X-13]
2B8E: 0D FB    ADC   [X-5],A
2B90: 52 F2    MOV   A,[X-14]
2B92: 0D FA    ADC   [X-6],A
2B94: 52 F1    MOV   A,[X-15]
2B96: 0D F9    ADC   [X-7],A
(0180)          c = c ^ (x < z);
2B98: 52 FC    MOV   A,[X-4]
2B9A: 13 F4    SUB   A,[X-12]
2B9C: 52 FB    MOV   A,[X-5]
2B9E: 1B F3    SBB   A,[X-13]
2BA0: 52 FA    MOV   A,[X-6]
2BA2: 1B F2    SBB   A,[X-14]
2BA4: 52 F9    MOV   A,[X-7]
2BA6: 1B F1    SBB   A,[X-15]
2BA8: D0 09    JNC   0x2BB2
2BAA: 56 07 01 MOV   [X+7],1
2BAD: 56 06 00 MOV   [X+6],0
2BB0: 80 07    JMP   0x2BB8
2BB2: 56 07 00 MOV   [X+7],0
2BB5: 56 06 00 MOV   [X+6],0
2BB8: 62 D0 02 MOV   REG[208],2
2BBB: 52 07    MOV   A,[X+7]
2BBD: 53 B3    MOV   [__r3],A
2BBF: 52 06    MOV   A,[X+6]
2BC1: 53 B4    MOV   [__r2],A
2BC3: 47 B4 80 TST   [__r2],128
2BC6: A0 09    JZ    0x2BD0
2BC8: 55 B5 FF MOV   [__r1],255
2BCB: 55 B6 FF MOV   [__r0],255
2BCE: 80 0A    JMP   0x2BD9
2BD0: 62 D0 02 MOV   REG[208],2
2BD3: 55 B5 00 MOV   [__r1],0
2BD6: 55 B6 00 MOV   [__r0],0
2BD9: 62 D0 02 MOV   REG[208],2
2BDC: 51 B3    MOV   A,[__r3]
2BDE: 35 03    XOR   [X+3],A
2BE0: 51 B4    MOV   A,[__r2]
2BE2: 35 02    XOR   [X+2],A
2BE4: 51 B5    MOV   A,[__r1]
2BE6: 35 01    XOR   [X+1],A
2BE8: 51 B6    MOV   A,[__r0]
2BEA: 35 00    XOR   [X+0],A
(0181)       }
(0182)       y = y + (1 - c);
2BEC: 62 D0 02 MOV   REG[208],2
2BEF: 50 01    MOV   A,1
2BF1: 13 03    SUB   A,[X+3]
2BF3: 53 B3    MOV   [__r3],A
2BF5: 50 00    MOV   A,0
2BF7: 1B 02    SBB   A,[X+2]
2BF9: 53 B4    MOV   [__r2],A
2BFB: 50 00    MOV   A,0
2BFD: 1B 01    SBB   A,[X+1]
2BFF: 53 B5    MOV   [__r1],A
2C01: 50 00    MOV   A,0
2C03: 1B 00    SBB   A,[X+0]
2C05: 53 B6    MOV   [__r0],A
2C07: 51 B3    MOV   A,[__r3]
2C09: 05 F8    ADD   [X-8],A
2C0B: 51 B4    MOV   A,[__r2]
2C0D: 0D F7    ADC   [X-9],A
2C0F: 51 B5    MOV   A,[__r1]
2C11: 0D F6    ADC   [X-10],A
2C13: 51 B6    MOV   A,[__r0]
2C15: 0D F5    ADC   [X-11],A
2C17: 77 05    INC   [X+5]
2C19: 0F 04 00 ADC   [X+4],0
2C1C: 50 20    MOV   A,32
2C1E: 13 05    SUB   A,[X+5]
2C20: 52 04    MOV   A,[X+4]
2C22: 31 80    XOR   A,128
2C24: 62 D0 02 MOV   REG[208],2
2C27: 53 AC    MOV   [__rX],A
2C29: 50 80    MOV   A,128
2C2B: 1A AC    SBB   A,[__rX]
2C2D: DD C2    JNC   0x29F0
(0183)    }
(0184)    return y;                    		// Remainder is x.
2C2F: 62 D0 02 MOV   REG[208],2
2C32: 52 F5    MOV   A,[X-11]
2C34: 53 B6    MOV   [__r0],A
2C36: 52 F6    MOV   A,[X-10]
2C38: 53 B5    MOV   [__r1],A
2C3A: 52 F7    MOV   A,[X-9]
2C3C: 53 B4    MOV   [__r2],A
2C3E: 52 F8    MOV   A,[X-8]
2C40: 53 B3    MOV   [__r3],A
2C42: 38 F8    ADD   SP,248
2C44: 20       POP   X
2C45: 7F       RET   
(0185) }
(0186) 
(0187) static void muldwu1(DWORD w[], DWORD u, DWORD v)
(0188) {
_muldwu1:
  w3                   --> X+32
  w2                   --> X+28
  w1                   --> X+24
  v1                   --> X+20
  v0                   --> X+16
  u1                   --> X+12
  u0                   --> X+8
  k                    --> X+4
  t                    --> X+0
  v                    --> X-13
  u                    --> X-9
  w                    --> X-5
2C46: 10       PUSH  X
2C47: 4F       MOV   X,SP
2C48: 38 24    ADD   SP,36
(0189)    DWORD u0, u1, v0, v1, k, t;
(0190)    DWORD w1, w2, w3;
(0191) 
(0192)    u0 = u >> 16; u1 = u & 0xFFFF;
2C4A: 62 D0 02 MOV   REG[208],2
2C4D: 52 F7    MOV   A,[X-9]
2C4F: 53 B6    MOV   [__r0],A
2C51: 52 F8    MOV   A,[X-8]
2C53: 53 B5    MOV   [__r1],A
2C55: 52 F9    MOV   A,[X-7]
2C57: 53 B4    MOV   [__r2],A
2C59: 52 FA    MOV   A,[X-6]
2C5B: 53 B3    MOV   [__r3],A
2C5D: 50 10    MOV   A,16
2C5F: 70 FB    AND   F,251
2C61: 62 D0 02 MOV   REG[208],2
2C64: 6E B6    RRC   [__r0]
2C66: 6E B5    RRC   [__r1]
2C68: 6E B4    RRC   [__r2]
2C6A: 6E B3    RRC   [__r3]
2C6C: 78       DEC   A
2C6D: BF F1    JNZ   0x2C5F
2C6F: 51 B6    MOV   A,[__r0]
2C71: 54 08    MOV   [X+8],A
2C73: 51 B5    MOV   A,[__r1]
2C75: 54 09    MOV   [X+9],A
2C77: 51 B4    MOV   A,[__r2]
2C79: 54 0A    MOV   [X+10],A
2C7B: 51 B3    MOV   A,[__r3]
2C7D: 54 0B    MOV   [X+11],A
2C7F: 52 FA    MOV   A,[X-6]
2C81: 54 0F    MOV   [X+15],A
2C83: 52 F9    MOV   A,[X-7]
2C85: 54 0E    MOV   [X+14],A
2C87: 56 0D 00 MOV   [X+13],0
2C8A: 56 0C 00 MOV   [X+12],0
(0193)    v0 = v >> 16; v1 = v & 0xFFFF;
2C8D: 52 F3    MOV   A,[X-13]
2C8F: 53 B6    MOV   [__r0],A
2C91: 52 F4    MOV   A,[X-12]
2C93: 53 B5    MOV   [__r1],A
2C95: 52 F5    MOV   A,[X-11]
2C97: 53 B4    MOV   [__r2],A
2C99: 52 F6    MOV   A,[X-10]
2C9B: 53 B3    MOV   [__r3],A
2C9D: 50 10    MOV   A,16
2C9F: 70 FB    AND   F,251
2CA1: 62 D0 02 MOV   REG[208],2
2CA4: 6E B6    RRC   [__r0]
2CA6: 6E B5    RRC   [__r1]
2CA8: 6E B4    RRC   [__r2]
2CAA: 6E B3    RRC   [__r3]
2CAC: 78       DEC   A
2CAD: BF F1    JNZ   0x2C9F
2CAF: 51 B6    MOV   A,[__r0]
2CB1: 54 10    MOV   [X+16],A
2CB3: 51 B5    MOV   A,[__r1]
2CB5: 54 11    MOV   [X+17],A
2CB7: 51 B4    MOV   A,[__r2]
2CB9: 54 12    MOV   [X+18],A
2CBB: 51 B3    MOV   A,[__r3]
2CBD: 54 13    MOV   [X+19],A
2CBF: 52 F6    MOV   A,[X-10]
2CC1: 54 17    MOV   [X+23],A
2CC3: 52 F5    MOV   A,[X-11]
2CC5: 54 16    MOV   [X+22],A
2CC7: 56 15 00 MOV   [X+21],0
2CCA: 56 14 00 MOV   [X+20],0
(0194) 
(0195)    t = u1*v1;
2CCD: 52 14    MOV   A,[X+20]
2CCF: 08       PUSH  A
2CD0: 52 15    MOV   A,[X+21]
2CD2: 08       PUSH  A
2CD3: 52 16    MOV   A,[X+22]
2CD5: 08       PUSH  A
2CD6: 52 17    MOV   A,[X+23]
2CD8: 08       PUSH  A
2CD9: 52 0C    MOV   A,[X+12]
2CDB: 08       PUSH  A
2CDC: 52 0D    MOV   A,[X+13]
2CDE: 08       PUSH  A
2CDF: 52 0E    MOV   A,[X+14]
2CE1: 08       PUSH  A
2CE2: 52 0F    MOV   A,[X+15]
2CE4: 08       PUSH  A
2CE5: 7C 57 3B LCALL __mul_32X32_32
2CE8: 38 FC    ADD   SP,252
2CEA: 18       POP   A
2CEB: 54 03    MOV   [X+3],A
2CED: 18       POP   A
2CEE: 54 02    MOV   [X+2],A
2CF0: 18       POP   A
2CF1: 54 01    MOV   [X+1],A
2CF3: 18       POP   A
2CF4: 54 00    MOV   [X+0],A
(0196)    w3 = t & 0xFFFF;             		// (*)
2CF6: 52 03    MOV   A,[X+3]
2CF8: 54 23    MOV   [X+35],A
2CFA: 52 02    MOV   A,[X+2]
2CFC: 54 22    MOV   [X+34],A
2CFE: 56 21 00 MOV   [X+33],0
2D01: 56 20 00 MOV   [X+32],0
(0197)    k = t >> 16;
2D04: 52 00    MOV   A,[X+0]
2D06: 53 B6    MOV   [__r0],A
2D08: 52 01    MOV   A,[X+1]
2D0A: 53 B5    MOV   [__r1],A
2D0C: 52 02    MOV   A,[X+2]
2D0E: 53 B4    MOV   [__r2],A
2D10: 52 03    MOV   A,[X+3]
2D12: 53 B3    MOV   [__r3],A
2D14: 50 10    MOV   A,16
2D16: 70 FB    AND   F,251
2D18: 62 D0 02 MOV   REG[208],2
2D1B: 6E B6    RRC   [__r0]
2D1D: 6E B5    RRC   [__r1]
2D1F: 6E B4    RRC   [__r2]
2D21: 6E B3    RRC   [__r3]
2D23: 78       DEC   A
2D24: BF F1    JNZ   0x2D16
2D26: 51 B6    MOV   A,[__r0]
2D28: 54 04    MOV   [X+4],A
2D2A: 51 B5    MOV   A,[__r1]
2D2C: 54 05    MOV   [X+5],A
2D2E: 51 B4    MOV   A,[__r2]
2D30: 54 06    MOV   [X+6],A
2D32: 51 B3    MOV   A,[__r3]
2D34: 54 07    MOV   [X+7],A
(0198) 
(0199)    t = u0*v1 + k;
2D36: 52 14    MOV   A,[X+20]
2D38: 08       PUSH  A
2D39: 52 15    MOV   A,[X+21]
2D3B: 08       PUSH  A
2D3C: 52 16    MOV   A,[X+22]
2D3E: 08       PUSH  A
2D3F: 52 17    MOV   A,[X+23]
2D41: 08       PUSH  A
2D42: 52 08    MOV   A,[X+8]
2D44: 08       PUSH  A
2D45: 52 09    MOV   A,[X+9]
2D47: 08       PUSH  A
2D48: 52 0A    MOV   A,[X+10]
2D4A: 08       PUSH  A
2D4B: 52 0B    MOV   A,[X+11]
2D4D: 08       PUSH  A
2D4E: 7C 57 3B LCALL __mul_32X32_32
2D51: 38 FC    ADD   SP,252
2D53: 18       POP   A
2D54: 53 B3    MOV   [__r3],A
2D56: 18       POP   A
2D57: 53 B4    MOV   [__r2],A
2D59: 18       POP   A
2D5A: 53 B5    MOV   [__r1],A
2D5C: 18       POP   A
2D5D: 53 B6    MOV   [__r0],A
2D5F: 51 B3    MOV   A,[__r3]
2D61: 03 07    ADD   A,[X+7]
2D63: 54 03    MOV   [X+3],A
2D65: 51 B4    MOV   A,[__r2]
2D67: 0B 06    ADC   A,[X+6]
2D69: 54 02    MOV   [X+2],A
2D6B: 51 B5    MOV   A,[__r1]
2D6D: 0B 05    ADC   A,[X+5]
2D6F: 54 01    MOV   [X+1],A
2D71: 51 B6    MOV   A,[__r0]
2D73: 0B 04    ADC   A,[X+4]
2D75: 54 00    MOV   [X+0],A
(0200)    w2 = t & 0xFFFF;
2D77: 52 03    MOV   A,[X+3]
2D79: 54 1F    MOV   [X+31],A
2D7B: 52 02    MOV   A,[X+2]
2D7D: 54 1E    MOV   [X+30],A
2D7F: 56 1D 00 MOV   [X+29],0
2D82: 56 1C 00 MOV   [X+28],0
(0201)    w1 = t >> 16;
2D85: 52 00    MOV   A,[X+0]
2D87: 53 B6    MOV   [__r0],A
2D89: 52 01    MOV   A,[X+1]
2D8B: 53 B5    MOV   [__r1],A
2D8D: 52 02    MOV   A,[X+2]
2D8F: 53 B4    MOV   [__r2],A
2D91: 52 03    MOV   A,[X+3]
2D93: 53 B3    MOV   [__r3],A
2D95: 50 10    MOV   A,16
2D97: 70 FB    AND   F,251
2D99: 62 D0 02 MOV   REG[208],2
2D9C: 6E B6    RRC   [__r0]
2D9E: 6E B5    RRC   [__r1]
2DA0: 6E B4    RRC   [__r2]
2DA2: 6E B3    RRC   [__r3]
2DA4: 78       DEC   A
2DA5: BF F1    JNZ   0x2D97
2DA7: 51 B6    MOV   A,[__r0]
2DA9: 54 18    MOV   [X+24],A
2DAB: 51 B5    MOV   A,[__r1]
2DAD: 54 19    MOV   [X+25],A
2DAF: 51 B4    MOV   A,[__r2]
2DB1: 54 1A    MOV   [X+26],A
2DB3: 51 B3    MOV   A,[__r3]
2DB5: 54 1B    MOV   [X+27],A
(0202) 
(0203)    t = u1*v0 + w2;
2DB7: 52 10    MOV   A,[X+16]
2DB9: 08       PUSH  A
2DBA: 52 11    MOV   A,[X+17]
2DBC: 08       PUSH  A
2DBD: 52 12    MOV   A,[X+18]
2DBF: 08       PUSH  A
2DC0: 52 13    MOV   A,[X+19]
2DC2: 08       PUSH  A
2DC3: 52 0C    MOV   A,[X+12]
2DC5: 08       PUSH  A
2DC6: 52 0D    MOV   A,[X+13]
2DC8: 08       PUSH  A
2DC9: 52 0E    MOV   A,[X+14]
2DCB: 08       PUSH  A
2DCC: 52 0F    MOV   A,[X+15]
2DCE: 08       PUSH  A
2DCF: 7C 57 3B LCALL __mul_32X32_32
2DD2: 38 FC    ADD   SP,252
2DD4: 18       POP   A
2DD5: 53 B3    MOV   [__r3],A
2DD7: 18       POP   A
2DD8: 53 B4    MOV   [__r2],A
2DDA: 18       POP   A
2DDB: 53 B5    MOV   [__r1],A
2DDD: 18       POP   A
2DDE: 53 B6    MOV   [__r0],A
2DE0: 51 B3    MOV   A,[__r3]
2DE2: 03 1F    ADD   A,[X+31]
2DE4: 54 03    MOV   [X+3],A
2DE6: 51 B4    MOV   A,[__r2]
2DE8: 0B 1E    ADC   A,[X+30]
2DEA: 54 02    MOV   [X+2],A
2DEC: 51 B5    MOV   A,[__r1]
2DEE: 0B 1D    ADC   A,[X+29]
2DF0: 54 01    MOV   [X+1],A
2DF2: 51 B6    MOV   A,[__r0]
2DF4: 0B 1C    ADC   A,[X+28]
2DF6: 54 00    MOV   [X+0],A
(0204)    k = t >> 16;
2DF8: 52 00    MOV   A,[X+0]
2DFA: 53 B6    MOV   [__r0],A
2DFC: 52 01    MOV   A,[X+1]
2DFE: 53 B5    MOV   [__r1],A
2E00: 52 02    MOV   A,[X+2]
2E02: 53 B4    MOV   [__r2],A
2E04: 52 03    MOV   A,[X+3]
2E06: 53 B3    MOV   [__r3],A
2E08: 50 10    MOV   A,16
2E0A: 70 FB    AND   F,251
2E0C: 62 D0 02 MOV   REG[208],2
2E0F: 6E B6    RRC   [__r0]
2E11: 6E B5    RRC   [__r1]
2E13: 6E B4    RRC   [__r2]
2E15: 6E B3    RRC   [__r3]
2E17: 78       DEC   A
2E18: BF F1    JNZ   0x2E0A
2E1A: 51 B6    MOV   A,[__r0]
2E1C: 54 04    MOV   [X+4],A
2E1E: 51 B5    MOV   A,[__r1]
2E20: 54 05    MOV   [X+5],A
2E22: 51 B4    MOV   A,[__r2]
2E24: 54 06    MOV   [X+6],A
2E26: 51 B3    MOV   A,[__r3]
2E28: 54 07    MOV   [X+7],A
(0205) 
(0206)    w[0] = u0*v0 + w1 + k;
2E2A: 52 10    MOV   A,[X+16]
2E2C: 08       PUSH  A
2E2D: 52 11    MOV   A,[X+17]
2E2F: 08       PUSH  A
2E30: 52 12    MOV   A,[X+18]
2E32: 08       PUSH  A
2E33: 52 13    MOV   A,[X+19]
2E35: 08       PUSH  A
2E36: 52 08    MOV   A,[X+8]
2E38: 08       PUSH  A
2E39: 52 09    MOV   A,[X+9]
2E3B: 08       PUSH  A
2E3C: 52 0A    MOV   A,[X+10]
2E3E: 08       PUSH  A
2E3F: 52 0B    MOV   A,[X+11]
2E41: 08       PUSH  A
2E42: 7C 57 3B LCALL __mul_32X32_32
2E45: 38 FC    ADD   SP,252
2E47: 18       POP   A
2E48: 53 B3    MOV   [__r3],A
2E4A: 18       POP   A
2E4B: 53 B4    MOV   [__r2],A
2E4D: 18       POP   A
2E4E: 53 B5    MOV   [__r1],A
2E50: 18       POP   A
2E51: 53 B6    MOV   [__r0],A
2E53: 52 1B    MOV   A,[X+27]
2E55: 04 B3    ADD   [__r3],A
2E57: 52 1A    MOV   A,[X+26]
2E59: 0C B4    ADC   [__r2],A
2E5B: 52 19    MOV   A,[X+25]
2E5D: 0C B5    ADC   [__r1],A
2E5F: 52 18    MOV   A,[X+24]
2E61: 0C B6    ADC   [__r0],A
2E63: 52 07    MOV   A,[X+7]
2E65: 04 B3    ADD   [__r3],A
2E67: 52 06    MOV   A,[X+6]
2E69: 0C B4    ADC   [__r2],A
2E6B: 52 05    MOV   A,[X+5]
2E6D: 0C B5    ADC   [__r1],A
2E6F: 52 04    MOV   A,[X+4]
2E71: 0C B6    ADC   [__r0],A
2E73: 52 FC    MOV   A,[X-4]
2E75: 53 B1    MOV   [__r5],A
2E77: 52 FB    MOV   A,[X-5]
2E79: 60 D5    MOV   REG[213],A
2E7B: 51 B6    MOV   A,[__r0]
2E7D: 3F B1    MVI   [__r5],A
2E7F: 51 B5    MOV   A,[__r1]
2E81: 3F B1    MVI   [__r5],A
2E83: 51 B4    MOV   A,[__r2]
2E85: 3F B1    MVI   [__r5],A
2E87: 51 B3    MOV   A,[__r3]
2E89: 3F B1    MVI   [__r5],A
(0207)    w[1] = (t << 16) + w3;       		// (*)
2E8B: 52 00    MOV   A,[X+0]
2E8D: 53 B6    MOV   [__r0],A
2E8F: 52 01    MOV   A,[X+1]
2E91: 53 B5    MOV   [__r1],A
2E93: 52 02    MOV   A,[X+2]
2E95: 53 B4    MOV   [__r2],A
2E97: 52 03    MOV   A,[X+3]
2E99: 53 B3    MOV   [__r3],A
2E9B: 50 10    MOV   A,16
2E9D: 62 D0 02 MOV   REG[208],2
2EA0: 65 B3    ASL   [__r3]
2EA2: 6B B4    RLC   [__r2]
2EA4: 6B B5    RLC   [__r1]
2EA6: 6B B6    RLC   [__r0]
2EA8: 78       DEC   A
2EA9: BF F3    JNZ   0x2E9D
2EAB: 52 23    MOV   A,[X+35]
2EAD: 04 B3    ADD   [__r3],A
2EAF: 52 22    MOV   A,[X+34]
2EB1: 0C B4    ADC   [__r2],A
2EB3: 52 21    MOV   A,[X+33]
2EB5: 0C B5    ADC   [__r1],A
2EB7: 52 20    MOV   A,[X+32]
2EB9: 0C B6    ADC   [__r0],A
2EBB: 52 FC    MOV   A,[X-4]
2EBD: 01 04    ADD   A,4
2EBF: 53 B1    MOV   [__r5],A
2EC1: 52 FB    MOV   A,[X-5]
2EC3: 09 00    ADC   A,0
2EC5: 60 D5    MOV   REG[213],A
2EC7: 51 B6    MOV   A,[__r0]
2EC9: 3F B1    MVI   [__r5],A
2ECB: 51 B5    MOV   A,[__r1]
2ECD: 3F B1    MVI   [__r5],A
2ECF: 51 B4    MOV   A,[__r2]
2ED1: 3F B1    MVI   [__r5],A
2ED3: 51 B3    MOV   A,[__r3]
2ED5: 3F B1    MVI   [__r5],A
(0208) /* w[1] = u*v;                  		// Alternative. */
(0209) 
(0210)    return;
2ED7: 38 DC    ADD   SP,220
2ED9: 20       POP   X
2EDA: 7F       RET   

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\display.c
(0001) //*****************************************************************************/
(0002) //  This file is a part of the "SARK100 SWR Analyzer firmware"
(0003) //
(0004) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
(0005) //  Melchor Varela, Madrid, Spain.
(0006) //  melchor.varela@gmail.com
(0007) //
(0008) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0009) //  and/or modify it under the terms of the GNU General Public License as
(0010) //  published by the Free Software Foundation, either version 3 of the License,
(0011) //  or (at your option) any later version.
(0012) //
(0013) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
(0014) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0015) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
(0016) //  GNU General Public License for more details.
(0017) //
(0018) //  You should have received a copy of the GNU General Public License
(0019) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0020) //  see <http://www.gnu.org/licenses/>.
(0021) //*****************************************************************************/
(0022) //*****************************************************************************/
(0023) //
(0024) //	PROJECT:	SARK100 SWR Analyzer
(0025) // 	FILE NAME: 	DISPLAY.C
(0026) // 	AUTHOR:		Melchor Varela
(0027) //
(0028) // 	DESCRIPTION
(0029) //
(0030) //	Display utility functions
(0031) //
(0032) // 	HISTORY
(0033) //
(0034) //	NAME   	DATE		REMARKS
(0035) //
(0036) //	MVM	   	DEC 2009	Creation
(0037) //
(0038) //*****************************************************************************/
(0039) #include <stdlib.h>
(0040) #include <string.h>
(0041) #include "m8c.h"
(0042) #include "Lcd.h"
(0043) #include "Util.h"
(0044) #include "Display.h"
(0045) #include "Msg_generic.h"
(0046) #include "glb_data.h"
(0047) 
(0048) //-----------------------------------------------------------------------------
(0049) //  FUNCTION NAME: DISP_Setup
(0050) //
(0051) //  DESCRIPTION:
(0052) //
(0053) //	Setup display controller and create icons from bitmap data.
(0054) //
(0055) //  ARGUMENTS:
(0056) //	  none.
(0057) //
(0058) //  RETURNS:
(0059) //    none.
(0060) //
(0061) //-----------------------------------------------------------------------------
(0062) void DISP_Setup ( void )
(0063) {
(0064) 	LCD_Start();
_DISP_Setup:
2EDB: 10       PUSH  X
2EDC: 7C 0D EB LCALL 0x0DEB
2EDF: 20       POP   X
(0065) 	LCD_InitBG(LCD_SOLID_BG);
2EE0: 10       PUSH  X
2EE1: 50 00    MOV   A,0
2EE3: 7C 0F 34 LCALL 0x0F34
2EE6: 20       POP   X
2EE7: 7F       RET   
(0066) }
(0067) //-----------------------------------------------------------------------------
(0068) //  FUNCTION NAME: DISP_Frequency
(0069) //
(0070) //  DESCRIPTION:
(0071) //
(0072) //	Display VFO frequency in the current cursor position
(0073) //
(0074) //  ARGUMENTS:
(0075) //    dwFreq 	Frequency in hertz
(0076) //
(0077) //  RETURNS:
(0078) //    none.
(0079) //
(0080) //-----------------------------------------------------------------------------
(0081) void DISP_Frequency ( DWORD dwFreq )
(0082) {
_DISP_Frequency:
  szFreq               --> X+15
  szText               --> X+4
  ii                   --> X+2
  jj                   --> X+0
  dwFreq               --> X-7
2EE8: 10       PUSH  X
2EE9: 4F       MOV   X,SP
2EEA: 38 18    ADD   SP,24
(0083) 	char szFreq[9];
(0084) 	char szText[11];
(0085) 	int ii, jj;
(0086) 
(0087) 	ultoa(szFreq, dwFreq, 10);
2EEC: 50 00    MOV   A,0
2EEE: 08       PUSH  A
2EEF: 50 0A    MOV   A,10
2EF1: 08       PUSH  A
2EF2: 52 F9    MOV   A,[X-7]
2EF4: 08       PUSH  A
2EF5: 52 FA    MOV   A,[X-6]
2EF7: 08       PUSH  A
2EF8: 52 FB    MOV   A,[X-5]
2EFA: 08       PUSH  A
2EFB: 52 FC    MOV   A,[X-4]
2EFD: 08       PUSH  A
2EFE: 62 D0 02 MOV   REG[208],2
2F01: 5A B5    MOV   [__r1],X
2F03: 06 B5 0F ADD   [__r1],15
2F06: 50 07    MOV   A,7
2F08: 08       PUSH  A
2F09: 51 B5    MOV   A,[__r1]
2F0B: 08       PUSH  A
2F0C: 7C 5D F8 LCALL _ultoa
(0088) 	szText[10] = 0;
2F0F: 56 0E 00 MOV   [X+14],0
(0089) 	for (ii=strlen(szFreq)-1, jj=9;ii>=0;ii--,jj--)
2F12: 62 D0 02 MOV   REG[208],2
2F15: 5A B5    MOV   [__r1],X
2F17: 06 B5 0F ADD   [__r1],15
2F1A: 50 07    MOV   A,7
2F1C: 08       PUSH  A
2F1D: 51 B5    MOV   A,[__r1]
2F1F: 08       PUSH  A
2F20: 7C 58 20 LCALL _strlenLMM
2F23: 38 F6    ADD   SP,246
2F25: 62 D0 02 MOV   REG[208],2
2F28: 16 B5 01 SUB   [__r1],1
2F2B: 1E B6 00 SBB   [__r0],0
2F2E: 51 B5    MOV   A,[__r1]
2F30: 54 03    MOV   [X+3],A
2F32: 51 B6    MOV   A,[__r0]
2F34: 54 02    MOV   [X+2],A
2F36: 56 01 09 MOV   [X+1],9
2F39: 56 00 00 MOV   [X+0],0
2F3C: 80 BE    JMP   0x2FFB
(0090) 	{
(0091) 		szText[jj] = szFreq[ii];
2F3E: 62 D0 02 MOV   REG[208],2
2F41: 55 B6 07 MOV   [__r0],7
2F44: 5A B5    MOV   [__r1],X
2F46: 06 B5 0F ADD   [__r1],15
2F49: 52 03    MOV   A,[X+3]
2F4B: 02 B5    ADD   A,[__r1]
2F4D: 53 B5    MOV   [__r1],A
2F4F: 52 02    MOV   A,[X+2]
2F51: 0A B6    ADC   A,[__r0]
2F53: 60 D4    MOV   REG[212],A
2F55: 3E B5    MVI   A,[__r1]
2F57: 53 B6    MOV   [__r0],A
2F59: 55 B4 07 MOV   [__r2],7
2F5C: 5A B3    MOV   [__r3],X
2F5E: 06 B3 04 ADD   [__r3],4
2F61: 52 01    MOV   A,[X+1]
2F63: 02 B3    ADD   A,[__r3]
2F65: 53 B3    MOV   [__r3],A
2F67: 52 00    MOV   A,[X+0]
2F69: 0A B4    ADC   A,[__r2]
2F6B: 60 D5    MOV   REG[213],A
2F6D: 51 B6    MOV   A,[__r0]
2F6F: 3F B3    MVI   [__r3],A
(0092) 		if ((jj==7) && (ii!=0))
2F71: 3D 00 00 CMP   [X+0],0
2F74: B0 3D    JNZ   0x2FB2
2F76: 3D 01 07 CMP   [X+1],7
2F79: B0 38    JNZ   0x2FB2
2F7B: 3D 02 00 CMP   [X+2],0
2F7E: B0 06    JNZ   0x2F85
2F80: 3D 03 00 CMP   [X+3],0
2F83: A0 2E    JZ    0x2FB2
(0093) 			szText[--jj] = '.';
2F85: 62 D0 02 MOV   REG[208],2
2F88: 52 01    MOV   A,[X+1]
2F8A: 11 01    SUB   A,1
2F8C: 53 B5    MOV   [__r1],A
2F8E: 52 00    MOV   A,[X+0]
2F90: 19 00    SBB   A,0
2F92: 53 B6    MOV   [__r0],A
2F94: 51 B5    MOV   A,[__r1]
2F96: 54 01    MOV   [X+1],A
2F98: 51 B6    MOV   A,[__r0]
2F9A: 54 00    MOV   [X+0],A
2F9C: 5A B3    MOV   [__r3],X
2F9E: 06 B3 04 ADD   [__r3],4
2FA1: 51 B3    MOV   A,[__r3]
2FA3: 04 B5    ADD   [__r1],A
2FA5: 0E B6 07 ADC   [__r0],7
2FA8: 51 B6    MOV   A,[__r0]
2FAA: 60 D5    MOV   REG[213],A
2FAC: 50 2E    MOV   A,46
2FAE: 3F B5    MVI   [__r1],A
2FB0: 80 40    JMP   0x2FF1
(0094) 		else if ((jj==3) && (ii!=0))
2FB2: 3D 00 00 CMP   [X+0],0
2FB5: B0 3B    JNZ   0x2FF1
2FB7: 3D 01 03 CMP   [X+1],3
2FBA: B0 36    JNZ   0x2FF1
2FBC: 3D 02 00 CMP   [X+2],0
2FBF: B0 06    JNZ   0x2FC6
2FC1: 3D 03 00 CMP   [X+3],0
2FC4: A0 2C    JZ    0x2FF1
(0095) 			szText[--jj] = ',';
2FC6: 62 D0 02 MOV   REG[208],2
2FC9: 52 01    MOV   A,[X+1]
2FCB: 11 01    SUB   A,1
2FCD: 53 B5    MOV   [__r1],A
2FCF: 52 00    MOV   A,[X+0]
2FD1: 19 00    SBB   A,0
2FD3: 53 B6    MOV   [__r0],A
2FD5: 51 B5    MOV   A,[__r1]
2FD7: 54 01    MOV   [X+1],A
2FD9: 51 B6    MOV   A,[__r0]
2FDB: 54 00    MOV   [X+0],A
2FDD: 5A B3    MOV   [__r3],X
2FDF: 06 B3 04 ADD   [__r3],4
2FE2: 51 B3    MOV   A,[__r3]
2FE4: 04 B5    ADD   [__r1],A
2FE6: 0E B6 07 ADC   [__r0],7
2FE9: 51 B6    MOV   A,[__r0]
2FEB: 60 D5    MOV   REG[213],A
2FED: 50 2C    MOV   A,44
2FEF: 3F B5    MVI   [__r1],A
2FF1: 7B 03    DEC   [X+3]
2FF3: 1F 02 00 SBB   [X+2],0
2FF6: 7B 01    DEC   [X+1]
2FF8: 1F 00 00 SBB   [X+0],0
2FFB: 52 03    MOV   A,[X+3]
2FFD: 11 00    SUB   A,0
2FFF: 52 02    MOV   A,[X+2]
3001: 31 80    XOR   A,128
3003: 19 80    SBB   A,128
3005: DF 38    JNC   0x2F3E
(0096) 	}
(0097) 	for (;jj!=-1; jj--)
3007: 80 21    JMP   0x3029
(0098) 	{
(0099) 		szText[jj] = ' ';
3009: 62 D0 02 MOV   REG[208],2
300C: 55 B6 07 MOV   [__r0],7
300F: 5A B5    MOV   [__r1],X
3011: 06 B5 04 ADD   [__r1],4
3014: 52 01    MOV   A,[X+1]
3016: 02 B5    ADD   A,[__r1]
3018: 53 B5    MOV   [__r1],A
301A: 52 00    MOV   A,[X+0]
301C: 0A B6    ADC   A,[__r0]
301E: 60 D5    MOV   REG[213],A
3020: 50 20    MOV   A,32
3022: 3F B5    MVI   [__r1],A
3024: 7B 01    DEC   [X+1]
3026: 1F 00 00 SBB   [X+0],0
3029: 3D 00 FF CMP   [X+0],255
302C: BF DC    JNZ   0x3009
302E: 3D 01 FF CMP   [X+1],255
3031: BF D7    JNZ   0x3009
(0100) 	}
(0101) 	LCD_PrString(szText);
3033: 62 D0 02 MOV   REG[208],2
3036: 5A B5    MOV   [__r1],X
3038: 06 B5 04 ADD   [__r1],4
303B: 10       PUSH  X
303C: 50 07    MOV   A,7
303E: 08       PUSH  A
303F: 51 B5    MOV   A,[__r1]
3041: 5C       MOV   X,A
3042: 18       POP   A
3043: 7C 0D 15 LCALL 0x0D15
3046: 20       POP   X
3047: 38 E8    ADD   SP,232
3049: 20       POP   X
304A: 7F       RET   
(0102) }
(0103) 
(0104) //-----------------------------------------------------------------------------
(0105) //  FUNCTION NAME: DISP_Swr
(0106) //
(0107) //  DESCRIPTION:
(0108) //
(0109) //	Display SWR value
(0110) //
(0111) //  ARGUMENTS:
(0112) //		wSwr	SWR value
(0113) //
(0114) //  RETURNS:
(0115) //    none.
(0116) //
(0117) //-----------------------------------------------------------------------------
(0118) void DISP_Swr ( WORD wSwr )
(0119) {
_DISP_Swr:
  szSwr                --> X+0
  wSwr                 --> X-5
304B: 10       PUSH  X
304C: 4F       MOV   X,SP
304D: 38 04    ADD   SP,4
(0120) 	char szSwr[4];
(0121) 
(0122) 	if (wSwr>=SWR_MAX)
304F: 52 FC    MOV   A,[X-4]
3051: 11 E7    SUB   A,231
3053: 52 FB    MOV   A,[X-5]
3055: 19 03    SBB   A,3
3057: C0 0F    JC    0x3067
(0123) 	{
(0124) 		LCD_PrCString(">10");
3059: 10       PUSH  X
305A: 50 01    MOV   A,1
305C: 08       PUSH  A
305D: 50 BE    MOV   A,190
305F: 5C       MOV   X,A
3060: 18       POP   A
3061: 7C 0C D9 LCALL 0x0CD9
3064: 20       POP   X
(0125) 		return;
3065: 80 35    JMP   0x309B
(0126) 	}
(0127) 	itoa(szSwr, wSwr, 10);
3067: 50 00    MOV   A,0
3069: 08       PUSH  A
306A: 50 0A    MOV   A,10
306C: 08       PUSH  A
306D: 52 FB    MOV   A,[X-5]
306F: 08       PUSH  A
3070: 52 FC    MOV   A,[X-4]
3072: 08       PUSH  A
3073: 62 D0 02 MOV   REG[208],2
3076: 50 07    MOV   A,7
3078: 08       PUSH  A
3079: 10       PUSH  X
307A: 7C 59 A6 LCALL _itoa
307D: 38 FA    ADD   SP,250
(0128) 	LCD_Write_Data( szSwr[0] );
307F: 10       PUSH  X
3080: 52 00    MOV   A,[X+0]
3082: 7C 0D 27 LCALL 0x0D27
3085: 20       POP   X
(0129) 	LCD_Write_Data( '.' );
3086: 10       PUSH  X
3087: 50 2E    MOV   A,46
3089: 7C 0D 27 LCALL 0x0D27
308C: 20       POP   X
(0130) 	LCD_Write_Data( szSwr[1] );
308D: 10       PUSH  X
308E: 52 01    MOV   A,[X+1]
3090: 7C 0D 27 LCALL 0x0D27
3093: 20       POP   X
(0131) 	LCD_Write_Data( szSwr[2] );
3094: 10       PUSH  X
3095: 52 02    MOV   A,[X+2]
3097: 7C 0D 27 LCALL 0x0D27
309A: 20       POP   X
309B: 38 FC    ADD   SP,252
309D: 20       POP   X
309E: 7F       RET   
(0132) }
(0133) 
(0134) //-----------------------------------------------------------------------------
(0135) //  FUNCTION NAME: DISP_ImpedanceComplez
(0136) //
(0137) //  DESCRIPTION:
(0138) //
(0139) //	Display impedance
(0140) //
(0141) //  ARGUMENTS:
(0142) //		wR			Resistance
(0143) //		wX			Reactance
(0144) //		bSign		Sign of impedance
(0145) //
(0146) //  RETURNS:
(0147) //    none.
(0148) //
(0149) //-----------------------------------------------------------------------------
(0150) void DISP_ImpedanceComplex ( WORD wR, WORD wX, BYTE bSign )
(0151) {
_DISP_ImpedanceComplex:
  szText               --> X+0
  bSign                --> X-8
  wX                   --> X-7
  wR                   --> X-5
309F: 10       PUSH  X
30A0: 4F       MOV   X,SP
30A1: 38 10    ADD   SP,16
(0152) 	char szText[16];
(0153) 
(0154) 	itoa(szText, wR, 10);
30A3: 50 00    MOV   A,0
30A5: 08       PUSH  A
30A6: 50 0A    MOV   A,10
30A8: 08       PUSH  A
30A9: 52 FB    MOV   A,[X-5]
30AB: 08       PUSH  A
30AC: 52 FC    MOV   A,[X-4]
30AE: 08       PUSH  A
30AF: 62 D0 02 MOV   REG[208],2
30B2: 50 07    MOV   A,7
30B4: 08       PUSH  A
30B5: 10       PUSH  X
30B6: 7C 59 A6 LCALL _itoa
30B9: 38 FA    ADD   SP,250
(0155) 	LCD_PrString(szText);
30BB: 62 D0 02 MOV   REG[208],2
30BE: 10       PUSH  X
30BF: 50 07    MOV   A,7
30C1: 08       PUSH  A
30C2: 18       POP   A
30C3: 7C 0D 15 LCALL 0x0D15
30C6: 20       POP   X
(0156) 	LCD_Write_Data( bSign );
30C7: 10       PUSH  X
30C8: 52 F8    MOV   A,[X-8]
30CA: 7C 0D 27 LCALL 0x0D27
30CD: 20       POP   X
(0157) 	LCD_Write_Data( 'j' );
30CE: 10       PUSH  X
30CF: 50 6A    MOV   A,106
30D1: 7C 0D 27 LCALL 0x0D27
30D4: 20       POP   X
(0158) 	itoa(szText, wX, 10);
30D5: 50 00    MOV   A,0
30D7: 08       PUSH  A
30D8: 50 0A    MOV   A,10
30DA: 08       PUSH  A
30DB: 52 F9    MOV   A,[X-7]
30DD: 08       PUSH  A
30DE: 52 FA    MOV   A,[X-6]
30E0: 08       PUSH  A
30E1: 62 D0 02 MOV   REG[208],2
30E4: 50 07    MOV   A,7
30E6: 08       PUSH  A
30E7: 10       PUSH  X
30E8: 7C 59 A6 LCALL _itoa
30EB: 38 FA    ADD   SP,250
(0159) 	LCD_PrString(szText);
30ED: 62 D0 02 MOV   REG[208],2
30F0: 10       PUSH  X
30F1: 50 07    MOV   A,7
30F3: 08       PUSH  A
30F4: 18       POP   A
30F5: 7C 0D 15 LCALL 0x0D15
30F8: 20       POP   X
30F9: 38 F0    ADD   SP,240
30FB: 20       POP   X
30FC: 7F       RET   
(0160) }
(0161) 
(0162) //-----------------------------------------------------------------------------
(0163) //  FUNCTION NAME: DISP_Capacitance
(0164) //
(0165) //  DESCRIPTION:
(0166) //
(0167) //	Display capacitance
(0168) //
(0169) //  ARGUMENTS:
(0170) //		wC		Capacitance in 10xpF
(0171) //
(0172) //  RETURNS:
(0173) //    none.
(0174) //
(0175) //-----------------------------------------------------------------------------
(0176) void DISP_Capacitance ( WORD wC )
(0177) {
_DISP_Capacitance:
  szC                  --> X+0
  wC                   --> X-5
30FD: 10       PUSH  X
30FE: 4F       MOV   X,SP
30FF: 38 10    ADD   SP,16
(0178) 	char szC[16];
(0179) 
(0180) 	LCD_PrCString("C = ");
3101: 10       PUSH  X
3102: 50 01    MOV   A,1
3104: 08       PUSH  A
3105: 50 B9    MOV   A,185
3107: 5C       MOV   X,A
3108: 18       POP   A
3109: 7C 0C D9 LCALL 0x0CD9
310C: 20       POP   X
(0181) 	itoa(szC, wC/10, 10);
310D: 50 00    MOV   A,0
310F: 08       PUSH  A
3110: 50 0A    MOV   A,10
3112: 08       PUSH  A
3113: 62 D0 02 MOV   REG[208],2
3116: 50 00    MOV   A,0
3118: 08       PUSH  A
3119: 50 0A    MOV   A,10
311B: 08       PUSH  A
311C: 52 FB    MOV   A,[X-5]
311E: 08       PUSH  A
311F: 52 FC    MOV   A,[X-4]
3121: 08       PUSH  A
3122: 7C 55 E1 LCALL __divmodu_16X16_16
3125: 18       POP   A
3126: 53 B5    MOV   [__r1],A
3128: 18       POP   A
3129: 38 FE    ADD   SP,254
312B: 08       PUSH  A
312C: 51 B5    MOV   A,[__r1]
312E: 08       PUSH  A
312F: 50 07    MOV   A,7
3131: 08       PUSH  A
3132: 10       PUSH  X
3133: 7C 59 A6 LCALL _itoa
3136: 38 FA    ADD   SP,250
(0182) 	LCD_PrString(szC);
3138: 62 D0 02 MOV   REG[208],2
313B: 10       PUSH  X
313C: 50 07    MOV   A,7
313E: 08       PUSH  A
313F: 18       POP   A
3140: 7C 0D 15 LCALL 0x0D15
3143: 20       POP   X
(0183) 	LCD_Write_Data( '.' );
3144: 10       PUSH  X
3145: 50 2E    MOV   A,46
3147: 7C 0D 27 LCALL 0x0D27
314A: 20       POP   X
(0184) 	itoa(szC, wC%10, 10);
314B: 50 00    MOV   A,0
314D: 08       PUSH  A
314E: 50 0A    MOV   A,10
3150: 08       PUSH  A
3151: 62 D0 02 MOV   REG[208],2
3154: 50 00    MOV   A,0
3156: 08       PUSH  A
3157: 50 0A    MOV   A,10
3159: 08       PUSH  A
315A: 52 FB    MOV   A,[X-5]
315C: 08       PUSH  A
315D: 52 FC    MOV   A,[X-4]
315F: 08       PUSH  A
3160: 7C 55 E1 LCALL __divmodu_16X16_16
3163: 38 FE    ADD   SP,254
3165: 18       POP   A
3166: 53 B5    MOV   [__r1],A
3168: 18       POP   A
3169: 08       PUSH  A
316A: 51 B5    MOV   A,[__r1]
316C: 08       PUSH  A
316D: 50 07    MOV   A,7
316F: 08       PUSH  A
3170: 10       PUSH  X
3171: 7C 59 A6 LCALL _itoa
3174: 38 FA    ADD   SP,250
(0185) 	LCD_PrString(szC);
3176: 62 D0 02 MOV   REG[208],2
3179: 10       PUSH  X
317A: 50 07    MOV   A,7
317C: 08       PUSH  A
317D: 18       POP   A
317E: 7C 0D 15 LCALL 0x0D15
3181: 20       POP   X
(0186) 	LCD_PrCString("pF");
3182: 10       PUSH  X
3183: 50 01    MOV   A,1
3185: 08       PUSH  A
3186: 50 B6    MOV   A,182
3188: 5C       MOV   X,A
3189: 18       POP   A
318A: 7C 0C D9 LCALL 0x0CD9
318D: 20       POP   X
318E: 38 F0    ADD   SP,240
3190: 20       POP   X
3191: 7F       RET   
(0187) }
(0188) 
(0189) //-----------------------------------------------------------------------------
(0190) //  FUNCTION NAME: DISP_Inductance
(0191) //
(0192) //  DESCRIPTION:
(0193) //
(0194) //	Display inductance
(0195) //
(0196) //  ARGUMENTS:
(0197) //		wL		Inductance in 10xuH
(0198) //
(0199) //  RETURNS:
(0200) //    none.
(0201) //
(0202) //-----------------------------------------------------------------------------
(0203) void DISP_Inductance ( WORD wL )
(0204) {
_DISP_Inductance:
  szL                  --> X+0
  wL                   --> X-5
3192: 10       PUSH  X
3193: 4F       MOV   X,SP
3194: 38 10    ADD   SP,16
(0205) 	char szL[16];
(0206) 
(0207) 	LCD_PrCString("L = ");
3196: 10       PUSH  X
3197: 50 01    MOV   A,1
3199: 08       PUSH  A
319A: 50 B1    MOV   A,177
319C: 5C       MOV   X,A
319D: 18       POP   A
319E: 7C 0C D9 LCALL 0x0CD9
31A1: 20       POP   X
(0208) 	itoa(szL, wL/10, 10);
31A2: 50 00    MOV   A,0
31A4: 08       PUSH  A
31A5: 50 0A    MOV   A,10
31A7: 08       PUSH  A
31A8: 62 D0 02 MOV   REG[208],2
31AB: 50 00    MOV   A,0
31AD: 08       PUSH  A
31AE: 50 0A    MOV   A,10
31B0: 08       PUSH  A
31B1: 52 FB    MOV   A,[X-5]
31B3: 08       PUSH  A
31B4: 52 FC    MOV   A,[X-4]
31B6: 08       PUSH  A
31B7: 7C 55 E1 LCALL __divmodu_16X16_16
31BA: 18       POP   A
31BB: 53 B5    MOV   [__r1],A
31BD: 18       POP   A
31BE: 38 FE    ADD   SP,254
31C0: 08       PUSH  A
31C1: 51 B5    MOV   A,[__r1]
31C3: 08       PUSH  A
31C4: 50 07    MOV   A,7
31C6: 08       PUSH  A
31C7: 10       PUSH  X
31C8: 7C 59 A6 LCALL _itoa
31CB: 38 FA    ADD   SP,250
(0209) 	LCD_PrString(szL);
31CD: 62 D0 02 MOV   REG[208],2
31D0: 10       PUSH  X
31D1: 50 07    MOV   A,7
31D3: 08       PUSH  A
31D4: 18       POP   A
31D5: 7C 0D 15 LCALL 0x0D15
31D8: 20       POP   X
(0210) 	LCD_Write_Data( '.' );
31D9: 10       PUSH  X
31DA: 50 2E    MOV   A,46
31DC: 7C 0D 27 LCALL 0x0D27
31DF: 20       POP   X
(0211) 	itoa(szL, wL%10, 10);
31E0: 50 00    MOV   A,0
31E2: 08       PUSH  A
31E3: 50 0A    MOV   A,10
31E5: 08       PUSH  A
31E6: 62 D0 02 MOV   REG[208],2
31E9: 50 00    MOV   A,0
31EB: 08       PUSH  A
31EC: 50 0A    MOV   A,10
31EE: 08       PUSH  A
31EF: 52 FB    MOV   A,[X-5]
31F1: 08       PUSH  A
31F2: 52 FC    MOV   A,[X-4]
31F4: 08       PUSH  A
31F5: 7C 55 E1 LCALL __divmodu_16X16_16
31F8: 38 FE    ADD   SP,254
31FA: 18       POP   A
31FB: 53 B5    MOV   [__r1],A
31FD: 18       POP   A
31FE: 08       PUSH  A
31FF: 51 B5    MOV   A,[__r1]
3201: 08       PUSH  A
3202: 50 07    MOV   A,7
3204: 08       PUSH  A
3205: 10       PUSH  X
3206: 7C 59 A6 LCALL _itoa
3209: 38 FA    ADD   SP,250
(0212) 	LCD_PrString(szL);
320B: 62 D0 02 MOV   REG[208],2
320E: 10       PUSH  X
320F: 50 07    MOV   A,7
3211: 08       PUSH  A
3212: 18       POP   A
3213: 7C 0D 15 LCALL 0x0D15
3216: 20       POP   X
(0213) 	LCD_PrCString("uH");
3217: 10       PUSH  X
3218: 50 01    MOV   A,1
321A: 08       PUSH  A
321B: 50 AE    MOV   A,174
321D: 5C       MOV   X,A
321E: 18       POP   A
321F: 7C 0C D9 LCALL 0x0CD9
3222: 20       POP   X
3223: 38 F0    ADD   SP,240
3225: 20       POP   X
3226: 7F       RET   
(0214) }
(0215) 
(0216) //-----------------------------------------------------------------------------
(0217) //  FUNCTION NAME: DISP_Impedance
(0218) //
(0219) //  DESCRIPTION:
(0220) //
(0221) //	Displays impedance modulus
(0222) //
(0223) //  ARGUMENTS:
(0224) //		wZ		Impedance modulus
(0225) //
(0226) //  RETURNS:
(0227) //    none.
(0228) //
(0229) //-----------------------------------------------------------------------------
(0230) void DISP_Impedance ( WORD wZ )
(0231) {
_DISP_Impedance:
  szZ                  --> X+0
  wZ                   --> X-5
3227: 10       PUSH  X
3228: 4F       MOV   X,SP
3229: 38 10    ADD   SP,16
(0232) 	char szZ[16];
(0233) 
(0234) 
(0235) 	LCD_PrCString("Z = ");
322B: 10       PUSH  X
322C: 50 01    MOV   A,1
322E: 08       PUSH  A
322F: 50 A9    MOV   A,169
3231: 5C       MOV   X,A
3232: 18       POP   A
3233: 7C 0C D9 LCALL 0x0CD9
3236: 20       POP   X
(0236) 	if (wZ>2000)
3237: 50 D0    MOV   A,208
3239: 13 FC    SUB   A,[X-4]
323B: 50 07    MOV   A,7
323D: 1B FB    SBB   A,[X-5]
323F: D0 0F    JNC   0x324F
(0237) 	{
(0238) 		LCD_PrCString(">2000");
3241: 10       PUSH  X
3242: 50 01    MOV   A,1
3244: 08       PUSH  A
3245: 50 A3    MOV   A,163
3247: 5C       MOV   X,A
3248: 18       POP   A
3249: 7C 0C D9 LCALL 0x0CD9
324C: 20       POP   X
(0239) 	}
324D: 80 31    JMP   0x327F
(0240) 	else
(0241) 	{
(0242) 		itoa(szZ, wZ, 10);
324F: 50 00    MOV   A,0
3251: 08       PUSH  A
3252: 50 0A    MOV   A,10
3254: 08       PUSH  A
3255: 52 FB    MOV   A,[X-5]
3257: 08       PUSH  A
3258: 52 FC    MOV   A,[X-4]
325A: 08       PUSH  A
325B: 62 D0 02 MOV   REG[208],2
325E: 50 07    MOV   A,7
3260: 08       PUSH  A
3261: 10       PUSH  X
3262: 7C 59 A6 LCALL _itoa
3265: 38 FA    ADD   SP,250
(0243) 		LCD_PrString(szZ);
3267: 62 D0 02 MOV   REG[208],2
326A: 10       PUSH  X
326B: 50 07    MOV   A,7
326D: 08       PUSH  A
326E: 18       POP   A
326F: 7C 0D 15 LCALL 0x0D15
3272: 20       POP   X
(0244) 		LCD_PrCString(" \xf4");
3273: 10       PUSH  X
3274: 50 01    MOV   A,1
3276: 08       PUSH  A
3277: 50 A0    MOV   A,160
3279: 5C       MOV   X,A
327A: 18       POP   A
327B: 7C 0C D9 LCALL 0x0CD9
327E: 20       POP   X
(0245) 	}
327F: 38 F0    ADD   SP,240
3281: 20       POP   X
3282: 7F       RET   
(0246) }
(0247) 
(0248) //-----------------------------------------------------------------------------
(0249) //  FUNCTION NAME: DISP_Clear
(0250) //
(0251) //  DESCRIPTION:
(0252) //
(0253) //	Clears the screen
(0254) //
(0255) //  ARGUMENTS:
(0256) //
(0257) //
(0258) //  RETURNS:
(0259) //    none.
(0260) //
(0261) //-----------------------------------------------------------------------------
(0262) void DISP_Clear (void)
(0263) {
(0264) 	LCD_Control(LCD_CLEAR);
_DISP_Clear:
3283: 10       PUSH  X
3284: 50 01    MOV   A,1
3286: 7C 0D 3B LCALL 0x0D3B
3289: 20       POP   X
328A: 7F       RET   

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\keypad.c
(0001) //*****************************************************************************/
(0002) //  This file is a part of the "SARK100 SWR Analyzer firmware"
(0003) //
(0004) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
(0005) //  Melchor Varela, Madrid, Spain.
(0006) //  melchor.varela@gmail.com
(0007) //
(0008) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0009) //  and/or modify it under the terms of the GNU General Public License as
(0010) //  published by the Free Software Foundation, either version 3 of the License,
(0011) //  or (at your option) any later version.
(0012) //
(0013) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
(0014) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0015) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
(0016) //  GNU General Public License for more details.
(0017) //
(0018) //  You should have received a copy of the GNU General Public License
(0019) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0020) //  see <http://www.gnu.org/licenses/>.
(0021) //*****************************************************************************/
(0022) //*****************************************************************************/
(0023) //
(0024) //	PROJECT:	PSoC AntennaAnalyzer
(0025) // 	FILE NAME: 	KEYPAD.C
(0026) // 	AUTHOR:		Melchor Varela
(0027) //
(0028) // 	DESCRIPTION
(0029) //
(0030) //	Keypad driver
(0031) //
(0032) // 	HISTORY
(0033) //
(0034) //	NAME   	DATE		REMARKS
(0035) //
(0036) //	MVM	   	6OCT2008	Creation
(0037) //
(0038) //*****************************************************************************/
(0039) 
(0040) #include <m8c.h>        				// Part specific constants and macros
(0041) #include "PSoCAPI.h"    				// PSoC API definitions for all User Modules
(0042) #include "psocgpioint.h"
(0043) 
(0044) #include "keypad.h"
(0045) #include "glb_data.h"
(0046) #include "buzzer.h"
(0047) #include "util.h"
(0048) 
(0049) //-----------------------------------------------------------------------------
(0050) //  Defines
(0051) //-----------------------------------------------------------------------------
(0052) #define KEY_DEBOUNCE_TIME		2		// Units of 1/8 sec
(0053) #define SPEED_KEY_DET_TIME_S	5		// Units of seconds
(0054) 
(0055) //-----------------------------------------------------------------------------
(0056) //  Prototypes
(0057) //-----------------------------------------------------------------------------
(0058) 
(0059) //-----------------------------------------------------------------------------
(0060) //  FUNCTION NAME:	KEYPAD_Get
(0061) //
(0062) //  DESCRIPTION:
(0063) //
(0064) //	Get key pressed value
(0065) //
(0066) //  ARGUMENTS:
(0067) //    none.
(0068) //
(0069) //  RETURNS:
(0070) //    Key pressed. Zero if no key.
(0071) //
(0072) //-----------------------------------------------------------------------------
(0073) BYTE KEYPAD_Get ( void )
(0074) {
_KEYPAD_Get:
  bKey                 --> X+0
328B: 10       PUSH  X
328C: 4F       MOV   X,SP
328D: 38 01    ADD   SP,1
(0075) 	BYTE bKey;
(0076) 	static BYTE bLastKey = 0;
(0077) 
(0078) 	if (g_bDebounceCounter!=0)
328F: 62 D0 02 MOV   REG[208],2
3292: 3C F2 00 CMP   [g_bDebounceCounter],0
3295: A0 08    JZ    0x329E
(0079) 		return 0;
3297: 62 D0 02 MOV   REG[208],2
329A: 50 00    MOV   A,0
329C: 80 71    JMP   0x330E
(0080) 
(0081) 	bKey = KEYPAD_Scan();
329E: 90 B5    CALL  _KEYPAD_Scan
32A0: 62 D0 02 MOV   REG[208],2
32A3: 54 00    MOV   [X+0],A
(0082) 	if (bKey != KEYPAD_Scan())
32A5: 90 AE    CALL  _KEYPAD_Scan
32A7: 62 D0 02 MOV   REG[208],2
32AA: 53 B6    MOV   [__r0],A
32AC: 52 00    MOV   A,[X+0]
32AE: 3A B6    CMP   A,[__r0]
32B0: A0 04    JZ    0x32B5
(0083) 		bKey = 0;
32B2: 56 00 00 MOV   [X+0],0
(0084) 
(0085) 	if (bKey)
32B5: 3D 00 00 CMP   [X+0],0
32B8: A0 4A    JZ    0x3303
(0086) 	{
(0087) 		BUZZ_KeyClick();
32BA: 7C 12 CB LCALL _BUZZ_KeyClick
(0088) 		g_bDebounceCounter = KEY_DEBOUNCE_TIME;
32BD: 62 D0 02 MOV   REG[208],2
32C0: 55 F2 02 MOV   [g_bDebounceCounter],2
(0089) 
(0090) 		if (bKey==bLastKey)
32C3: 62 D0 02 MOV   REG[208],2
32C6: 52 00    MOV   A,[X+0]
32C8: 3A F6    CMP   A,[bLastKey]
32CA: B0 29    JNZ   0x32F4
(0091) 		{
(0092) 			if (g_bSpeedKeyCounter == 0)
32CC: 62 D0 02 MOV   REG[208],2
32CF: 3C F3 00 CMP   [g_bSpeedKeyCounter],0
32D2: B0 36    JNZ   0x3309
(0093) 			{
(0094) 				if (bKey == KBD_UP)
32D4: 3D 00 05 CMP   [X+0],5
32D7: B0 0C    JNZ   0x32E4
(0095) 				{
(0096) 										// Debouncing not needed for faster scan
(0097) 					g_bDebounceCounter = 0;
32D9: 62 D0 02 MOV   REG[208],2
32DC: 55 F2 00 MOV   [g_bDebounceCounter],0
(0098) 					bKey = KBD_2xUP;
32DF: 56 00 07 MOV   [X+0],7
(0099) 				}
32E2: 80 26    JMP   0x3309
(0100) 				else if (bKey == KBD_DWN)
32E4: 3D 00 06 CMP   [X+0],6
32E7: B0 21    JNZ   0x3309
(0101) 				{
(0102) 										// Debouncing not needed for faster scan
(0103) 					g_bDebounceCounter = 0;
32E9: 62 D0 02 MOV   REG[208],2
32EC: 55 F2 00 MOV   [g_bDebounceCounter],0
(0104) 					bKey = KBD_2xDWN;
32EF: 56 00 08 MOV   [X+0],8
(0105) 				}
(0106) 			}
(0107) 		}
32F2: 80 16    JMP   0x3309
(0108) 		else
(0109) 		{
(0110) 			g_bSpeedKeyCounter = SPEED_KEY_DET_TIME_S;
32F4: 62 D0 02 MOV   REG[208],2
32F7: 55 F3 05 MOV   [g_bSpeedKeyCounter],5
(0111) 			bLastKey = bKey;
32FA: 52 00    MOV   A,[X+0]
32FC: 62 D0 02 MOV   REG[208],2
32FF: 53 F6    MOV   [bLastKey],A
(0112) 		}
(0113) 	}
3301: 80 07    JMP   0x3309
(0114) 	else
(0115) 		bLastKey = 0;
3303: 62 D0 02 MOV   REG[208],2
3306: 55 F6 00 MOV   [bLastKey],0
(0116) 	return bKey;
3309: 52 00    MOV   A,[X+0]
330B: 62 D0 02 MOV   REG[208],2
330E: 38 FF    ADD   SP,255
3310: 20       POP   X
3311: 7F       RET   
(0117) }
(0118) 
(0119) //-----------------------------------------------------------------------------
(0120) //  FUNCTION NAME:	KEYPAD_WaitKey
(0121) //
(0122) //  DESCRIPTION:
(0123) //
(0124) //	Waits for key or delay.
(0125) //	Implements power saving features
(0126) //
(0127) //  ARGUMENTS:
(0128) //    bDelayS	Wait timeout in seconds
(0129) //
(0130) //  RETURNS:
(0131) //    Key pressed.
(0132) //
(0133) //-----------------------------------------------------------------------------
(0134) BYTE KEYPAD_WaitKey ( BYTE bDelayS )
(0135) {
_KEYPAD_WaitKey:
  bKey                 --> X+0
  bDelayS              --> X-4
3312: 10       PUSH  X
3313: 4F       MOV   X,SP
3314: 38 01    ADD   SP,1
(0136) 	BYTE bKey;
(0137) 										// Actions to minimize power consumption
(0138) 	OSC_CR0 &= ~0x07; 					// Clear Bits 0 to 2
3316: 71 10    OR    F,16
3318: 41 E0 F8 AND   REG[224],248
(0139) 	OSC_CR0 |= 0x05; 					// Sets CPU clock to 750Khz
331B: 43 E0 05 OR    REG[224],5
(0140) 	g_bIddleCounter = bDelayS;
331E: 52 FC    MOV   A,[X-4]
3320: 70 CF    AND   F,207
3322: 62 D0 02 MOV   REG[208],2
3325: 53 F0    MOV   [g_bIddleCounter],A
(0141) 	do
(0142) 	{
(0143) 		M8C_Sleep;
3327: 43 FF 08 OR    REG[255],8
(0144) 		bKey = KEYPAD_Get();
332A: 9F 5F    CALL  _KEYPAD_Get
332C: 54 00    MOV   [X+0],A
(0145) 		if (bDelayS)
332E: 3D FC 00 CMP   [X-4],0
3331: A0 0B    JZ    0x333D
(0146) 		{
(0147) 			if (g_bIddleCounter==0)
3333: 62 D0 02 MOV   REG[208],2
3336: 3C F0 00 CMP   [g_bIddleCounter],0
3339: B0 03    JNZ   0x333D
(0148) 				break;
333B: 80 06    JMP   0x3342
(0149) 		}
(0150) 	} while (bKey == 0);
333D: 3D 00 00 CMP   [X+0],0
3340: AF E6    JZ    0x3327
(0151) 	OSC_CR0 &= ~0x07; 					// Clear Bits 0 to 2
3342: 71 10    OR    F,16
3344: 41 E0 F8 AND   REG[224],248
(0152) 	OSC_CR0 |= 0x03;  					// Set CPU Clock to SysClk/1
3347: 43 E0 03 OR    REG[224],3
(0153) 
(0154) 	return bKey;
334A: 52 00    MOV   A,[X+0]
334C: 70 CF    AND   F,207
334E: 62 D0 02 MOV   REG[208],2
3351: 38 FF    ADD   SP,255
3353: 20       POP   X
3354: 7F       RET   
(0155) }
(0156) 
(0157) //-----------------------------------------------------------------------------
(0158) //  FUNCTION NAME:	KEYPAD_Scan
(0159) //
(0160) //  DESCRIPTION:
(0161) //
(0162) //	Scans keypad
(0163) //
(0164) //  ARGUMENTS:
(0165) //    none.
(0166) //
(0167) //  RETURNS:
(0168) //    Key pressed. Zero if no key.
(0169) //
(0170) //-----------------------------------------------------------------------------
(0171) BYTE KEYPAD_Scan ( void )
(0172) {
_KEYPAD_Scan:
  bKey                 --> X+0
3355: 10       PUSH  X
3356: 4F       MOV   X,SP
3357: 38 01    ADD   SP,1
(0173) 	BYTE bKey = 0;
3359: 56 00 00 MOV   [X+0],0
(0174) 
(0175) 	COL0_Data_ADDR |= COL0_MASK;
335C: 43 04 80 OR    REG[4],128
(0176) 	COL1_Data_ADDR |= COL1_MASK;
335F: 43 04 20 OR    REG[4],32
(0177) 	COL2_Data_ADDR |= COL2_MASK;
3362: 43 00 40 OR    REG[0],64
(0178) 
(0179) 	COL0_Data_ADDR &= ~COL0_MASK;
3365: 41 04 7F AND   REG[4],127
(0180) 	if ( (ROW0_Data_ADDR & ROW0_MASK) == 0 )
3368: 5D 04    MOV   A,REG[4]
336A: 62 D0 02 MOV   REG[208],2
336D: 53 B6    MOV   [__r0],A
336F: 47 B6 02 TST   [__r0],2
3372: B0 04    JNZ   0x3377
(0181) 	{
(0182) 		bKey = KBD_CONFIG;
3374: 56 00 01 MOV   [X+0],1
(0183) 	}
(0184) 	if ( (ROW1_Data_ADDR & ROW1_MASK) == 0 )
3377: 5D 04    MOV   A,REG[4]
3379: 62 D0 02 MOV   REG[208],2
337C: 53 B6    MOV   [__r0],A
337E: 47 B6 01 TST   [__r0],1
3381: B0 04    JNZ   0x3386
(0185) 	{
(0186) 		bKey = KBD_BAND;
3383: 56 00 03 MOV   [X+0],3
(0187) 	}
(0188) 	COL0_Data_ADDR |= COL0_MASK;
3386: 43 04 80 OR    REG[4],128
(0189) 
(0190) 	COL1_Data_ADDR &= ~COL1_MASK;
3389: 41 04 DF AND   REG[4],223
(0191) 	if ( (ROW0_Data_ADDR & ROW0_MASK) == 0 )
338C: 5D 04    MOV   A,REG[4]
338E: 62 D0 02 MOV   REG[208],2
3391: 53 B6    MOV   [__r0],A
3393: 47 B6 02 TST   [__r0],2
3396: B0 04    JNZ   0x339B
(0192) 	{
(0193) 		bKey = KBD_SCAN;
3398: 56 00 04 MOV   [X+0],4
(0194) 	}
(0195) 	if ( (ROW1_Data_ADDR & ROW1_MASK) == 0 )
339B: 5D 04    MOV   A,REG[4]
339D: 62 D0 02 MOV   REG[208],2
33A0: 53 B6    MOV   [__r0],A
33A2: 47 B6 01 TST   [__r0],1
33A5: B0 04    JNZ   0x33AA
(0196) 	{
(0197) 		bKey = KBD_UP;
33A7: 56 00 05 MOV   [X+0],5
(0198) 	}
(0199) 	COL1_Data_ADDR |= COL1_MASK;
33AA: 43 04 20 OR    REG[4],32
(0200) 
(0201) 	COL2_Data_ADDR &= ~COL2_MASK;
33AD: 41 00 BF AND   REG[0],191
(0202) 	if ( (ROW0_Data_ADDR & ROW0_MASK) == 0 )
33B0: 5D 04    MOV   A,REG[4]
33B2: 62 D0 02 MOV   REG[208],2
33B5: 53 B6    MOV   [__r0],A
33B7: 47 B6 02 TST   [__r0],2
33BA: B0 04    JNZ   0x33BF
(0203) 	{
(0204) 		bKey = KBD_MODE;
33BC: 56 00 02 MOV   [X+0],2
(0205) 	}
(0206) 	if ( (ROW1_Data_ADDR & ROW1_MASK) == 0 )
33BF: 5D 04    MOV   A,REG[4]
33C1: 62 D0 02 MOV   REG[208],2
33C4: 53 B6    MOV   [__r0],A
33C6: 47 B6 01 TST   [__r0],1
33C9: B0 0E    JNZ   0x33D8
(0207) 	{
(0208) 		if (bKey == KBD_UP)
33CB: 3D 00 05 CMP   [X+0],5
33CE: B0 06    JNZ   0x33D5
(0209) 			bKey =  KBD_UP_DWN;
33D0: 56 00 09 MOV   [X+0],9
33D3: 80 04    JMP   0x33D8
(0210) 		else
(0211) 			bKey = KBD_DWN;
33D5: 56 00 06 MOV   [X+0],6
(0212) 	}
(0213) 	COL2_Data_ADDR |= COL2_MASK;
33D8: 43 00 40 OR    REG[0],64
(0214) 
(0215) 	return bKey;
33DB: 52 00    MOV   A,[X+0]
33DD: 62 D0 02 MOV   REG[208],2
33E0: 38 FF    ADD   SP,255
33E2: 20       POP   X
33E3: 7F       RET   
(0216) }
(0217) 
(0218) //-----------------------------------------------------------------------------
(0219) //  FUNCTION NAME:	KEYPAD_SysSuspend
(0220) //
(0221) //  DESCRIPTION:
(0222) //
(0223) //	System suspend. Wakes up from a key press
(0224) //
(0225) //  ARGUMENTS:
(0226) //    none.
(0227) //
(0228) //  RETURNS:
(0229) //    Key pressed. Zero if no key.
(0230) //
(0231) //-----------------------------------------------------------------------------
(0232) void KEYPAD_SysSuspend ( void )
(0233) {
_KEYPAD_SysSuspend:
  bSave_ABF_CR0        --> X+1
  bSave_ARF_CR         --> X+0
33E4: 10       PUSH  X
33E5: 4F       MOV   X,SP
33E6: 38 02    ADD   SP,2
(0234) 	BYTE bSave_ARF_CR;
(0235) 	BYTE bSave_ABF_CR0;
(0236) 
(0237) 	M8C_DisableGInt;
33E8: 70 FE    AND   F,254
(0238) 										// Activates all columns
(0239) 	COL0_Data_ADDR &= ~COL0_MASK;
33EA: 41 04 7F AND   REG[4],127
(0240) 	COL1_Data_ADDR &= ~COL1_MASK;
33ED: 41 04 DF AND   REG[4],223
(0241) 	COL2_Data_ADDR &= ~COL2_MASK;
33F0: 41 00 BF AND   REG[0],191
(0242) 										// Reduces analog power
(0243) 	bSave_ARF_CR = ARF_CR;
33F3: 5D 63    MOV   A,REG[99]
33F5: 54 00    MOV   [X+0],A
(0244) 	bSave_ABF_CR0 = ABF_CR0;
33F7: 71 10    OR    F,16
33F9: 5D 62    MOV   A,REG[98]
33FB: 54 01    MOV   [X+1],A
(0245) 	ARF_CR &= 0xf8; 					// analog blocks Off
33FD: 70 CF    AND   F,207
33FF: 41 63 F8 AND   REG[99],248
(0246) 	ABF_CR0 &= 0xc3;	 				// analog buffer off
3402: 71 10    OR    F,16
3404: 41 62 C3 AND   REG[98],195
(0247) 
(0248) 										// Set low level active interrupt
(0249) 	PRT1IC0	|= 0x3;
3407: 43 06 03 OR    REG[6],3
(0250) 	PRT1IC1	&= ~0x3;
340A: 41 07 FC AND   REG[7],252
(0251) 
(0252) 	PRT1IE	|= 0x3;						// Enables row0&row1 interrupt
340D: 70 CF    AND   F,207
340F: 43 05 03 OR    REG[5],3
(0253) 
(0254) 										// Disables sleep interrupt
(0255) 	M8C_DisableIntMask(INT_MSK0, INT_MSK0_SLEEP);
3412: 41 E0 BF AND   REG[224],191
(0256) 										// Enables GPIO interrupt
(0257) 	M8C_EnableIntMask(INT_MSK0, INT_MSK0_GPIO);
3415: 43 E0 20 OR    REG[224],32
(0258) 
(0259) 										// Clear Pending GPIO Interrupt
(0260) 	INT_CLR0 &= 0x20;
3418: 41 DA 20 AND   REG[218],32
(0261) 
(0262) 	M8C_EnableGInt;
341B: 71 01    OR    F,1
(0263) 
(0264) 	M8C_Sleep;							// Goes sleep
341D: 43 FF 08 OR    REG[255],8
(0265) 
(0266) 	INT_VC = 0;							// Erases vector
3420: 62 E2 00 MOV   REG[226],0
(0267) 
(0268) 	PRT1IE	&= ~(0x3);					// Disables row0&row1 interrupt
3423: 41 05 FC AND   REG[5],252
(0269) 
(0270) 										// Disables GPIO interrupt
(0271) 	M8C_DisableIntMask(INT_MSK0, INT_MSK0_GPIO);
3426: 41 E0 DF AND   REG[224],223
(0272) 										// Restores sleep interrupt
(0273) 	M8C_EnableIntMask(INT_MSK0, INT_MSK0_SLEEP);
3429: 43 E0 40 OR    REG[224],64
(0274) 
(0275) 	ARF_CR = bSave_ARF_CR;
342C: 52 00    MOV   A,[X+0]
342E: 60 63    MOV   REG[99],A
(0276) 	ABF_CR0 = bSave_ABF_CR0;
3430: 52 01    MOV   A,[X+1]
3432: 71 10    OR    F,16
3434: 60 62    MOV   REG[98],A
3436: 70 CF    AND   F,207
3438: 38 FE    ADD   SP,254
343A: 20       POP   X
343B: 7F       RET   

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\main.c
(0001) //*****************************************************************************/
(0002) //  This file is a part of the "SARK100 SWR Analyzer firmware"
(0003) //
(0004) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
(0005) //  Melchor Varela, Madrid, Spain.
(0006) //  melchor.varela@gmail.com
(0007) //
(0008) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0009) //  and/or modify it under the terms of the GNU General Public License as
(0010) //  published by the Free Software Foundation, either version 3 of the License,
(0011) //  or (at your option) any later version.
(0012) //
(0013) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
(0014) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0015) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
(0016) //  GNU General Public License for more details.
(0017) //
(0018) //  You should have received a copy of the GNU General Public License
(0019) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0020) //  see <http://www.gnu.org/licenses/>.
(0021) //*****************************************************************************/
(0022) //*****************************************************************************/
(0023) //
(0024) //	PROJECT:	SARK100 SWR Analyzer
(0025) // 	FILE NAME: 	MAIN.C
(0026) // 	AUTHOR:		EA4FRB - Melchor Varela
(0027) //
(0028) // 	DESCRIPTION
(0029) //
(0030) //	Main program logic
(0031) //
(0032) // 	HISTORY
(0033) //
(0034) //	NAME   	DATE		REMARKS
(0035) //
(0036) //	MVM	   	DEC 2009	Creation
(0037) //
(0038) //*****************************************************************************/
(0039) #include <stdlib.h>
(0040) #include <m8c.h>
(0041) #include "psocgpioint.h"
(0042) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0043) #include "Lcd.h"
(0044) #include "Util.h"
(0045) #include "Display.h"
(0046) #include "glb_data.h"
(0047) #include "msg_generic.h"
(0048) #include "dds.h"
(0049) #include "storage.h"
(0050) #include "keypad.h"
(0051) #include "buzzer.h"
(0052) #include "calcs.h"
(0053) #include "calibrate_reflectometer.h"
(0054) #include "pclink.h"
(0055) 
(0056) //-----------------------------------------------------------------------------
(0057) //  Defines
(0058) //-----------------------------------------------------------------------------
(0059) #define DIZZLING_FREQ		1000000		//1Mhz
(0060) #define TIME_DELAY_TEXT		4			//Temporary screen texts: units of 1 sec
(0061) 
(0062) 										//Text coordinates
(0063) #define COL_MODE			0
(0064) #define ROW_MODE			0
(0065) 
(0066) #define COL_SWR				0
(0067) #define ROW_SWR				1
(0068) 
(0069) #define COL_L				0
(0070) #define ROW_L				1
(0071) 
(0072) #define COL_C				0
(0073) #define ROW_C				1
(0074) 
(0075) #define COL_IMP				5
(0076) #define ROW_IMP				1
(0077) 
(0078) #define COL_FREQ			6
(0079) #define ROW_FREQ			0
(0080) 
(0081) #define SWR_BANDWIDTH		200
(0082) 
(0083) //-----------------------------------------------------------------------------
(0084) //  Prototypes
(0085) //-----------------------------------------------------------------------------
(0086) static DWORD Mode_Scan (BYTE bBand, BYTE bStep);
(0087) static void Mode_Config (void);
(0088) 
(0089) //-----------------------------------------------------------------------------
(0090) //  Private data
(0091) //-----------------------------------------------------------------------------
(0092) #define MAX_INCREMENT		7
(0093) 
(0094) typedef struct
(0095) {
(0096) 	BYTE bCol;
(0097) 	DWORD dwIncrement;
(0098) } INCREMENT_CONTROL;
(0099) 
(0100) INCREMENT_CONTROL const gxIncrementControl[MAX_INCREMENT] =
(0101) {
(0102) 	{COL_FREQ+9, 1},
(0103) 	{COL_FREQ+8, 10},
(0104) 	{COL_FREQ+7, 100},
(0105) 	{COL_FREQ+5, 1000},
(0106) 	{COL_FREQ+4, 10000},
(0107) 	{COL_FREQ+3, 100000},
(0108) 	{COL_FREQ+1, 1000000},
(0109) };
(0110) //-----------------------------------------------------------------------------
(0111) //  FUNCTION NAME:	main
(0112) //
(0113) //  DESCRIPTION:
(0114) //
(0115) //	Main program logic
(0116) //
(0117) //  ARGUMENTS:
(0118) //     none.
(0119) //
(0120) //  RETURNS:
(0121) //     none.
(0122) //
(0123) //-----------------------------------------------------------------------------
(0124) void main()
(0125) {
_main:
  dwNewFreq            --> X+24
  bNewBand             --> X+23
  bSign                --> X+22
  wDizzlingX           --> X+20
  bDizzling            --> X+19
  wDizzlingX           --> X+17
  bSign                --> X+16
  bDizzling            --> X+15
  bUserIddle           --> X+14
  ii                   --> X+13
  dwScanFreq           --> X+9
  bIncCtl              --> X+8
  bFrChMode            --> X+7
  dwCurrentFreq        --> X+3
  bMode                --> X+2
  bBand                --> X+1
  bKey                 --> X+0
343C: 10       PUSH  X
343D: 4F       MOV   X,SP
343E: 38 1E    ADD   SP,30
(0126) 	DWORD dwCurrentFreq;
(0127) 	DWORD dwScanFreq;
(0128) 	BYTE bMode = MODE_SWR;
3440: 56 02 00 MOV   [X+2],0
(0129) 	BYTE bBand = BAND_20M;
3443: 56 01 05 MOV   [X+1],5
(0130) 	BYTE bKey = 0;
3446: 56 00 00 MOV   [X+0],0
(0131) 	BYTE ii;
(0132) 	BYTE bUserIddle;
(0133) 	BYTE bDizzling;
(0134) 	BYTE bSign;
(0135) 	WORD wDizzlingX;
(0136) 	BYTE bFrChMode = FALSE;
3449: 56 07 00 MOV   [X+7],0
(0137) 	BYTE bIncCtl = 4;					// Cursor position index. Default set to 10Khz
344C: 56 08 04 MOV   [X+8],4
(0138) 
(0139) 	g_bScanning = FALSE;
344F: 62 D0 02 MOV   REG[208],2
3452: 55 F4 00 MOV   [g_bScanning],0
(0140) 	M8C_ClearWDTAndSleep;				// Put sleep and watchdog timers into a known state
3455: 62 E3 38 MOV   REG[227],56
(0141) 										// before enabling interrupts.
(0142) 										// Enables sleep timer
(0143) 	M8C_EnableIntMask(INT_MSK0, INT_MSK0_SLEEP);
3458: 43 E0 40 OR    REG[224],64
(0144) 	M8C_EnableGInt;						// Enable global interrupt
345B: 71 01    OR    F,1
(0145) 
(0146) 	DISP_Setup();						// Enables display
345D: 7C 2E DB LCALL _DISP_Setup
(0147) 										// Enables backlight
(0148) 	Port_2_Data_SHADE |= XO_EN_MASK;
3460: 62 D0 00 MOV   REG[208],0
3463: 51 02    MOV   A,[2]
3465: 29 80    OR    A,128
3467: 53 02    MOV   [2],A
(0149) 	XO_EN_Data_ADDR |= XO_EN_MASK;
3469: 43 08 80 OR    REG[8],128
(0150) 
(0151) 	// Display welcome screen
(0152) 	LCD_Position(0, 0);
346C: 10       PUSH  X
346D: 50 00    MOV   A,0
346F: 5C       MOV   X,A
3470: 7C 0E 5E LCALL 0x0E5E
3473: 20       POP   X
(0153) 	LCD_PrCString(gWelcome1Str);
3474: 10       PUSH  X
3475: 50 03    MOV   A,3
3477: 08       PUSH  A
3478: 50 22    MOV   A,34
347A: 5C       MOV   X,A
347B: 18       POP   A
347C: 7C 0C D9 LCALL 0x0CD9
347F: 20       POP   X
(0154) 	LCD_Position(1, 0);
3480: 10       PUSH  X
3481: 57 00    MOV   X,0
3483: 50 01    MOV   A,1
3485: 7C 0E 5E LCALL 0x0E5E
3488: 20       POP   X
(0155) 	LCD_PrCString(gWelcome2Str);
3489: 10       PUSH  X
348A: 50 03    MOV   A,3
348C: 08       PUSH  A
348D: 50 33    MOV   A,51
348F: 5C       MOV   X,A
3490: 18       POP   A
3491: 7C 0C D9 LCALL 0x0CD9
3494: 20       POP   X
(0156) 	KEYPAD_WaitKey(TIME_DELAY_TEXT);
3495: 50 04    MOV   A,4
3497: 08       PUSH  A
3498: 7C 33 12 LCALL _KEYPAD_WaitKey
349B: 38 FF    ADD   SP,255
349D: 62 D0 02 MOV   REG[208],2
(0157) 
(0158) 	STR_Restore();						// Get stored correction factors
34A0: 7C 51 77 LCALL _STR_Restore
(0159) 
(0160) 	if (g_bIsCalibrated == FALSE)		// If not calibrated presents warning text
34A3: 62 D0 02 MOV   REG[208],2
34A6: 3C F5 00 CMP   [g_bIsCalibrated],0
34A9: B0 3E    JNZ   0x34E8
(0161) 	{
(0162) 		BUZZ_BeepError();
34AB: 7C 12 A6 LCALL _BUZZ_BeepError
(0163) 
(0164) 		DISP_Clear();
34AE: 7C 32 83 LCALL _DISP_Clear
(0165) 		LCD_Position(0, 0);
34B1: 10       PUSH  X
34B2: 50 00    MOV   A,0
34B4: 5C       MOV   X,A
34B5: 7C 0E 5E LCALL 0x0E5E
34B8: 20       POP   X
(0166) 		LCD_PrCString(gErrorUncalibratedStr);
34B9: 10       PUSH  X
34BA: 50 04    MOV   A,4
34BC: 08       PUSH  A
34BD: 50 7E    MOV   A,126
34BF: 5C       MOV   X,A
34C0: 18       POP   A
34C1: 7C 0C D9 LCALL 0x0CD9
34C4: 20       POP   X
(0167) 		LCD_Position(1, 0);
34C5: 10       PUSH  X
34C6: 57 00    MOV   X,0
34C8: 50 01    MOV   A,1
34CA: 7C 0E 5E LCALL 0x0E5E
34CD: 20       POP   X
(0168) 		LCD_PrCString(gPressAnyKeyStr);
34CE: 10       PUSH  X
34CF: 50 04    MOV   A,4
34D1: 08       PUSH  A
34D2: 50 8F    MOV   A,143
34D4: 5C       MOV   X,A
34D5: 18       POP   A
34D6: 7C 0C D9 LCALL 0x0CD9
34D9: 20       POP   X
(0169) 										// Wait key press
(0170) 		KEYPAD_WaitKey(TIME_DELAY_TEXT);
34DA: 50 04    MOV   A,4
34DC: 08       PUSH  A
34DD: 7C 33 12 LCALL _KEYPAD_WaitKey
34E0: 38 FF    ADD   SP,255
34E2: 62 D0 02 MOV   REG[208],2
(0171) 		DISP_Clear();
34E5: 7C 32 83 LCALL _DISP_Clear
(0172) 	}
(0173) 
(0174) 	DDS_Init();							// Enables DDS oscillator
34E8: 7C 28 BC LCALL _DDS_Init
(0175) 
(0176) 										// Setup default frequency
(0177) 	dwCurrentFreq = g_xBandLimits[bBand].middle * BAND_FREQ_MULT;
34EB: 62 D0 02 MOV   REG[208],2
34EE: 52 01    MOV   A,[X+1]
34F0: 53 B5    MOV   [__r1],A
34F2: 50 00    MOV   A,0
34F4: 08       PUSH  A
34F5: 51 B5    MOV   A,[__r1]
34F7: 08       PUSH  A
34F8: 50 00    MOV   A,0
34FA: 08       PUSH  A
34FB: 50 06    MOV   A,6
34FD: 08       PUSH  A
34FE: 7C 56 FD LCALL __mul16
3501: 38 FC    ADD   SP,252
3503: 51 AC    MOV   A,[__rX]
3505: 53 B5    MOV   [__r1],A
3507: 51 AB    MOV   A,[__rY]
3509: 53 B6    MOV   [__r0],A
350B: 06 B5 C4 ADD   [__r1],196
350E: 0E B6 01 ADC   [__r0],1
3511: 51 B6    MOV   A,[__r0]
3513: 10       PUSH  X
3514: 08       PUSH  A
3515: 58 B5    MOV   X,[__r1]
3517: 28       ROMX  
3518: 53 B6    MOV   [__r0],A
351A: 18       POP   A
351B: 75       INC   X
351C: 09 00    ADC   A,0
351E: 28       ROMX  
351F: 20       POP   X
3520: 53 B3    MOV   [__r3],A
3522: 51 B6    MOV   A,[__r0]
3524: 53 B4    MOV   [__r2],A
3526: 50 00    MOV   A,0
3528: 08       PUSH  A
3529: 08       PUSH  A
352A: 51 B4    MOV   A,[__r2]
352C: 08       PUSH  A
352D: 51 B3    MOV   A,[__r3]
352F: 08       PUSH  A
3530: 50 00    MOV   A,0
3532: 08       PUSH  A
3533: 50 01    MOV   A,1
3535: 08       PUSH  A
3536: 50 86    MOV   A,134
3538: 08       PUSH  A
3539: 50 A0    MOV   A,160
353B: 08       PUSH  A
353C: 7C 57 3B LCALL __mul_32X32_32
353F: 38 FC    ADD   SP,252
3541: 18       POP   A
3542: 53 B3    MOV   [__r3],A
3544: 18       POP   A
3545: 53 B4    MOV   [__r2],A
3547: 18       POP   A
3548: 53 B5    MOV   [__r1],A
354A: 18       POP   A
354B: 54 03    MOV   [X+3],A
354D: 51 B5    MOV   A,[__r1]
354F: 54 04    MOV   [X+4],A
3551: 51 B4    MOV   A,[__r2]
3553: 54 05    MOV   [X+5],A
3555: 51 B3    MOV   A,[__r3]
3557: 54 06    MOV   [X+6],A
(0178) 
(0179) 										// Get band-specific correction factors based on current freq dial setting
(0180) 	g_xBridgeCorrect = g_xBandCorrFactor[bBand];
3559: 52 01    MOV   A,[X+1]
355B: 53 B5    MOV   [__r1],A
355D: 50 00    MOV   A,0
355F: 08       PUSH  A
3560: 51 B5    MOV   A,[__r1]
3562: 08       PUSH  A
3563: 50 00    MOV   A,0
3565: 08       PUSH  A
3566: 50 0C    MOV   A,12
3568: 08       PUSH  A
3569: 7C 56 FD LCALL __mul16
356C: 38 FC    ADD   SP,252
356E: 51 AC    MOV   A,[__rX]
3570: 53 B5    MOV   [__r1],A
3572: 51 AB    MOV   A,[__rY]
3574: 53 B6    MOV   [__r0],A
3576: 06 B5 0B ADD   [__r1],11
3579: 0E B6 00 ADC   [__r0],0
357C: 55 B3 EB MOV   [__r3],235
357F: 55 B4 00 MOV   [__r2],0
3582: 51 B6    MOV   A,[__r0]
3584: 60 D4    MOV   REG[212],A
3586: 51 B4    MOV   A,[__r2]
3588: 60 D5    MOV   REG[213],A
358A: 10       PUSH  X
358B: 57 0C    MOV   X,12
358D: 62 D0 02 MOV   REG[208],2
3590: 3E B5    MVI   A,[__r1]
3592: 3F B3    MVI   [__r3],A
3594: 79       DEC   X
3595: BF F7    JNZ   0x358D
3597: 20       POP   X
(0181) 
(0182) 										// Set save band frequency to the center of each band
(0183) 	for (ii=0; ii<BAND_MAX; ii++)
3598: 56 0D 00 MOV   [X+13],0
359B: 80 8E    JMP   0x362A
(0184) 	{
(0185) 		g_dwSaveFreqBand[ii] = g_xBandLimits[ii].middle * BAND_FREQ_MULT;
359D: 62 D0 02 MOV   REG[208],2
35A0: 52 0D    MOV   A,[X+13]
35A2: 53 B5    MOV   [__r1],A
35A4: 50 00    MOV   A,0
35A6: 08       PUSH  A
35A7: 51 B5    MOV   A,[__r1]
35A9: 08       PUSH  A
35AA: 50 00    MOV   A,0
35AC: 08       PUSH  A
35AD: 50 06    MOV   A,6
35AF: 08       PUSH  A
35B0: 7C 56 FD LCALL __mul16
35B3: 38 FC    ADD   SP,252
35B5: 51 AC    MOV   A,[__rX]
35B7: 53 B5    MOV   [__r1],A
35B9: 51 AB    MOV   A,[__rY]
35BB: 53 B6    MOV   [__r0],A
35BD: 06 B5 C4 ADD   [__r1],196
35C0: 0E B6 01 ADC   [__r0],1
35C3: 51 B6    MOV   A,[__r0]
35C5: 10       PUSH  X
35C6: 08       PUSH  A
35C7: 58 B5    MOV   X,[__r1]
35C9: 28       ROMX  
35CA: 53 B6    MOV   [__r0],A
35CC: 18       POP   A
35CD: 75       INC   X
35CE: 09 00    ADC   A,0
35D0: 28       ROMX  
35D1: 20       POP   X
35D2: 53 B3    MOV   [__r3],A
35D4: 51 B6    MOV   A,[__r0]
35D6: 53 B4    MOV   [__r2],A
35D8: 50 00    MOV   A,0
35DA: 08       PUSH  A
35DB: 08       PUSH  A
35DC: 51 B4    MOV   A,[__r2]
35DE: 08       PUSH  A
35DF: 51 B3    MOV   A,[__r3]
35E1: 08       PUSH  A
35E2: 50 00    MOV   A,0
35E4: 08       PUSH  A
35E5: 50 01    MOV   A,1
35E7: 08       PUSH  A
35E8: 50 86    MOV   A,134
35EA: 08       PUSH  A
35EB: 50 A0    MOV   A,160
35ED: 08       PUSH  A
35EE: 7C 57 3B LCALL __mul_32X32_32
35F1: 38 FC    ADD   SP,252
35F3: 18       POP   A
35F4: 53 B3    MOV   [__r3],A
35F6: 18       POP   A
35F7: 53 B4    MOV   [__r2],A
35F9: 18       POP   A
35FA: 53 B5    MOV   [__r1],A
35FC: 18       POP   A
35FD: 53 B6    MOV   [__r0],A
35FF: 52 0D    MOV   A,[X+13]
3601: 53 B1    MOV   [__r5],A
3603: 55 B2 00 MOV   [__r4],0
3606: 65 B1    ASL   [__r5]
3608: 6B B2    RLC   [__r4]
360A: 65 B1    ASL   [__r5]
360C: 6B B2    RLC   [__r4]
360E: 06 B1 B3 ADD   [__r5],179
3611: 0E B2 00 ADC   [__r4],0
3614: 51 B2    MOV   A,[__r4]
3616: 60 D5    MOV   REG[213],A
3618: 51 B6    MOV   A,[__r0]
361A: 3F B1    MVI   [__r5],A
361C: 51 B5    MOV   A,[__r1]
361E: 3F B1    MVI   [__r5],A
3620: 51 B4    MOV   A,[__r2]
3622: 3F B1    MVI   [__r5],A
3624: 51 B3    MOV   A,[__r3]
3626: 3F B1    MVI   [__r5],A
3628: 77 0D    INC   [X+13]
362A: 3D 0D 0E CMP   [X+13],14
362D: CF 6F    JC    0x359D
(0186) 	}
(0187) 
(0188) 										// Sets DDS gain
(0189) 	PGA_DDS_1_Start(PGA_DDS_1_HIGHPOWER);
362F: 10       PUSH  X
3630: 50 03    MOV   A,3
3632: 7C 0C 59 LCALL 0x0C59
3635: 20       POP   X
(0190) 	PGA_DDS_2_Start(PGA_DDS_2_HIGHPOWER);
3636: 10       PUSH  X
3637: 50 03    MOV   A,3
3639: 7C 0C 19 LCALL 0x0C19
363C: 20       POP   X
(0191) 	Adjust_Dds_Gain(bBand);
363D: 52 01    MOV   A,[X+1]
363F: 08       PUSH  A
3640: 7C 25 35 LCALL _Adjust_Dds_Gain
3643: 38 FF    ADD   SP,255
(0192) 
(0193) 	ADCINC12_Start(ADCINC12_HIGHPOWER); // Turn on Analog section
3645: 10       PUSH  X
3646: 50 03    MOV   A,3
3648: 7C 10 15 LCALL 0x1015
364B: 20       POP   X
(0194) 	PGA_ADC_Start(PGA_ADC_HIGHPOWER);
364C: 10       PUSH  X
364D: 50 03    MOV   A,3
364F: 7C 0C 99 LCALL 0x0C99
3652: 20       POP   X
(0195) 	PGA_ADC_SetGain(PGA_ADC_G2_67);
3653: 10       PUSH  X
3654: 50 58    MOV   A,88
3656: 7C 0C AB LCALL 0x0CAB
3659: 20       POP   X
(0196) 										// Check Vf level
(0197) 	DDS_Set(dwCurrentFreq);
365A: 52 03    MOV   A,[X+3]
365C: 08       PUSH  A
365D: 52 04    MOV   A,[X+4]
365F: 08       PUSH  A
3660: 52 05    MOV   A,[X+5]
3662: 08       PUSH  A
3663: 52 06    MOV   A,[X+6]
3665: 08       PUSH  A
3666: 7C 28 DC LCALL _DDS_Set
(0198) 	Delay_Ms(100);
3669: 50 00    MOV   A,0
366B: 08       PUSH  A
366C: 50 64    MOV   A,100
366E: 08       PUSH  A
366F: 7C 53 01 LCALL _Delay_Ms
3672: 38 FA    ADD   SP,250
(0199) 	Do_Measure();
3674: 7C 47 0E LCALL _Do_Measure
(0200) 
(0201) 	if (g_xBridgeMeasure.Vf<500)		// Vf too low, warn user
3677: 62 D0 02 MOV   REG[208],2
367A: 51 8F    MOV   A,[g_xBridgeMeasure+3]
367C: 11 F4    SUB   A,244
367E: 51 8E    MOV   A,[g_xBridgeMeasure+2]
3680: 19 01    SBB   A,1
3682: 51 8D    MOV   A,[g_xBridgeMeasure+1]
3684: 19 00    SBB   A,0
3686: 51 8C    MOV   A,[g_xBridgeMeasure]
3688: 19 00    SBB   A,0
368A: D0 3B    JNC   0x36C6
(0202) 	{
(0203) 		BUZZ_BeepError();
368C: 7C 12 A6 LCALL _BUZZ_BeepError
(0204) 
(0205) 		LCD_Position(0, 0);
368F: 10       PUSH  X
3690: 50 00    MOV   A,0
3692: 5C       MOV   X,A
3693: 7C 0E 5E LCALL 0x0E5E
3696: 20       POP   X
(0206) 		LCD_PrCString(gErrorAdjustVfStr);
3697: 10       PUSH  X
3698: 50 03    MOV   A,3
369A: 08       PUSH  A
369B: 50 FD    MOV   A,253
369D: 5C       MOV   X,A
369E: 18       POP   A
369F: 7C 0C D9 LCALL 0x0CD9
36A2: 20       POP   X
(0207) 		LCD_Position(1, 0);
36A3: 10       PUSH  X
36A4: 57 00    MOV   X,0
36A6: 50 01    MOV   A,1
36A8: 7C 0E 5E LCALL 0x0E5E
36AB: 20       POP   X
(0208) 		LCD_PrCString(gPressAnyKeyStr);
36AC: 10       PUSH  X
36AD: 50 04    MOV   A,4
36AF: 08       PUSH  A
36B0: 50 8F    MOV   A,143
36B2: 5C       MOV   X,A
36B3: 18       POP   A
36B4: 7C 0C D9 LCALL 0x0CD9
36B7: 20       POP   X
(0209) 										// Wait key press
(0210) 		KEYPAD_WaitKey(TIME_WAIT_KEY_S);
36B8: 50 1E    MOV   A,30
36BA: 08       PUSH  A
36BB: 7C 33 12 LCALL _KEYPAD_WaitKey
36BE: 38 FF    ADD   SP,255
36C0: 62 D0 02 MOV   REG[208],2
(0211) 		DISP_Clear();
36C3: 7C 32 83 LCALL _DISP_Clear
(0212) 	}
(0213) 
(0214) 										// Resets iddle counter
(0215) 	g_bIddleCounter = GetUserIddle(g_xConf.bUserIddle);
36C6: 62 D0 02 MOV   REG[208],2
36C9: 51 EE    MOV   A,[g_xConf+1]
36CB: 08       PUSH  A
36CC: 7C 54 2F LCALL _GetUserIddle
36CF: 38 FF    ADD   SP,255
36D1: 62 D0 02 MOV   REG[208],2
36D4: 53 F0    MOV   [g_bIddleCounter],A
(0216) 	do
(0217) 	{
(0218) 										// Initializes dizzling variables
(0219) 		BYTE bDizzling = FALSE;
36D6: 56 13 00 MOV   [X+19],0
(0220) 		BYTE bSign = ' ';
36D9: 56 16 20 MOV   [X+22],32
(0221) 		WORD wDizzlingX = 0;
36DC: 56 15 00 MOV   [X+21],0
36DF: 56 14 00 MOV   [X+20],0
(0222) 
(0223) 										// Display mode and frequency
(0224) 		LCD_Control(LCD_ON);
36E2: 10       PUSH  X
36E3: 50 0C    MOV   A,12
36E5: 7C 0D 3B LCALL 0x0D3B
36E8: 20       POP   X
(0225) 		DISP_Clear();
36E9: 7C 32 83 LCALL _DISP_Clear
(0226) 		LCD_Position(ROW_MODE, COL_MODE);
36EC: 10       PUSH  X
36ED: 50 00    MOV   A,0
36EF: 5C       MOV   X,A
36F0: 7C 0E 5E LCALL 0x0E5E
36F3: 20       POP   X
(0227) 		LCD_PrCString(gModeStr[bMode]);
36F4: 62 D0 02 MOV   REG[208],2
36F7: 52 02    MOV   A,[X+2]
36F9: 53 B5    MOV   [__r1],A
36FB: 55 B6 00 MOV   [__r0],0
36FE: 65 B5    ASL   [__r1]
3700: 6B B6    RLC   [__r0]
3702: 06 B5 C1 ADD   [__r1],193
3705: 0E B6 02 ADC   [__r0],2
3708: 51 B6    MOV   A,[__r0]
370A: 60 D4    MOV   REG[212],A
370C: 3E B5    MVI   A,[__r1]
370E: 53 B6    MOV   [__r0],A
3710: 3E B5    MVI   A,[__r1]
3712: 53 B5    MOV   [__r1],A
3714: 10       PUSH  X
3715: 51 B6    MOV   A,[__r0]
3717: 08       PUSH  A
3718: 51 B5    MOV   A,[__r1]
371A: 5C       MOV   X,A
371B: 18       POP   A
371C: 7C 0C D9 LCALL 0x0CD9
371F: 20       POP   X
(0228) 		if (bMode != MODE_OFF)
3720: 3D 02 04 CMP   [X+2],4
3723: A0 1B    JZ    0x373F
(0229) 		{
(0230) 			LCD_Position(ROW_FREQ, COL_FREQ);
3725: 10       PUSH  X
3726: 57 06    MOV   X,6
3728: 50 00    MOV   A,0
372A: 7C 0E 5E LCALL 0x0E5E
372D: 20       POP   X
(0231) 			DISP_Frequency(dwCurrentFreq);
372E: 52 03    MOV   A,[X+3]
3730: 08       PUSH  A
3731: 52 04    MOV   A,[X+4]
3733: 08       PUSH  A
3734: 52 05    MOV   A,[X+5]
3736: 08       PUSH  A
3737: 52 06    MOV   A,[X+6]
3739: 08       PUSH  A
373A: 7C 2E E8 LCALL _DISP_Frequency
373D: 38 FC    ADD   SP,252
(0232) 		}
(0233) 		do
(0234) 		{
(0235) 										// If frequency is scrolled fast it does not measure
(0236) 			if ((bMode != MODE_OFF)&&!((bKey==KBD_2xUP)||(bKey==KBD_2xDWN)))
373F: 3D 02 04 CMP   [X+2],4
3742: A2 C2    JZ    0x3A05
3744: 3D 00 07 CMP   [X+0],7
3747: A2 BD    JZ    0x3A05
3749: 3D 00 08 CMP   [X+0],8
374C: A2 B8    JZ    0x3A05
(0237) 			{
(0238) 				Do_Measure();
374E: 7C 47 0E LCALL _Do_Measure
(0239) 				Do_Correct();
3751: 7C 23 F1 LCALL _Do_Correct
(0240) 										// Do the basic calcs
(0241) 				gwSwr = Calculate_Swr(g_xBridgeMeasure.Vf, g_xBridgeMeasure.Vr);
3754: 62 D0 02 MOV   REG[208],2
3757: 51 90    MOV   A,[144]
3759: 08       PUSH  A
375A: 51 91    MOV   A,[145]
375C: 08       PUSH  A
375D: 51 92    MOV   A,[146]
375F: 08       PUSH  A
3760: 51 93    MOV   A,[147]
3762: 08       PUSH  A
3763: 51 8C    MOV   A,[g_xBridgeMeasure]
3765: 08       PUSH  A
3766: 51 8D    MOV   A,[g_xBridgeMeasure+1]
3768: 08       PUSH  A
3769: 51 8E    MOV   A,[g_xBridgeMeasure+2]
376B: 08       PUSH  A
376C: 51 8F    MOV   A,[g_xBridgeMeasure+3]
376E: 08       PUSH  A
376F: 7C 12 F0 LCALL _Calculate_Swr
3772: 38 F8    ADD   SP,248
3774: 62 D0 02 MOV   REG[208],2
3777: 51 B5    MOV   A,[__r1]
3779: 08       PUSH  A
377A: 51 B6    MOV   A,[__r0]
377C: 62 D0 02 MOV   REG[208],2
377F: 53 EB    MOV   [gwSwr],A
3781: 18       POP   A
3782: 53 EC    MOV   [gwSwr+1],A
(0242) 				gwZ = Calculate_Z(g_xBridgeMeasure.Vz, g_xBridgeMeasure.Va);
3784: 62 D0 02 MOV   REG[208],2
3787: 51 94    MOV   A,[148]
3789: 08       PUSH  A
378A: 51 95    MOV   A,[149]
378C: 08       PUSH  A
378D: 51 96    MOV   A,[150]
378F: 08       PUSH  A
3790: 51 97    MOV   A,[151]
3792: 08       PUSH  A
3793: 51 98    MOV   A,[152]
3795: 08       PUSH  A
3796: 51 99    MOV   A,[153]
3798: 08       PUSH  A
3799: 51 9A    MOV   A,[154]
379B: 08       PUSH  A
379C: 51 9B    MOV   A,[155]
379E: 08       PUSH  A
379F: 7C 13 BC LCALL _Calculate_Z
37A2: 38 F8    ADD   SP,248
37A4: 62 D0 02 MOV   REG[208],2
37A7: 51 B5    MOV   A,[__r1]
37A9: 08       PUSH  A
37AA: 51 B6    MOV   A,[__r0]
37AC: 62 D0 02 MOV   REG[208],2
37AF: 53 E9    MOV   [gwZ],A
37B1: 18       POP   A
37B2: 53 EA    MOV   [gwZ+1],A
(0243) 				gwR = Calculate_R(gwZ, gwSwr);
37B4: 62 D0 02 MOV   REG[208],2
37B7: 51 EB    MOV   A,[gwSwr]
37B9: 08       PUSH  A
37BA: 51 EC    MOV   A,[gwSwr+1]
37BC: 08       PUSH  A
37BD: 62 D0 02 MOV   REG[208],2
37C0: 51 E9    MOV   A,[gwZ]
37C2: 08       PUSH  A
37C3: 51 EA    MOV   A,[gwZ+1]
37C5: 08       PUSH  A
37C6: 7C 14 5E LCALL _Calculate_R
37C9: 38 FC    ADD   SP,252
37CB: 62 D0 02 MOV   REG[208],2
37CE: 51 B5    MOV   A,[__r1]
37D0: 08       PUSH  A
37D1: 51 B6    MOV   A,[__r0]
37D3: 62 D0 02 MOV   REG[208],2
37D6: 53 E5    MOV   [gwR],A
37D8: 18       POP   A
37D9: 53 E6    MOV   [gwR+1],A
(0244) 				gwX = Calculate_X(gwZ, gwR);
37DB: 51 E5    MOV   A,[gwR]
37DD: 08       PUSH  A
37DE: 51 E6    MOV   A,[gwR+1]
37E0: 08       PUSH  A
37E1: 62 D0 02 MOV   REG[208],2
37E4: 51 E9    MOV   A,[gwZ]
37E6: 08       PUSH  A
37E7: 51 EA    MOV   A,[gwZ+1]
37E9: 08       PUSH  A
37EA: 7C 15 6D LCALL _Calculate_X
37ED: 38 FC    ADD   SP,252
37EF: 62 D0 02 MOV   REG[208],2
37F2: 51 B5    MOV   A,[__r1]
37F4: 08       PUSH  A
37F5: 51 B6    MOV   A,[__r0]
37F7: 62 D0 02 MOV   REG[208],2
37FA: 53 E7    MOV   [gwX],A
37FC: 18       POP   A
37FD: 53 E8    MOV   [gwX+1],A
(0245) 
(0246) 										// Display data depending mode
(0247) 				switch (bMode)
37FF: 52 02    MOV   A,[X+2]
3801: 54 18    MOV   [X+24],A
3803: 56 17 00 MOV   [X+23],0
3806: 3D 17 00 CMP   [X+23],0
3809: B0 06    JNZ   0x3810
380B: 3D 18 00 CMP   [X+24],0
380E: A0 21    JZ    0x3830
3810: 3D 17 00 CMP   [X+23],0
3813: B0 06    JNZ   0x381A
3815: 3D 18 01 CMP   [X+24],1
3818: A0 5C    JZ    0x3875
381A: 3D 17 00 CMP   [X+23],0
381D: B0 06    JNZ   0x3824
381F: 3D 18 02 CMP   [X+24],2
3822: A1 3A    JZ    0x395D
3824: 3D 17 00 CMP   [X+23],0
3827: B0 06    JNZ   0x382E
3829: 3D 18 03 CMP   [X+24],3
382C: A1 85    JZ    0x39B2
382E: 81 D6    JMP   0x3A05
(0248) 				{
(0249) 					case MODE_SWR:
(0250) 						LCD_Position(ROW_SWR, 0);
3830: 10       PUSH  X
3831: 57 00    MOV   X,0
3833: 50 01    MOV   A,1
3835: 7C 0E 5E LCALL 0x0E5E
3838: 20       POP   X
(0251) 						LCD_PrCString(gBlankStr);
3839: 10       PUSH  X
383A: 50 03    MOV   A,3
383C: 08       PUSH  A
383D: 50 11    MOV   A,17
383F: 5C       MOV   X,A
3840: 18       POP   A
3841: 7C 0C D9 LCALL 0x0CD9
3844: 20       POP   X
(0252) 						LCD_Position(ROW_SWR, COL_SWR);
3845: 10       PUSH  X
3846: 57 00    MOV   X,0
3848: 50 01    MOV   A,1
384A: 7C 0E 5E LCALL 0x0E5E
384D: 20       POP   X
(0253) 						DISP_Swr(gwSwr);
384E: 62 D0 02 MOV   REG[208],2
3851: 51 EB    MOV   A,[gwSwr]
3853: 08       PUSH  A
3854: 51 EC    MOV   A,[gwSwr+1]
3856: 08       PUSH  A
3857: 7C 30 4B LCALL _DISP_Swr
385A: 38 FE    ADD   SP,254
(0254) 						LCD_Position(ROW_IMP, COL_IMP);
385C: 10       PUSH  X
385D: 57 05    MOV   X,5
385F: 50 01    MOV   A,1
3861: 7C 0E 5E LCALL 0x0E5E
3864: 20       POP   X
(0255) 						DISP_Impedance(gwZ);
3865: 62 D0 02 MOV   REG[208],2
3868: 51 E9    MOV   A,[gwZ]
386A: 08       PUSH  A
386B: 51 EA    MOV   A,[gwZ+1]
386D: 08       PUSH  A
386E: 7C 32 27 LCALL _DISP_Impedance
3871: 38 FE    ADD   SP,254
(0256) 						break;
3873: 81 91    JMP   0x3A05
(0257) 
(0258) 					case MODE_IMP:
(0259) 						if (bDizzling == FALSE)
3875: 3D 13 00 CMP   [X+19],0
3878: B0 88    JNZ   0x3901
(0260) 						{
(0261) 							wDizzlingX = gwX;
387A: 62 D0 02 MOV   REG[208],2
387D: 51 E8    MOV   A,[gwX+1]
387F: 54 15    MOV   [X+21],A
3881: 51 E7    MOV   A,[gwX]
3883: 54 14    MOV   [X+20],A
(0262) 							bDizzling = TRUE;
3885: 56 13 01 MOV   [X+19],1
(0263) 							DDS_Set(dwCurrentFreq+DIZZLING_FREQ);
3888: 62 D0 02 MOV   REG[208],2
388B: 52 06    MOV   A,[X+6]
388D: 01 40    ADD   A,64
388F: 53 B3    MOV   [__r3],A
3891: 52 05    MOV   A,[X+5]
3893: 09 42    ADC   A,66
3895: 53 B4    MOV   [__r2],A
3897: 52 04    MOV   A,[X+4]
3899: 09 0F    ADC   A,15
389B: 53 B5    MOV   [__r1],A
389D: 52 03    MOV   A,[X+3]
389F: 09 00    ADC   A,0
38A1: 08       PUSH  A
38A2: 51 B5    MOV   A,[__r1]
38A4: 08       PUSH  A
38A5: 51 B4    MOV   A,[__r2]
38A7: 08       PUSH  A
38A8: 51 B3    MOV   A,[__r3]
38AA: 08       PUSH  A
38AB: 7C 28 DC LCALL _DDS_Set
38AE: 38 FC    ADD   SP,252
(0264) 							LCD_Position(ROW_SWR, 0);
38B0: 10       PUSH  X
38B1: 57 00    MOV   X,0
38B3: 50 01    MOV   A,1
38B5: 7C 0E 5E LCALL 0x0E5E
38B8: 20       POP   X
(0265) 							LCD_PrCString(gBlankStr);
38B9: 10       PUSH  X
38BA: 50 03    MOV   A,3
38BC: 08       PUSH  A
38BD: 50 11    MOV   A,17
38BF: 5C       MOV   X,A
38C0: 18       POP   A
38C1: 7C 0C D9 LCALL 0x0CD9
38C4: 20       POP   X
(0266) 							LCD_Position(ROW_SWR, COL_SWR);
38C5: 10       PUSH  X
38C6: 57 00    MOV   X,0
38C8: 50 01    MOV   A,1
38CA: 7C 0E 5E LCALL 0x0E5E
38CD: 20       POP   X
(0267) 							DISP_Swr(gwSwr);
38CE: 62 D0 02 MOV   REG[208],2
38D1: 51 EB    MOV   A,[gwSwr]
38D3: 08       PUSH  A
38D4: 51 EC    MOV   A,[gwSwr+1]
38D6: 08       PUSH  A
38D7: 7C 30 4B LCALL _DISP_Swr
38DA: 38 FE    ADD   SP,254
(0268) 							LCD_Position(ROW_IMP, COL_IMP);
38DC: 10       PUSH  X
38DD: 57 05    MOV   X,5
38DF: 50 01    MOV   A,1
38E1: 7C 0E 5E LCALL 0x0E5E
38E4: 20       POP   X
(0269) 							DISP_ImpedanceComplex(gwR, gwX, bSign);
38E5: 52 16    MOV   A,[X+22]
38E7: 08       PUSH  A
38E8: 62 D0 02 MOV   REG[208],2
38EB: 51 E7    MOV   A,[gwX]
38ED: 08       PUSH  A
38EE: 51 E8    MOV   A,[gwX+1]
38F0: 08       PUSH  A
38F1: 62 D0 02 MOV   REG[208],2
38F4: 51 E5    MOV   A,[gwR]
38F6: 08       PUSH  A
38F7: 51 E6    MOV   A,[gwR+1]
38F9: 08       PUSH  A
38FA: 7C 30 9F LCALL _DISP_ImpedanceComplex
38FD: 38 FB    ADD   SP,251
(0270) 						}
38FF: 81 05    JMP   0x3A05
(0271) 						else
(0272) 						{
(0273) 							bDizzling = FALSE;
3901: 56 13 00 MOV   [X+19],0
(0274) 							DDS_Set(dwCurrentFreq);
3904: 52 03    MOV   A,[X+3]
3906: 08       PUSH  A
3907: 52 04    MOV   A,[X+4]
3909: 08       PUSH  A
390A: 52 05    MOV   A,[X+5]
390C: 08       PUSH  A
390D: 52 06    MOV   A,[X+6]
390F: 08       PUSH  A
3910: 7C 28 DC LCALL _DDS_Set
(0275)          								//Increasing X with increasing F ==> inductive reactance = +j
(0276)          								//Decreasing X with increasing F ==> capacitive reactance = -j
(0277) 										//If value <2 consider undeterminate to avoid bouncing
(0278) 							if (abs((INT)wDizzlingX-gwX)<2)
3913: 62 D0 02 MOV   REG[208],2
3916: 52 15    MOV   A,[X+21]
3918: 12 E8    SUB   A,[gwX+1]
391A: 62 D0 02 MOV   REG[208],2
391D: 53 B5    MOV   [__r1],A
391F: 52 14    MOV   A,[X+20]
3921: 62 D0 02 MOV   REG[208],2
3924: 1A E7    SBB   A,[gwX]
3926: 62 D0 02 MOV   REG[208],2
3929: 08       PUSH  A
392A: 51 B5    MOV   A,[__r1]
392C: 08       PUSH  A
392D: 7C 5F 7B LCALL _abs
3930: 38 FA    ADD   SP,250
3932: 62 D0 02 MOV   REG[208],2
3935: 51 B5    MOV   A,[__r1]
3937: 11 02    SUB   A,2
3939: 51 B6    MOV   A,[__r0]
393B: 31 80    XOR   A,128
393D: 19 80    SBB   A,128
393F: D0 06    JNC   0x3946
(0279) 								bSign = ' ';
3941: 56 16 20 MOV   [X+22],32
3944: 80 C0    JMP   0x3A05
(0280) 							else if (wDizzlingX<gwX)
3946: 62 D0 02 MOV   REG[208],2
3949: 52 15    MOV   A,[X+21]
394B: 12 E8    SUB   A,[gwX+1]
394D: 52 14    MOV   A,[X+20]
394F: 1A E7    SBB   A,[gwX]
3951: D0 06    JNC   0x3958
(0281) 								bSign = '+';
3953: 56 16 2B MOV   [X+22],43
3956: 80 AE    JMP   0x3A05
(0282) 							else
(0283) 								bSign = '-';
3958: 56 16 2D MOV   [X+22],45
(0284) 						}
(0285) 						break;
395B: 80 A9    JMP   0x3A05
(0286) 
(0287) 					case MODE_CAP:
(0288) 						LCD_Position(ROW_SWR, 0);
395D: 10       PUSH  X
395E: 57 00    MOV   X,0
3960: 50 01    MOV   A,1
3962: 7C 0E 5E LCALL 0x0E5E
3965: 20       POP   X
(0289) 						LCD_PrCString(gBlankStr);
3966: 10       PUSH  X
3967: 50 03    MOV   A,3
3969: 08       PUSH  A
396A: 50 11    MOV   A,17
396C: 5C       MOV   X,A
396D: 18       POP   A
396E: 7C 0C D9 LCALL 0x0CD9
3971: 20       POP   X
(0290) 						LCD_Position(ROW_C, COL_C);
3972: 10       PUSH  X
3973: 57 00    MOV   X,0
3975: 50 01    MOV   A,1
3977: 7C 0E 5E LCALL 0x0E5E
397A: 20       POP   X
(0291) 						gwC = Calculate_C(gwX, dwCurrentFreq);
397B: 52 03    MOV   A,[X+3]
397D: 08       PUSH  A
397E: 52 04    MOV   A,[X+4]
3980: 08       PUSH  A
3981: 52 05    MOV   A,[X+5]
3983: 08       PUSH  A
3984: 52 06    MOV   A,[X+6]
3986: 08       PUSH  A
3987: 62 D0 02 MOV   REG[208],2
398A: 51 E7    MOV   A,[gwX]
398C: 08       PUSH  A
398D: 51 E8    MOV   A,[gwX+1]
398F: 08       PUSH  A
3990: 7C 17 24 LCALL _Calculate_C
3993: 38 FA    ADD   SP,250
3995: 62 D0 02 MOV   REG[208],2
3998: 51 B5    MOV   A,[__r1]
399A: 08       PUSH  A
399B: 51 B6    MOV   A,[__r0]
399D: 62 D0 02 MOV   REG[208],2
39A0: 53 E3    MOV   [gwC],A
39A2: 18       POP   A
39A3: 53 E4    MOV   [gwC+1],A
(0292) 						DISP_Capacitance(gwC);
39A5: 51 E3    MOV   A,[gwC]
39A7: 08       PUSH  A
39A8: 51 E4    MOV   A,[gwC+1]
39AA: 08       PUSH  A
39AB: 7C 30 FD LCALL _DISP_Capacitance
39AE: 38 FE    ADD   SP,254
(0293) 						break;
39B0: 80 54    JMP   0x3A05
(0294) 
(0295) 					case MODE_IND:
(0296) 						LCD_Position(ROW_SWR, 0);
39B2: 10       PUSH  X
39B3: 57 00    MOV   X,0
39B5: 50 01    MOV   A,1
39B7: 7C 0E 5E LCALL 0x0E5E
39BA: 20       POP   X
(0297) 						LCD_PrCString(gBlankStr);
39BB: 10       PUSH  X
39BC: 50 03    MOV   A,3
39BE: 08       PUSH  A
39BF: 50 11    MOV   A,17
39C1: 5C       MOV   X,A
39C2: 18       POP   A
39C3: 7C 0C D9 LCALL 0x0CD9
39C6: 20       POP   X
(0298) 						LCD_Position(ROW_L, COL_L);
39C7: 10       PUSH  X
39C8: 57 00    MOV   X,0
39CA: 50 01    MOV   A,1
39CC: 7C 0E 5E LCALL 0x0E5E
39CF: 20       POP   X
(0299) 						gwL = Calculate_L(gwX, dwCurrentFreq);
39D0: 52 03    MOV   A,[X+3]
39D2: 08       PUSH  A
39D3: 52 04    MOV   A,[X+4]
39D5: 08       PUSH  A
39D6: 52 05    MOV   A,[X+5]
39D8: 08       PUSH  A
39D9: 52 06    MOV   A,[X+6]
39DB: 08       PUSH  A
39DC: 62 D0 02 MOV   REG[208],2
39DF: 51 E7    MOV   A,[gwX]
39E1: 08       PUSH  A
39E2: 51 E8    MOV   A,[gwX+1]
39E4: 08       PUSH  A
39E5: 7C 16 71 LCALL _Calculate_L
39E8: 38 FA    ADD   SP,250
39EA: 62 D0 02 MOV   REG[208],2
39ED: 51 B5    MOV   A,[__r1]
39EF: 08       PUSH  A
39F0: 51 B6    MOV   A,[__r0]
39F2: 62 D0 02 MOV   REG[208],2
39F5: 53 E1    MOV   [gwL],A
39F7: 18       POP   A
39F8: 53 E2    MOV   [gwL+1],A
(0300) 						DISP_Inductance(gwL);
39FA: 51 E1    MOV   A,[gwL]
39FC: 08       PUSH  A
39FD: 51 E2    MOV   A,[gwL+1]
39FF: 08       PUSH  A
3A00: 7C 31 92 LCALL _DISP_Inductance
3A03: 38 FE    ADD   SP,254
(0301) 						break;
(0302) 
(0303) 					default:
(0304) 						break;
(0305) 				}
(0306) 			}
(0307) 			if (bMode == MODE_OFF)
3A05: 3D 02 04 CMP   [X+2],4
3A08: B0 65    JNZ   0x3A6E
(0308) 			{
(0309) 				Do_MeasureRfLevel();
3A0A: 7C 47 BC LCALL _Do_MeasureRfLevel
(0310) 				LCD_DrawBG(ROW_SWR, 0, 16, (g_xBridgeMeasure.Vz*80)/4000);
3A0D: 62 D0 02 MOV   REG[208],2
3A10: 51 98    MOV   A,[152]
3A12: 08       PUSH  A
3A13: 51 99    MOV   A,[153]
3A15: 08       PUSH  A
3A16: 51 9A    MOV   A,[154]
3A18: 08       PUSH  A
3A19: 51 9B    MOV   A,[155]
3A1B: 08       PUSH  A
3A1C: 50 00    MOV   A,0
3A1E: 08       PUSH  A
3A1F: 08       PUSH  A
3A20: 08       PUSH  A
3A21: 50 50    MOV   A,80
3A23: 08       PUSH  A
3A24: 62 D0 02 MOV   REG[208],2
3A27: 7C 57 3B LCALL __mul_32X32_32
3A2A: 38 FC    ADD   SP,252
3A2C: 18       POP   A
3A2D: 53 B3    MOV   [__r3],A
3A2F: 18       POP   A
3A30: 53 B4    MOV   [__r2],A
3A32: 18       POP   A
3A33: 53 B5    MOV   [__r1],A
3A35: 18       POP   A
3A36: 53 B6    MOV   [__r0],A
3A38: 50 00    MOV   A,0
3A3A: 08       PUSH  A
3A3B: 08       PUSH  A
3A3C: 50 0F    MOV   A,15
3A3E: 08       PUSH  A
3A3F: 50 A0    MOV   A,160
3A41: 08       PUSH  A
3A42: 51 B6    MOV   A,[__r0]
3A44: 08       PUSH  A
3A45: 51 B5    MOV   A,[__r1]
3A47: 08       PUSH  A
3A48: 51 B4    MOV   A,[__r2]
3A4A: 08       PUSH  A
3A4B: 51 B3    MOV   A,[__r3]
3A4D: 08       PUSH  A
3A4E: 7C 55 EC LCALL __divmodu_32X32_32
3A51: 18       POP   A
3A52: 53 B3    MOV   [__r3],A
3A54: 18       POP   A
3A55: 18       POP   A
3A56: 18       POP   A
3A57: 38 FC    ADD   SP,252
3A59: 51 B3    MOV   A,[__r3]
3A5B: 10       PUSH  X
3A5C: 08       PUSH  A
3A5D: 50 10    MOV   A,16
3A5F: 08       PUSH  A
3A60: 50 00    MOV   A,0
3A62: 08       PUSH  A
3A63: 50 01    MOV   A,1
3A65: 08       PUSH  A
3A66: 7C 0E 90 LCALL 0x0E90
3A69: 38 FC    ADD   SP,252
3A6B: 20       POP   X
(0311) 			}
3A6C: 80 4C    JMP   0x3AB9
(0312) 			else
(0313) 			{
(0314) 										// Set cursor position
(0315) 				LCD_Position(ROW_FREQ, gxIncrementControl[bIncCtl].bCol);
3A6E: 62 D0 02 MOV   REG[208],2
3A71: 52 08    MOV   A,[X+8]
3A73: 53 B5    MOV   [__r1],A
3A75: 50 00    MOV   A,0
3A77: 08       PUSH  A
3A78: 51 B5    MOV   A,[__r1]
3A7A: 08       PUSH  A
3A7B: 50 00    MOV   A,0
3A7D: 08       PUSH  A
3A7E: 50 05    MOV   A,5
3A80: 08       PUSH  A
3A81: 7C 56 FD LCALL __mul16
3A84: 38 FC    ADD   SP,252
3A86: 51 AC    MOV   A,[__rX]
3A88: 53 B5    MOV   [__r1],A
3A8A: 51 AB    MOV   A,[__rY]
3A8C: 53 B6    MOV   [__r0],A
3A8E: 06 B5 EE ADD   [__r1],238
3A91: 0E B6 02 ADC   [__r0],2
3A94: 51 B6    MOV   A,[__r0]
3A96: 10       PUSH  X
3A97: 58 B5    MOV   X,[__r1]
3A99: 28       ROMX  
3A9A: 20       POP   X
3A9B: 10       PUSH  X
3A9C: 08       PUSH  A
3A9D: 50 00    MOV   A,0
3A9F: 20       POP   X
3AA0: 7C 0E 5E LCALL 0x0E5E
3AA3: 20       POP   X
(0316) 				if (bFrChMode==TRUE)
3AA4: 3D 07 01 CMP   [X+7],1
3AA7: B0 0A    JNZ   0x3AB2
(0317) 					LCD_Control(LCD_ON_BLINK);
3AA9: 10       PUSH  X
3AAA: 50 0D    MOV   A,13
3AAC: 7C 0D 3B LCALL 0x0D3B
3AAF: 20       POP   X
3AB0: 80 08    JMP   0x3AB9
(0318) 				else
(0319) 					LCD_Control(LCD_ON_CURSOR);
3AB2: 10       PUSH  X
3AB3: 50 0E    MOV   A,14
3AB5: 7C 0D 3B LCALL 0x0D3B
3AB8: 20       POP   X
(0320) 			}
(0321) 										// Waits for key or time for new measurement
(0322) 			g_bMeasureCounter = MEASURE_PERIOD;
3AB9: 62 D0 02 MOV   REG[208],2
3ABC: 55 F1 08 MOV   [g_bMeasureCounter],8
(0323) 			do
(0324) 			{
(0325) 				BYTE bNewBand;
(0326) 				DWORD dwNewFreq;
(0327) 
(0328) 				M8C_Sleep;
3ABF: 43 FF 08 OR    REG[255],8
(0329) 				bKey = KEYPAD_Get();
3AC2: 7C 32 8B LCALL _KEYPAD_Get
3AC5: 62 D0 02 MOV   REG[208],2
3AC8: 54 00    MOV   [X+0],A
(0330) 				switch ( bKey )
3ACA: 52 00    MOV   A,[X+0]
3ACC: 54 1D    MOV   [X+29],A
3ACE: 56 1C 00 MOV   [X+28],0
3AD1: 3D 1C 00 CMP   [X+28],0
3AD4: B0 06    JNZ   0x3ADB
3AD6: 3D 1D 01 CMP   [X+29],1
3AD9: A0 53    JZ    0x3B2D
3ADB: 3D 1C 00 CMP   [X+28],0
3ADE: B0 06    JNZ   0x3AE5
3AE0: 3D 1D 02 CMP   [X+29],2
3AE3: A0 CA    JZ    0x3BAE
3AE5: 3D 1C 00 CMP   [X+28],0
3AE8: B0 06    JNZ   0x3AEF
3AEA: 3D 1D 03 CMP   [X+29],3
3AED: A1 25    JZ    0x3C13
3AEF: 3D 1C 00 CMP   [X+28],0
3AF2: B0 06    JNZ   0x3AF9
3AF4: 3D 1D 04 CMP   [X+29],4
3AF7: A2 47    JZ    0x3D3F
3AF9: 3D 1C 00 CMP   [X+28],0
3AFC: B0 06    JNZ   0x3B03
3AFE: 3D 1D 05 CMP   [X+29],5
3B01: A2 CE    JZ    0x3DD0
3B03: 3D 1C 00 CMP   [X+28],0
3B06: B0 06    JNZ   0x3B0D
3B08: 3D 1D 06 CMP   [X+29],6
3B0B: A3 D8    JZ    0x3EE4
3B0D: 3D 1C 00 CMP   [X+28],0
3B10: B0 06    JNZ   0x3B17
3B12: 3D 1D 07 CMP   [X+29],7
3B15: A2 BA    JZ    0x3DD0
3B17: 3D 1C 00 CMP   [X+28],0
3B1A: B0 06    JNZ   0x3B21
3B1C: 3D 1D 08 CMP   [X+29],8
3B1F: A3 C4    JZ    0x3EE4
3B21: 3D 1C 00 CMP   [X+28],0
3B24: B0 06    JNZ   0x3B2B
3B26: 3D 1D 09 CMP   [X+29],9
3B29: A2 90    JZ    0x3DBA
3B2B: 84 C6    JMP   0x3FF2
(0331) 				{
(0332) 					case KBD_CONFIG:
(0333) 						bFrChMode=FALSE;
3B2D: 56 07 00 MOV   [X+7],0
(0334) 						LCD_Control(LCD_ON);
3B30: 10       PUSH  X
3B31: 50 0C    MOV   A,12
3B33: 7C 0D 3B LCALL 0x0D3B
3B36: 20       POP   X
(0335) 										// Enter configuration mode routine
(0336) 						DDS_Set(0);		// Disables DDS to save power
3B37: 50 00    MOV   A,0
3B39: 08       PUSH  A
3B3A: 08       PUSH  A
3B3B: 08       PUSH  A
3B3C: 08       PUSH  A
3B3D: 7C 28 DC LCALL _DDS_Set
3B40: 38 FC    ADD   SP,252
(0337) 						Mode_Config();
3B42: 7C 44 8E LCALL _Mode_Config
(0338) 
(0339) 										// Get band-specific correction factors based on current freq dial setting
(0340) 						g_xBridgeCorrect = g_xBandCorrFactor[bBand];
3B45: 62 D0 02 MOV   REG[208],2
3B48: 52 01    MOV   A,[X+1]
3B4A: 53 B5    MOV   [__r1],A
3B4C: 50 00    MOV   A,0
3B4E: 08       PUSH  A
3B4F: 51 B5    MOV   A,[__r1]
3B51: 08       PUSH  A
3B52: 50 00    MOV   A,0
3B54: 08       PUSH  A
3B55: 50 0C    MOV   A,12
3B57: 08       PUSH  A
3B58: 7C 56 FD LCALL __mul16
3B5B: 38 FC    ADD   SP,252
3B5D: 51 AC    MOV   A,[__rX]
3B5F: 53 B5    MOV   [__r1],A
3B61: 51 AB    MOV   A,[__rY]
3B63: 53 B6    MOV   [__r0],A
3B65: 06 B5 0B ADD   [__r1],11
3B68: 0E B6 00 ADC   [__r0],0
3B6B: 55 B3 EB MOV   [__r3],235
3B6E: 55 B4 00 MOV   [__r2],0
3B71: 51 B6    MOV   A,[__r0]
3B73: 60 D4    MOV   REG[212],A
3B75: 51 B4    MOV   A,[__r2]
3B77: 60 D5    MOV   REG[213],A
3B79: 10       PUSH  X
3B7A: 57 0C    MOV   X,12
3B7C: 62 D0 02 MOV   REG[208],2
3B7F: 3E B5    MVI   A,[__r1]
3B81: 3F B3    MVI   [__r3],A
3B83: 79       DEC   X
3B84: BF F7    JNZ   0x3B7C
3B86: 20       POP   X
(0341) 										// Adjust DDS gain setting
(0342) 						Adjust_Dds_Gain(bBand);
3B87: 52 01    MOV   A,[X+1]
3B89: 08       PUSH  A
3B8A: 7C 25 35 LCALL _Adjust_Dds_Gain
3B8D: 38 FF    ADD   SP,255
(0343) 						if (bMode != MODE_OFF)
3B8F: 3D 02 04 CMP   [X+2],4
3B92: A0 12    JZ    0x3BA5
(0344) 							DDS_Set(dwCurrentFreq);
3B94: 52 03    MOV   A,[X+3]
3B96: 08       PUSH  A
3B97: 52 04    MOV   A,[X+4]
3B99: 08       PUSH  A
3B9A: 52 05    MOV   A,[X+5]
3B9C: 08       PUSH  A
3B9D: 52 06    MOV   A,[X+6]
3B9F: 08       PUSH  A
3BA0: 7C 28 DC LCALL _DDS_Set
3BA3: 38 FC    ADD   SP,252
(0345) 						LCD_Control(LCD_ON_CURSOR);
3BA5: 10       PUSH  X
3BA6: 50 0E    MOV   A,14
3BA8: 7C 0D 3B LCALL 0x0D3B
3BAB: 20       POP   X
(0346) 						break;
3BAC: 84 45    JMP   0x3FF2
(0347) 
(0348) 					case KBD_MODE:
(0349) 						bFrChMode=FALSE;
3BAE: 56 07 00 MOV   [X+7],0
(0350) 						if (bMode==MODE_OFF)
3BB1: 3D 02 04 CMP   [X+2],4
3BB4: B0 2D    JNZ   0x3BE2
(0351) 						{				// Resume from OFF mode
(0352) 							PGA_DDS_1_Start(PGA_DDS_1_HIGHPOWER);
3BB6: 10       PUSH  X
3BB7: 50 03    MOV   A,3
3BB9: 7C 0C 59 LCALL 0x0C59
3BBC: 20       POP   X
(0353) 							PGA_DDS_2_Start(PGA_DDS_2_HIGHPOWER);
3BBD: 10       PUSH  X
3BBE: 50 03    MOV   A,3
3BC0: 7C 0C 19 LCALL 0x0C19
3BC3: 20       POP   X
(0354) 							Adjust_Dds_Gain(bBand);
3BC4: 52 01    MOV   A,[X+1]
3BC6: 08       PUSH  A
3BC7: 7C 25 35 LCALL _Adjust_Dds_Gain
(0355) 
(0356) 										// Enables DDS oscillator and backlight (shared port)
(0357) 							DDS_Set(dwCurrentFreq);
3BCA: 52 03    MOV   A,[X+3]
3BCC: 08       PUSH  A
3BCD: 52 04    MOV   A,[X+4]
3BCF: 08       PUSH  A
3BD0: 52 05    MOV   A,[X+5]
3BD2: 08       PUSH  A
3BD3: 52 06    MOV   A,[X+6]
3BD5: 08       PUSH  A
3BD6: 7C 28 DC LCALL _DDS_Set
3BD9: 38 FB    ADD   SP,251
(0358) 							//XO_EN_Data_ADDR |= XO_EN_MASK;
(0359) 
(0360) 							LCD_Control(LCD_ON_CURSOR);
3BDB: 10       PUSH  X
3BDC: 50 0E    MOV   A,14
3BDE: 7C 0D 3B LCALL 0x0D3B
3BE1: 20       POP   X
(0361) 						}
(0362) 						if (++bMode >= MODE_MAX)
3BE2: 62 D0 02 MOV   REG[208],2
3BE5: 52 02    MOV   A,[X+2]
3BE7: 01 01    ADD   A,1
3BE9: 54 02    MOV   [X+2],A
3BEB: 39 05    CMP   A,5
3BED: C0 04    JC    0x3BF2
(0363) 							bMode = MODE_SWR;
3BEF: 56 02 00 MOV   [X+2],0
(0364) 						if (bMode==MODE_OFF)
3BF2: 3D 02 04 CMP   [X+2],4
3BF5: B3 FC    JNZ   0x3FF2
(0365) 						{				// Enter OFF mode
(0366) 							LCD_Control(LCD_ON);
3BF7: 10       PUSH  X
3BF8: 50 0C    MOV   A,12
3BFA: 7C 0D 3B LCALL 0x0D3B
3BFD: 20       POP   X
(0367) 							DDS_Set(0);
3BFE: 50 00    MOV   A,0
3C00: 08       PUSH  A
3C01: 08       PUSH  A
3C02: 08       PUSH  A
3C03: 08       PUSH  A
3C04: 7C 28 DC LCALL _DDS_Set
3C07: 38 FC    ADD   SP,252
(0368) 							PGA_DDS_1_Stop();
3C09: 10       PUSH  X
3C0A: 7C 0C 95 LCALL 0x0C95
(0369) 							PGA_DDS_2_Stop();
3C0D: 7C 0C 55 LCALL 0x0C55
3C10: 20       POP   X
(0370) 
(0371) 										// Disables DDS oscillator and backlight (shared port)
(0372) 							//XO_EN_Data_ADDR &= ~XO_EN_MASK;
(0373) 						}
(0374) 						break;
3C11: 83 E0    JMP   0x3FF2
(0375) 
(0376) 					case KBD_BAND:
(0377) 						if (bMode == MODE_OFF)
3C13: 3D 02 04 CMP   [X+2],4
3C16: B0 03    JNZ   0x3C1A
(0378) 							break;
3C18: 83 D9    JMP   0x3FF2
(0379) 						bFrChMode=FALSE;
3C1A: 56 07 00 MOV   [X+7],0
(0380) 						LCD_Control(LCD_ON);
3C1D: 10       PUSH  X
3C1E: 50 0C    MOV   A,12
3C20: 7C 0D 3B LCALL 0x0D3B
3C23: 20       POP   X
(0381) 
(0382) 						// Saves current freq
(0383) 						g_dwSaveFreqBand[bBand] = dwCurrentFreq;
3C24: 62 D0 02 MOV   REG[208],2
3C27: 52 01    MOV   A,[X+1]
3C29: 53 B5    MOV   [__r1],A
3C2B: 55 B6 00 MOV   [__r0],0
3C2E: 65 B5    ASL   [__r1]
3C30: 6B B6    RLC   [__r0]
3C32: 65 B5    ASL   [__r1]
3C34: 6B B6    RLC   [__r0]
3C36: 06 B5 B3 ADD   [__r1],179
3C39: 0E B6 00 ADC   [__r0],0
3C3C: 51 B6    MOV   A,[__r0]
3C3E: 60 D5    MOV   REG[213],A
3C40: 52 03    MOV   A,[X+3]
3C42: 3F B5    MVI   [__r1],A
3C44: 52 04    MOV   A,[X+4]
3C46: 3F B5    MVI   [__r1],A
3C48: 52 05    MOV   A,[X+5]
3C4A: 3F B5    MVI   [__r1],A
3C4C: 52 06    MOV   A,[X+6]
3C4E: 3F B5    MVI   [__r1],A
(0384) 						if (++bBand >= BAND_MAX)
3C50: 52 01    MOV   A,[X+1]
3C52: 01 01    ADD   A,1
3C54: 54 01    MOV   [X+1],A
3C56: 39 0E    CMP   A,14
3C58: C0 04    JC    0x3C5D
(0385) 							bBand = BAND_160M;
3C5A: 56 01 00 MOV   [X+1],0
(0386) 									// Restores frequency
(0387) 						dwCurrentFreq = g_dwSaveFreqBand[bBand];
3C5D: 62 D0 02 MOV   REG[208],2
3C60: 52 01    MOV   A,[X+1]
3C62: 53 B5    MOV   [__r1],A
3C64: 55 B6 00 MOV   [__r0],0
3C67: 65 B5    ASL   [__r1]
3C69: 6B B6    RLC   [__r0]
3C6B: 65 B5    ASL   [__r1]
3C6D: 6B B6    RLC   [__r0]
3C6F: 06 B5 B3 ADD   [__r1],179
3C72: 0E B6 00 ADC   [__r0],0
3C75: 51 B6    MOV   A,[__r0]
3C77: 60 D4    MOV   REG[212],A
3C79: 3E B5    MVI   A,[__r1]
3C7B: 54 03    MOV   [X+3],A
3C7D: 3E B5    MVI   A,[__r1]
3C7F: 54 04    MOV   [X+4],A
3C81: 3E B5    MVI   A,[__r1]
3C83: 54 05    MOV   [X+5],A
3C85: 3E B5    MVI   A,[__r1]
3C87: 54 06    MOV   [X+6],A
(0388) 									// Get band-specific correction factors based on current freq dial setting
(0389) 						g_xBridgeCorrect = g_xBandCorrFactor[bBand];
3C89: 52 01    MOV   A,[X+1]
3C8B: 53 B5    MOV   [__r1],A
3C8D: 50 00    MOV   A,0
3C8F: 08       PUSH  A
3C90: 51 B5    MOV   A,[__r1]
3C92: 08       PUSH  A
3C93: 50 00    MOV   A,0
3C95: 08       PUSH  A
3C96: 50 0C    MOV   A,12
3C98: 08       PUSH  A
3C99: 7C 56 FD LCALL __mul16
3C9C: 38 FC    ADD   SP,252
3C9E: 51 AC    MOV   A,[__rX]
3CA0: 53 B5    MOV   [__r1],A
3CA2: 51 AB    MOV   A,[__rY]
3CA4: 53 B6    MOV   [__r0],A
3CA6: 06 B5 0B ADD   [__r1],11
3CA9: 0E B6 00 ADC   [__r0],0
3CAC: 55 B3 EB MOV   [__r3],235
3CAF: 55 B4 00 MOV   [__r2],0
3CB2: 51 B6    MOV   A,[__r0]
3CB4: 60 D4    MOV   REG[212],A
3CB6: 51 B4    MOV   A,[__r2]
3CB8: 60 D5    MOV   REG[213],A
3CBA: 10       PUSH  X
3CBB: 57 0C    MOV   X,12
3CBD: 62 D0 02 MOV   REG[208],2
3CC0: 3E B5    MVI   A,[__r1]
3CC2: 3F B3    MVI   [__r3],A
3CC4: 79       DEC   X
3CC5: BF F7    JNZ   0x3CBD
3CC7: 20       POP   X
(0390) 						Adjust_Dds_Gain(bBand);
3CC8: 52 01    MOV   A,[X+1]
3CCA: 08       PUSH  A
3CCB: 7C 25 35 LCALL _Adjust_Dds_Gain
(0391) 						DDS_Set(dwCurrentFreq);
3CCE: 52 03    MOV   A,[X+3]
3CD0: 08       PUSH  A
3CD1: 52 04    MOV   A,[X+4]
3CD3: 08       PUSH  A
3CD4: 52 05    MOV   A,[X+5]
3CD6: 08       PUSH  A
3CD7: 52 06    MOV   A,[X+6]
3CD9: 08       PUSH  A
3CDA: 7C 28 DC LCALL _DDS_Set
3CDD: 38 FB    ADD   SP,251
(0392) 									// Displays band
(0393) 						DISP_Clear();
3CDF: 7C 32 83 LCALL _DISP_Clear
(0394) 						LCD_Position(0, 0);
3CE2: 10       PUSH  X
3CE3: 50 00    MOV   A,0
3CE5: 5C       MOV   X,A
3CE6: 7C 0E 5E LCALL 0x0E5E
3CE9: 20       POP   X
(0395) 						LCD_PrCString(gBandLitStr);
3CEA: 10       PUSH  X
3CEB: 50 04    MOV   A,4
3CED: 08       PUSH  A
3CEE: 50 CE    MOV   A,206
3CF0: 5C       MOV   X,A
3CF1: 18       POP   A
3CF2: 7C 0C D9 LCALL 0x0CD9
3CF5: 20       POP   X
(0396) 						LCD_Position(0, 12);
3CF6: 10       PUSH  X
3CF7: 57 0C    MOV   X,12
3CF9: 50 00    MOV   A,0
3CFB: 7C 0E 5E LCALL 0x0E5E
3CFE: 20       POP   X
(0397) 						LCD_PrCString(gBandStr[bBand]);
3CFF: 62 D0 02 MOV   REG[208],2
3D02: 52 01    MOV   A,[X+1]
3D04: 53 B5    MOV   [__r1],A
3D06: 55 B6 00 MOV   [__r0],0
3D09: 65 B5    ASL   [__r1]
3D0B: 6B B6    RLC   [__r0]
3D0D: 06 B5 70 ADD   [__r1],112
3D10: 0E B6 02 ADC   [__r0],2
3D13: 51 B6    MOV   A,[__r0]
3D15: 60 D4    MOV   REG[212],A
3D17: 3E B5    MVI   A,[__r1]
3D19: 53 B6    MOV   [__r0],A
3D1B: 3E B5    MVI   A,[__r1]
3D1D: 53 B5    MOV   [__r1],A
3D1F: 10       PUSH  X
3D20: 51 B6    MOV   A,[__r0]
3D22: 08       PUSH  A
3D23: 51 B5    MOV   A,[__r1]
3D25: 5C       MOV   X,A
3D26: 18       POP   A
3D27: 7C 0C D9 LCALL 0x0CD9
3D2A: 20       POP   X
(0398) 						KEYPAD_WaitKey(TIME_DELAY_TEXT);
3D2B: 50 04    MOV   A,4
3D2D: 08       PUSH  A
3D2E: 7C 33 12 LCALL _KEYPAD_WaitKey
3D31: 38 FF    ADD   SP,255
3D33: 62 D0 02 MOV   REG[208],2
(0399) 						LCD_Control(LCD_ON_CURSOR);
3D36: 10       PUSH  X
3D37: 50 0E    MOV   A,14
3D39: 7C 0D 3B LCALL 0x0D3B
3D3C: 20       POP   X
(0400) 						break;
3D3D: 82 B4    JMP   0x3FF2
(0401) 
(0402) 					case KBD_SCAN:
(0403) 						if (bMode == MODE_OFF)
3D3F: 3D 02 04 CMP   [X+2],4
3D42: B0 03    JNZ   0x3D46
(0404) 							break;
3D44: 82 AD    JMP   0x3FF2
(0405) 
(0406) 						bFrChMode=FALSE;
3D46: 56 07 00 MOV   [X+7],0
(0407) 						LCD_Control(LCD_ON);
3D49: 10       PUSH  X
3D4A: 50 0C    MOV   A,12
3D4C: 7C 0D 3B LCALL 0x0D3B
3D4F: 20       POP   X
(0408) 
(0409) 						g_bScanning = TRUE;
3D50: 62 D0 02 MOV   REG[208],2
3D53: 55 F4 01 MOV   [g_bScanning],1
(0410) 										// Enter scan mode
(0411) 						dwScanFreq = Mode_Scan(bBand, g_xConf.bStep);
3D56: 62 D0 02 MOV   REG[208],2
3D59: 51 ED    MOV   A,[g_xConf]
3D5B: 08       PUSH  A
3D5C: 52 01    MOV   A,[X+1]
3D5E: 08       PUSH  A
3D5F: 93 A4    CALL  _Mode_Scan
3D61: 38 FE    ADD   SP,254
3D63: 62 D0 02 MOV   REG[208],2
3D66: 51 B6    MOV   A,[__r0]
3D68: 54 09    MOV   [X+9],A
3D6A: 51 B5    MOV   A,[__r1]
3D6C: 54 0A    MOV   [X+10],A
3D6E: 51 B4    MOV   A,[__r2]
3D70: 54 0B    MOV   [X+11],A
3D72: 51 B3    MOV   A,[__r3]
3D74: 54 0C    MOV   [X+12],A
(0412) 						if (dwScanFreq!=-1)
3D76: 3D 09 FF CMP   [X+9],255
3D79: B0 10    JNZ   0x3D8A
3D7B: 3D 0A FF CMP   [X+10],255
3D7E: B0 0B    JNZ   0x3D8A
3D80: 3D 0B FF CMP   [X+11],255
3D83: B0 06    JNZ   0x3D8A
3D85: 3D 0C FF CMP   [X+12],255
3D88: A0 11    JZ    0x3D9A
(0413) 						{
(0414) 							dwCurrentFreq = dwScanFreq;
3D8A: 52 09    MOV   A,[X+9]
3D8C: 54 03    MOV   [X+3],A
3D8E: 52 0A    MOV   A,[X+10]
3D90: 54 04    MOV   [X+4],A
3D92: 52 0B    MOV   A,[X+11]
3D94: 54 05    MOV   [X+5],A
3D96: 52 0C    MOV   A,[X+12]
3D98: 54 06    MOV   [X+6],A
(0415) 						}
(0416) 						DDS_Set(dwCurrentFreq);
3D9A: 52 03    MOV   A,[X+3]
3D9C: 08       PUSH  A
3D9D: 52 04    MOV   A,[X+4]
3D9F: 08       PUSH  A
3DA0: 52 05    MOV   A,[X+5]
3DA2: 08       PUSH  A
3DA3: 52 06    MOV   A,[X+6]
3DA5: 08       PUSH  A
3DA6: 7C 28 DC LCALL _DDS_Set
3DA9: 38 FC    ADD   SP,252
(0417) 						g_bScanning = FALSE;
3DAB: 62 D0 02 MOV   REG[208],2
3DAE: 55 F4 00 MOV   [g_bScanning],0
(0418) 						LCD_Control(LCD_ON_CURSOR);
3DB1: 10       PUSH  X
3DB2: 50 0E    MOV   A,14
3DB4: 7C 0D 3B LCALL 0x0D3B
3DB7: 20       POP   X
(0419) 						break;
3DB8: 82 39    JMP   0x3FF2
(0420) 
(0421) 					case KBD_UP_DWN:
(0422) 						if (bMode == MODE_OFF)
3DBA: 3D 02 04 CMP   [X+2],4
3DBD: B0 03    JNZ   0x3DC1
(0423) 							break;
3DBF: 82 32    JMP   0x3FF2
(0424) 										// Toggle between cursor or frequency change modes
(0425) 						if (bFrChMode==TRUE)
3DC1: 3D 07 01 CMP   [X+7],1
3DC4: B0 06    JNZ   0x3DCB
(0426) 							bFrChMode=FALSE;
3DC6: 56 07 00 MOV   [X+7],0
3DC9: 82 28    JMP   0x3FF2
(0427) 						else
(0428) 							bFrChMode=TRUE;
3DCB: 56 07 01 MOV   [X+7],1
(0429) 						break;
3DCE: 82 23    JMP   0x3FF2
(0430) 
(0431) 					case KBD_2xUP:
(0432) 					case KBD_UP:
(0433) 						if (bMode == MODE_OFF)
3DD0: 3D 02 04 CMP   [X+2],4
3DD3: B0 03    JNZ   0x3DD7
(0434) 							break;
3DD5: 82 1C    JMP   0x3FF2
(0435) 										// Moves frequency cursor
(0436) 						if (bFrChMode==TRUE)
3DD7: 3D 07 01 CMP   [X+7],1
3DDA: B0 13    JNZ   0x3DEE
(0437) 						{
(0438) 							if (++bIncCtl >= MAX_INCREMENT)
3DDC: 62 D0 02 MOV   REG[208],2
3DDF: 52 08    MOV   A,[X+8]
3DE1: 01 01    ADD   A,1
3DE3: 54 08    MOV   [X+8],A
3DE5: 39 07    CMP   A,7
3DE7: C2 0A    JC    0x3FF2
(0439) 								bIncCtl = 0;
3DE9: 56 08 00 MOV   [X+8],0
(0440) 							break;
3DEC: 82 05    JMP   0x3FF2
(0441) 						}
(0442) 										// Increases frequency
(0443) 						dwNewFreq = dwCurrentFreq+gxIncrementControl[bIncCtl].dwIncrement;
3DEE: 62 D0 02 MOV   REG[208],2
3DF1: 52 08    MOV   A,[X+8]
3DF3: 53 B5    MOV   [__r1],A
3DF5: 50 00    MOV   A,0
3DF7: 08       PUSH  A
3DF8: 51 B5    MOV   A,[__r1]
3DFA: 08       PUSH  A
3DFB: 50 00    MOV   A,0
3DFD: 08       PUSH  A
3DFE: 50 05    MOV   A,5
3E00: 08       PUSH  A
3E01: 7C 56 FD LCALL __mul16
3E04: 38 FC    ADD   SP,252
3E06: 51 AC    MOV   A,[__rX]
3E08: 53 B5    MOV   [__r1],A
3E0A: 51 AB    MOV   A,[__rY]
3E0C: 53 B6    MOV   [__r0],A
3E0E: 06 B5 EF ADD   [__r1],239
3E11: 0E B6 02 ADC   [__r0],2
3E14: 51 B6    MOV   A,[__r0]
3E16: 10       PUSH  X
3E17: 08       PUSH  A
3E18: 58 B5    MOV   X,[__r1]
3E1A: 28       ROMX  
3E1B: 53 B6    MOV   [__r0],A
3E1D: 18       POP   A
3E1E: 75       INC   X
3E1F: 09 00    ADC   A,0
3E21: 08       PUSH  A
3E22: 28       ROMX  
3E23: 53 B5    MOV   [__r1],A
3E25: 18       POP   A
3E26: 75       INC   X
3E27: 09 00    ADC   A,0
3E29: 08       PUSH  A
3E2A: 28       ROMX  
3E2B: 53 B4    MOV   [__r2],A
3E2D: 18       POP   A
3E2E: 75       INC   X
3E2F: 09 00    ADC   A,0
3E31: 28       ROMX  
3E32: 53 B3    MOV   [__r3],A
3E34: 20       POP   X
3E35: 52 06    MOV   A,[X+6]
3E37: 02 B3    ADD   A,[__r3]
3E39: 54 1B    MOV   [X+27],A
3E3B: 52 05    MOV   A,[X+5]
3E3D: 0A B4    ADC   A,[__r2]
3E3F: 54 1A    MOV   [X+26],A
3E41: 52 04    MOV   A,[X+4]
3E43: 0A B5    ADC   A,[__r1]
3E45: 54 19    MOV   [X+25],A
3E47: 52 03    MOV   A,[X+3]
3E49: 0A B6    ADC   A,[__r0]
3E4B: 54 18    MOV   [X+24],A
(0444) 						bNewBand = GetBand(dwNewFreq);
3E4D: 52 18    MOV   A,[X+24]
3E4F: 08       PUSH  A
3E50: 52 19    MOV   A,[X+25]
3E52: 08       PUSH  A
3E53: 52 1A    MOV   A,[X+26]
3E55: 08       PUSH  A
3E56: 52 1B    MOV   A,[X+27]
3E58: 08       PUSH  A
3E59: 7C 54 82 LCALL _GetBand
3E5C: 38 FC    ADD   SP,252
3E5E: 62 D0 02 MOV   REG[208],2
3E61: 54 17    MOV   [X+23],A
(0445) 						if (bNewBand==-1)
3E63: 3D 17 FF CMP   [X+23],255
3E66: B0 06    JNZ   0x3E6D
(0446) 						{
(0447) 							BUZZ_BeepError();
3E68: 7C 12 A6 LCALL _BUZZ_BeepError
(0448) 							break;
3E6B: 81 86    JMP   0x3FF2
(0449) 						}
(0450) 						dwCurrentFreq = dwNewFreq;
3E6D: 52 18    MOV   A,[X+24]
3E6F: 54 03    MOV   [X+3],A
3E71: 52 19    MOV   A,[X+25]
3E73: 54 04    MOV   [X+4],A
3E75: 52 1A    MOV   A,[X+26]
3E77: 54 05    MOV   [X+5],A
3E79: 52 1B    MOV   A,[X+27]
3E7B: 54 06    MOV   [X+6],A
(0451) 						if (bBand!=bNewBand)
3E7D: 52 01    MOV   A,[X+1]
3E7F: 3B 17    CMP   A,[X+23]
3E81: A0 4F    JZ    0x3ED1
(0452) 						{
(0453) 							bBand = bNewBand;
3E83: 52 17    MOV   A,[X+23]
3E85: 54 01    MOV   [X+1],A
(0454) 							g_xBridgeCorrect = g_xBandCorrFactor[bBand];
3E87: 62 D0 02 MOV   REG[208],2
3E8A: 52 01    MOV   A,[X+1]
3E8C: 53 B5    MOV   [__r1],A
3E8E: 50 00    MOV   A,0
3E90: 08       PUSH  A
3E91: 51 B5    MOV   A,[__r1]
3E93: 08       PUSH  A
3E94: 50 00    MOV   A,0
3E96: 08       PUSH  A
3E97: 50 0C    MOV   A,12
3E99: 08       PUSH  A
3E9A: 7C 56 FD LCALL __mul16
3E9D: 38 FC    ADD   SP,252
3E9F: 51 AC    MOV   A,[__rX]
3EA1: 53 B5    MOV   [__r1],A
3EA3: 51 AB    MOV   A,[__rY]
3EA5: 53 B6    MOV   [__r0],A
3EA7: 06 B5 0B ADD   [__r1],11
3EAA: 0E B6 00 ADC   [__r0],0
3EAD: 55 B3 EB MOV   [__r3],235
3EB0: 55 B4 00 MOV   [__r2],0
3EB3: 51 B6    MOV   A,[__r0]
3EB5: 60 D4    MOV   REG[212],A
3EB7: 51 B4    MOV   A,[__r2]
3EB9: 60 D5    MOV   REG[213],A
3EBB: 10       PUSH  X
3EBC: 57 0C    MOV   X,12
3EBE: 62 D0 02 MOV   REG[208],2
3EC1: 3E B5    MVI   A,[__r1]
3EC3: 3F B3    MVI   [__r3],A
3EC5: 79       DEC   X
3EC6: BF F7    JNZ   0x3EBE
3EC8: 20       POP   X
(0455) 							Adjust_Dds_Gain(bBand);
3EC9: 52 01    MOV   A,[X+1]
3ECB: 08       PUSH  A
3ECC: 7C 25 35 LCALL _Adjust_Dds_Gain
3ECF: 38 FF    ADD   SP,255
(0456) 						}
(0457) 						DDS_Set(dwCurrentFreq);
3ED1: 52 03    MOV   A,[X+3]
3ED3: 08       PUSH  A
3ED4: 52 04    MOV   A,[X+4]
3ED6: 08       PUSH  A
3ED7: 52 05    MOV   A,[X+5]
3ED9: 08       PUSH  A
3EDA: 52 06    MOV   A,[X+6]
3EDC: 08       PUSH  A
3EDD: 7C 28 DC LCALL _DDS_Set
3EE0: 38 FC    ADD   SP,252
(0458) 						break;
3EE2: 81 0F    JMP   0x3FF2
(0459) 
(0460) 					case KBD_2xDWN:
(0461) 					case KBD_DWN:
(0462) 						if (bMode == MODE_OFF)
3EE4: 3D 02 04 CMP   [X+2],4
3EE7: B0 03    JNZ   0x3EEB
(0463) 							break;
3EE9: 81 08    JMP   0x3FF2
(0464) 
(0465) 										// Moves frequency cursor
(0466) 						if (bFrChMode==TRUE)
3EEB: 3D 07 01 CMP   [X+7],1
3EEE: B0 0F    JNZ   0x3EFE
(0467) 						{
(0468) 							if (bIncCtl == 0)
3EF0: 3D 08 00 CMP   [X+8],0
3EF3: B0 06    JNZ   0x3EFA
(0469) 								bIncCtl = MAX_INCREMENT-1;
3EF5: 56 08 06 MOV   [X+8],6
3EF8: 80 F9    JMP   0x3FF2
(0470) 							else
(0471) 								bIncCtl--;
3EFA: 7B 08    DEC   [X+8]
(0472) 							break;
3EFC: 80 F5    JMP   0x3FF2
(0473) 						}
(0474) 										// Decreases frequency
(0475) 						dwNewFreq = dwCurrentFreq-gxIncrementControl[bIncCtl].dwIncrement;
3EFE: 62 D0 02 MOV   REG[208],2
3F01: 52 08    MOV   A,[X+8]
3F03: 53 B5    MOV   [__r1],A
3F05: 50 00    MOV   A,0
3F07: 08       PUSH  A
3F08: 51 B5    MOV   A,[__r1]
3F0A: 08       PUSH  A
3F0B: 50 00    MOV   A,0
3F0D: 08       PUSH  A
3F0E: 50 05    MOV   A,5
3F10: 08       PUSH  A
3F11: 7C 56 FD LCALL __mul16
3F14: 38 FC    ADD   SP,252
3F16: 51 AC    MOV   A,[__rX]
3F18: 53 B5    MOV   [__r1],A
3F1A: 51 AB    MOV   A,[__rY]
3F1C: 53 B6    MOV   [__r0],A
3F1E: 06 B5 EF ADD   [__r1],239
3F21: 0E B6 02 ADC   [__r0],2
3F24: 51 B6    MOV   A,[__r0]
3F26: 10       PUSH  X
3F27: 08       PUSH  A
3F28: 58 B5    MOV   X,[__r1]
3F2A: 28       ROMX  
3F2B: 53 B6    MOV   [__r0],A
3F2D: 18       POP   A
3F2E: 75       INC   X
3F2F: 09 00    ADC   A,0
3F31: 08       PUSH  A
3F32: 28       ROMX  
3F33: 53 B5    MOV   [__r1],A
3F35: 18       POP   A
3F36: 75       INC   X
3F37: 09 00    ADC   A,0
3F39: 08       PUSH  A
3F3A: 28       ROMX  
3F3B: 53 B4    MOV   [__r2],A
3F3D: 18       POP   A
3F3E: 75       INC   X
3F3F: 09 00    ADC   A,0
3F41: 28       ROMX  
3F42: 53 B3    MOV   [__r3],A
3F44: 20       POP   X
3F45: 52 06    MOV   A,[X+6]
3F47: 12 B3    SUB   A,[__r3]
3F49: 54 1B    MOV   [X+27],A
3F4B: 52 05    MOV   A,[X+5]
3F4D: 1A B4    SBB   A,[__r2]
3F4F: 54 1A    MOV   [X+26],A
3F51: 52 04    MOV   A,[X+4]
3F53: 1A B5    SBB   A,[__r1]
3F55: 54 19    MOV   [X+25],A
3F57: 52 03    MOV   A,[X+3]
3F59: 1A B6    SBB   A,[__r0]
3F5B: 54 18    MOV   [X+24],A
(0476) 						bNewBand = GetBand(dwNewFreq);
3F5D: 52 18    MOV   A,[X+24]
3F5F: 08       PUSH  A
3F60: 52 19    MOV   A,[X+25]
3F62: 08       PUSH  A
3F63: 52 1A    MOV   A,[X+26]
3F65: 08       PUSH  A
3F66: 52 1B    MOV   A,[X+27]
3F68: 08       PUSH  A
3F69: 7C 54 82 LCALL _GetBand
3F6C: 38 FC    ADD   SP,252
3F6E: 62 D0 02 MOV   REG[208],2
3F71: 54 17    MOV   [X+23],A
(0477) 						if (bNewBand==-1)
3F73: 3D 17 FF CMP   [X+23],255
3F76: B0 06    JNZ   0x3F7D
(0478) 						{
(0479) 							BUZZ_BeepError();
3F78: 7C 12 A6 LCALL _BUZZ_BeepError
(0480) 							break;
3F7B: 80 76    JMP   0x3FF2
(0481) 						}
(0482) 						dwCurrentFreq = dwNewFreq;
3F7D: 52 18    MOV   A,[X+24]
3F7F: 54 03    MOV   [X+3],A
3F81: 52 19    MOV   A,[X+25]
3F83: 54 04    MOV   [X+4],A
3F85: 52 1A    MOV   A,[X+26]
3F87: 54 05    MOV   [X+5],A
3F89: 52 1B    MOV   A,[X+27]
3F8B: 54 06    MOV   [X+6],A
(0483) 						if (bBand!=bNewBand)
3F8D: 52 01    MOV   A,[X+1]
3F8F: 3B 17    CMP   A,[X+23]
3F91: A0 4F    JZ    0x3FE1
(0484) 						{
(0485) 							bBand = bNewBand;
3F93: 52 17    MOV   A,[X+23]
3F95: 54 01    MOV   [X+1],A
(0486) 							g_xBridgeCorrect = g_xBandCorrFactor[bBand];
3F97: 62 D0 02 MOV   REG[208],2
3F9A: 52 01    MOV   A,[X+1]
3F9C: 53 B5    MOV   [__r1],A
3F9E: 50 00    MOV   A,0
3FA0: 08       PUSH  A
3FA1: 51 B5    MOV   A,[__r1]
3FA3: 08       PUSH  A
3FA4: 50 00    MOV   A,0
3FA6: 08       PUSH  A
3FA7: 50 0C    MOV   A,12
3FA9: 08       PUSH  A
3FAA: 7C 56 FD LCALL __mul16
3FAD: 38 FC    ADD   SP,252
3FAF: 51 AC    MOV   A,[__rX]
3FB1: 53 B5    MOV   [__r1],A
3FB3: 51 AB    MOV   A,[__rY]
3FB5: 53 B6    MOV   [__r0],A
3FB7: 06 B5 0B ADD   [__r1],11
3FBA: 0E B6 00 ADC   [__r0],0
3FBD: 55 B3 EB MOV   [__r3],235
3FC0: 55 B4 00 MOV   [__r2],0
3FC3: 51 B6    MOV   A,[__r0]
3FC5: 60 D4    MOV   REG[212],A
3FC7: 51 B4    MOV   A,[__r2]
3FC9: 60 D5    MOV   REG[213],A
3FCB: 10       PUSH  X
3FCC: 57 0C    MOV   X,12
3FCE: 62 D0 02 MOV   REG[208],2
3FD1: 3E B5    MVI   A,[__r1]
3FD3: 3F B3    MVI   [__r3],A
3FD5: 79       DEC   X
3FD6: BF F7    JNZ   0x3FCE
3FD8: 20       POP   X
(0487) 							Adjust_Dds_Gain(bBand);
3FD9: 52 01    MOV   A,[X+1]
3FDB: 08       PUSH  A
3FDC: 7C 25 35 LCALL _Adjust_Dds_Gain
3FDF: 38 FF    ADD   SP,255
(0488) 						}
(0489) 						DDS_Set(dwCurrentFreq);
3FE1: 52 03    MOV   A,[X+3]
3FE3: 08       PUSH  A
3FE4: 52 04    MOV   A,[X+4]
3FE6: 08       PUSH  A
3FE7: 52 05    MOV   A,[X+5]
3FE9: 08       PUSH  A
3FEA: 52 06    MOV   A,[X+6]
3FEC: 08       PUSH  A
3FED: 7C 28 DC LCALL _DDS_Set
3FF0: 38 FC    ADD   SP,252
(0490) 						break;
(0491) 
(0492) 					default:
(0493) 						break;
(0494) 				}
(0495) 			} while ((bKey==0) && (g_bMeasureCounter!=0));
3FF2: 3D 00 00 CMP   [X+0],0
3FF5: B0 09    JNZ   0x3FFF
3FF7: 62 D0 02 MOV   REG[208],2
3FFA: 3C F1 00 CMP   [g_bMeasureCounter],0
3FFD: BA C1    JNZ   0x3ABF
(0496) 
(0497) 										// Key pressed, resets user iddle timer
(0498) 			if (bKey != 0)
3FFF: 3D 00 00 CMP   [X+0],0
4002: A0 11    JZ    0x4014
(0499) 				g_bIddleCounter = GetUserIddle(g_xConf.bUserIddle);
4004: 62 D0 02 MOV   REG[208],2
4007: 51 EE    MOV   A,[g_xConf+1]
4009: 08       PUSH  A
400A: 7C 54 2F LCALL _GetUserIddle
400D: 38 FF    ADD   SP,255
400F: 62 D0 02 MOV   REG[208],2
4012: 53 F0    MOV   [g_bIddleCounter],A
(0500) 
(0501) 										// Iddle mode
(0502) 			if ((g_bIddleCounter==0) && (GetUserIddle(g_xConf.bUserIddle) != 0))
4014: 62 D0 02 MOV   REG[208],2
4017: 3C F0 00 CMP   [g_bIddleCounter],0
401A: B0 DA    JNZ   0x40F5
401C: 62 D0 02 MOV   REG[208],2
401F: 51 EE    MOV   A,[g_xConf+1]
4021: 08       PUSH  A
4022: 7C 54 2F LCALL _GetUserIddle
4025: 38 FF    ADD   SP,255
4027: 62 D0 02 MOV   REG[208],2
402A: 39 00    CMP   A,0
402C: A0 C8    JZ    0x40F5
(0503) 			{
(0504) 				bFrChMode=FALSE;
402E: 56 07 00 MOV   [X+7],0
(0505) 										// Suspend
(0506) 										// Disables DDS oscillator and backlight (shared port)
(0507) 				DDS_Set(0);				// DDS power down
4031: 50 00    MOV   A,0
4033: 08       PUSH  A
4034: 08       PUSH  A
4035: 08       PUSH  A
4036: 08       PUSH  A
4037: 7C 28 DC LCALL _DDS_Set
403A: 38 FC    ADD   SP,252
(0508) 				XO_EN_Data_ADDR &= ~XO_EN_MASK;
403C: 41 08 7F AND   REG[8],127
(0509) 				Port_2_Data_SHADE &= ~XO_EN_MASK;
403F: 62 D0 00 MOV   REG[208],0
4042: 26 02 7F AND   [2],127
(0510) 
(0511) 				PGA_DDS_1_Stop();
4045: 10       PUSH  X
4046: 7C 0C 95 LCALL 0x0C95
(0512) 				PGA_DDS_2_Stop();
4049: 7C 0C 55 LCALL 0x0C55
(0513) 
(0514) 				ADCINC12_Stop();
404C: 7C 10 29 LCALL 0x1029
(0515) 				PGA_ADC_Stop();
404F: 7C 0C D5 LCALL 0x0CD5
(0516) 
(0517) 				LCD_Init();
4052: 7C 0D EB LCALL 0x0DEB
4055: 20       POP   X
(0518) 				LCD_Control(LCD_OFF);	// Display off
4056: 10       PUSH  X
4057: 50 08    MOV   A,8
4059: 7C 0D 3B LCALL 0x0D3B
405C: 20       POP   X
(0519) 
(0520) 				KEYPAD_SysSuspend();
405D: 7C 33 E4 LCALL _KEYPAD_SysSuspend
(0521) 										// Resumes
(0522) 										// Display on
(0523) 				LCD_Control(LCD_ON_CURSOR);
4060: 10       PUSH  X
4061: 50 0E    MOV   A,14
4063: 7C 0D 3B LCALL 0x0D3B
4066: 20       POP   X
(0524) 
(0525) 										// Enables DDS oscillator and backlight (shared port)
(0526) 				XO_EN_Data_ADDR |= XO_EN_MASK;
4067: 43 08 80 OR    REG[8],128
(0527) 				Port_2_Data_SHADE |= XO_EN_MASK;
406A: 62 D0 00 MOV   REG[208],0
406D: 51 02    MOV   A,[2]
406F: 29 80    OR    A,128
4071: 53 02    MOV   [2],A
(0528) 				Delay_Ms(10);
4073: 50 00    MOV   A,0
4075: 08       PUSH  A
4076: 50 0A    MOV   A,10
4078: 08       PUSH  A
4079: 7C 53 01 LCALL _Delay_Ms
(0529) 				XO_EN_Data_ADDR &= ~XO_EN_MASK;
407C: 41 08 7F AND   REG[8],127
(0530) 				Port_2_Data_SHADE &= ~XO_EN_MASK;
407F: 62 D0 00 MOV   REG[208],0
4082: 26 02 7F AND   [2],127
(0531) 				Delay_Ms(10);
4085: 50 00    MOV   A,0
4087: 08       PUSH  A
4088: 50 0A    MOV   A,10
408A: 08       PUSH  A
408B: 7C 53 01 LCALL _Delay_Ms
408E: 38 FC    ADD   SP,252
(0532) 				XO_EN_Data_ADDR |= XO_EN_MASK;
4090: 43 08 80 OR    REG[8],128
(0533) 				Port_2_Data_SHADE |= XO_EN_MASK;
4093: 62 D0 00 MOV   REG[208],0
4096: 51 02    MOV   A,[2]
4098: 29 80    OR    A,128
409A: 53 02    MOV   [2],A
(0534) 				Delay_Ms(10);
409C: 50 00    MOV   A,0
409E: 08       PUSH  A
409F: 50 0A    MOV   A,10
40A1: 08       PUSH  A
40A2: 7C 53 01 LCALL _Delay_Ms
(0535) 
(0536) 				DDS_Init();
40A5: 7C 28 BC LCALL _DDS_Init
(0537) 
(0538) 				g_bIddleCounter = GetUserIddle(g_xConf.bUserIddle);
40A8: 62 D0 02 MOV   REG[208],2
40AB: 51 EE    MOV   A,[g_xConf+1]
40AD: 08       PUSH  A
40AE: 7C 54 2F LCALL _GetUserIddle
40B1: 38 FD    ADD   SP,253
40B3: 62 D0 02 MOV   REG[208],2
40B6: 53 F0    MOV   [g_bIddleCounter],A
(0539) 
(0540) 				if (bMode != MODE_OFF)
40B8: 3D 02 04 CMP   [X+2],4
40BB: A0 28    JZ    0x40E4
(0541) 				{
(0542) 					DDS_Set(dwCurrentFreq);
40BD: 52 03    MOV   A,[X+3]
40BF: 08       PUSH  A
40C0: 52 04    MOV   A,[X+4]
40C2: 08       PUSH  A
40C3: 52 05    MOV   A,[X+5]
40C5: 08       PUSH  A
40C6: 52 06    MOV   A,[X+6]
40C8: 08       PUSH  A
40C9: 7C 28 DC LCALL _DDS_Set
40CC: 38 FC    ADD   SP,252
(0543) 					PGA_DDS_1_Start(PGA_DDS_1_HIGHPOWER);
40CE: 10       PUSH  X
40CF: 50 03    MOV   A,3
40D1: 7C 0C 59 LCALL 0x0C59
40D4: 20       POP   X
(0544) 					PGA_DDS_2_Start(PGA_DDS_2_HIGHPOWER);
40D5: 10       PUSH  X
40D6: 50 03    MOV   A,3
40D8: 7C 0C 19 LCALL 0x0C19
40DB: 20       POP   X
(0545) 					Adjust_Dds_Gain(bBand);
40DC: 52 01    MOV   A,[X+1]
40DE: 08       PUSH  A
40DF: 7C 25 35 LCALL _Adjust_Dds_Gain
40E2: 38 FF    ADD   SP,255
(0546) 				}
(0547) 				ADCINC12_Start(ADCINC12_HIGHPOWER); // Turn on Analog section
40E4: 10       PUSH  X
40E5: 50 03    MOV   A,3
40E7: 7C 10 15 LCALL 0x1015
40EA: 20       POP   X
(0548) 				PGA_ADC_Start(PGA_ADC_HIGHPOWER);
40EB: 10       PUSH  X
40EC: 50 03    MOV   A,3
40EE: 7C 0C 99 LCALL 0x0C99
40F1: 20       POP   X
(0549) 				bKey = 1;				// Forces exit loop
40F2: 56 00 01 MOV   [X+0],1
(0550) 			}
(0551) 		} while (bKey==0);
40F5: 3D 00 00 CMP   [X+0],0
40F8: B0 04    JNZ   0x40FD
40FA: 7D 37 3F LJMP  0x373F
(0552) 	} while (TRUE);
40FD: 7D 36 D6 LJMP  0x36D6
4100: 38 E2    ADD   SP,226
4102: 20       POP   X
4103: 8F FF    JMP   0x4103
(0553) }
(0554) 
(0555) //-----------------------------------------------------------------------------
(0556) //  FUNCTION NAME:	Mode_Scan
(0557) //
(0558) //  DESCRIPTION:
(0559) //
(0560) //	Scanning routine
(0561) //
(0562) //  ARGUMENTS:
(0563) //  	bBand	Integer describing band number
(0564) //		bStep	Integer describing frequency step value
(0565) //
(0566) //  RETURNS:
(0567) //     Resonance frequency. (-1) if not found
(0568) //
(0569) //-----------------------------------------------------------------------------
(0570) static DWORD Mode_Scan (BYTE bBand, BYTE bStep)
(0571) {
_Mode_Scan:
  bKey                 --> X+22
  dwResonanceFreq      --> X+18
  dwBwMaxFreq          --> X+14
  dwLimitFreq          --> X+10
  dwBwMinFreq          --> X+6
  wSwrMin              --> X+4
  dwCurrentFreq        --> X+0
  bStep                --> X-5
  bBand                --> X-4
4105: 10       PUSH  X
4106: 4F       MOV   X,SP
4107: 38 17    ADD   SP,23
(0572) 	DWORD dwCurrentFreq;
(0573) 	DWORD dwLimitFreq;
(0574) 	DWORD dwResonanceFreq = -1;
4109: 56 12 FF MOV   [X+18],255
410C: 56 13 FF MOV   [X+19],255
410F: 56 14 FF MOV   [X+20],255
4112: 56 15 FF MOV   [X+21],255
(0575) 	DWORD dwBwMinFreq = -1;
4115: 56 06 FF MOV   [X+6],255
4118: 56 07 FF MOV   [X+7],255
411B: 56 08 FF MOV   [X+8],255
411E: 56 09 FF MOV   [X+9],255
(0576) 	DWORD dwBwMaxFreq = -1;
4121: 56 0E FF MOV   [X+14],255
4124: 56 0F FF MOV   [X+15],255
4127: 56 10 FF MOV   [X+16],255
412A: 56 11 FF MOV   [X+17],255
(0577) 	WORD wSwrMin = SWR_BANDWIDTH;
412D: 56 05 C8 MOV   [X+5],200
4130: 56 04 00 MOV   [X+4],0
(0578) 	BYTE bKey;
(0579) 
(0580) 										// Display mode
(0581) 	DISP_Clear();
4133: 7C 32 83 LCALL _DISP_Clear
(0582) 	LCD_Position(ROW_MODE, COL_MODE);
4136: 10       PUSH  X
4137: 50 00    MOV   A,0
4139: 5C       MOV   X,A
413A: 7C 0E 5E LCALL 0x0E5E
413D: 20       POP   X
(0583) 	LCD_PrCString(gModeScanStr);
413E: 10       PUSH  X
413F: 50 03    MOV   A,3
4141: 08       PUSH  A
4142: 50 F8    MOV   A,248
4144: 5C       MOV   X,A
4145: 18       POP   A
4146: 7C 0C D9 LCALL 0x0CD9
4149: 20       POP   X
(0584) 
(0585) 										// Set frequency limits
(0586) 	dwCurrentFreq = g_xBandLimits[bBand].low * BAND_FREQ_MULT;
414A: 62 D0 02 MOV   REG[208],2
414D: 52 FC    MOV   A,[X-4]
414F: 53 B5    MOV   [__r1],A
4151: 50 00    MOV   A,0
4153: 08       PUSH  A
4154: 51 B5    MOV   A,[__r1]
4156: 08       PUSH  A
4157: 50 00    MOV   A,0
4159: 08       PUSH  A
415A: 50 06    MOV   A,6
415C: 08       PUSH  A
415D: 7C 56 FD LCALL __mul16
4160: 38 FC    ADD   SP,252
4162: 51 AC    MOV   A,[__rX]
4164: 53 B5    MOV   [__r1],A
4166: 51 AB    MOV   A,[__rY]
4168: 53 B6    MOV   [__r0],A
416A: 06 B5 C2 ADD   [__r1],194
416D: 0E B6 01 ADC   [__r0],1
4170: 51 B6    MOV   A,[__r0]
4172: 10       PUSH  X
4173: 08       PUSH  A
4174: 58 B5    MOV   X,[__r1]
4176: 28       ROMX  
4177: 53 B6    MOV   [__r0],A
4179: 18       POP   A
417A: 75       INC   X
417B: 09 00    ADC   A,0
417D: 28       ROMX  
417E: 20       POP   X
417F: 53 B3    MOV   [__r3],A
4181: 51 B6    MOV   A,[__r0]
4183: 53 B4    MOV   [__r2],A
4185: 50 00    MOV   A,0
4187: 08       PUSH  A
4188: 08       PUSH  A
4189: 51 B4    MOV   A,[__r2]
418B: 08       PUSH  A
418C: 51 B3    MOV   A,[__r3]
418E: 08       PUSH  A
418F: 50 00    MOV   A,0
4191: 08       PUSH  A
4192: 50 01    MOV   A,1
4194: 08       PUSH  A
4195: 50 86    MOV   A,134
4197: 08       PUSH  A
4198: 50 A0    MOV   A,160
419A: 08       PUSH  A
419B: 7C 57 3B LCALL __mul_32X32_32
419E: 38 FC    ADD   SP,252
41A0: 18       POP   A
41A1: 53 B3    MOV   [__r3],A
41A3: 18       POP   A
41A4: 53 B4    MOV   [__r2],A
41A6: 18       POP   A
41A7: 53 B5    MOV   [__r1],A
41A9: 18       POP   A
41AA: 54 00    MOV   [X+0],A
41AC: 51 B5    MOV   A,[__r1]
41AE: 54 01    MOV   [X+1],A
41B0: 51 B4    MOV   A,[__r2]
41B2: 54 02    MOV   [X+2],A
41B4: 51 B3    MOV   A,[__r3]
41B6: 54 03    MOV   [X+3],A
(0587) 	dwLimitFreq = g_xBandLimits[bBand].high * BAND_FREQ_MULT;
41B8: 52 FC    MOV   A,[X-4]
41BA: 53 B5    MOV   [__r1],A
41BC: 50 00    MOV   A,0
41BE: 08       PUSH  A
41BF: 51 B5    MOV   A,[__r1]
41C1: 08       PUSH  A
41C2: 50 00    MOV   A,0
41C4: 08       PUSH  A
41C5: 50 06    MOV   A,6
41C7: 08       PUSH  A
41C8: 7C 56 FD LCALL __mul16
41CB: 38 FC    ADD   SP,252
41CD: 51 AC    MOV   A,[__rX]
41CF: 53 B5    MOV   [__r1],A
41D1: 51 AB    MOV   A,[__rY]
41D3: 53 B6    MOV   [__r0],A
41D5: 06 B5 C6 ADD   [__r1],198
41D8: 0E B6 01 ADC   [__r0],1
41DB: 51 B6    MOV   A,[__r0]
41DD: 10       PUSH  X
41DE: 08       PUSH  A
41DF: 58 B5    MOV   X,[__r1]
41E1: 28       ROMX  
41E2: 53 B6    MOV   [__r0],A
41E4: 18       POP   A
41E5: 75       INC   X
41E6: 09 00    ADC   A,0
41E8: 28       ROMX  
41E9: 20       POP   X
41EA: 53 B3    MOV   [__r3],A
41EC: 51 B6    MOV   A,[__r0]
41EE: 53 B4    MOV   [__r2],A
41F0: 50 00    MOV   A,0
41F2: 08       PUSH  A
41F3: 08       PUSH  A
41F4: 51 B4    MOV   A,[__r2]
41F6: 08       PUSH  A
41F7: 51 B3    MOV   A,[__r3]
41F9: 08       PUSH  A
41FA: 50 00    MOV   A,0
41FC: 08       PUSH  A
41FD: 50 01    MOV   A,1
41FF: 08       PUSH  A
4200: 50 86    MOV   A,134
4202: 08       PUSH  A
4203: 50 A0    MOV   A,160
4205: 08       PUSH  A
4206: 7C 57 3B LCALL __mul_32X32_32
4209: 38 FC    ADD   SP,252
420B: 18       POP   A
420C: 53 B3    MOV   [__r3],A
420E: 18       POP   A
420F: 53 B4    MOV   [__r2],A
4211: 18       POP   A
4212: 53 B5    MOV   [__r1],A
4214: 18       POP   A
4215: 54 0A    MOV   [X+10],A
4217: 51 B5    MOV   A,[__r1]
4219: 54 0B    MOV   [X+11],A
421B: 51 B4    MOV   A,[__r2]
421D: 54 0C    MOV   [X+12],A
421F: 51 B3    MOV   A,[__r3]
4221: 54 0D    MOV   [X+13],A
(0588) 	do
(0589) 	{
(0590) 										// Set frequency, measures, and calculate impedance
(0591) 		DDS_Set(dwCurrentFreq);
4223: 52 00    MOV   A,[X+0]
4225: 08       PUSH  A
4226: 52 01    MOV   A,[X+1]
4228: 08       PUSH  A
4229: 52 02    MOV   A,[X+2]
422B: 08       PUSH  A
422C: 52 03    MOV   A,[X+3]
422E: 08       PUSH  A
422F: 7C 28 DC LCALL _DDS_Set
4232: 38 FC    ADD   SP,252
(0592) 		LCD_Position(ROW_FREQ, COL_FREQ);
4234: 10       PUSH  X
4235: 57 06    MOV   X,6
4237: 50 00    MOV   A,0
4239: 7C 0E 5E LCALL 0x0E5E
423C: 20       POP   X
(0593) 		DISP_Frequency(dwCurrentFreq);
423D: 52 00    MOV   A,[X+0]
423F: 08       PUSH  A
4240: 52 01    MOV   A,[X+1]
4242: 08       PUSH  A
4243: 52 02    MOV   A,[X+2]
4245: 08       PUSH  A
4246: 52 03    MOV   A,[X+3]
4248: 08       PUSH  A
4249: 7C 2E E8 LCALL _DISP_Frequency
(0594) 
(0595) 		Do_Measure();
424C: 7C 47 0E LCALL _Do_Measure
(0596) 		Do_Correct();
424F: 7C 23 F1 LCALL _Do_Correct
(0597) 
(0598) 		gwSwr = Calculate_Swr(g_xBridgeMeasure.Vf, g_xBridgeMeasure.Vr);
4252: 62 D0 02 MOV   REG[208],2
4255: 51 90    MOV   A,[144]
4257: 08       PUSH  A
4258: 51 91    MOV   A,[145]
425A: 08       PUSH  A
425B: 51 92    MOV   A,[146]
425D: 08       PUSH  A
425E: 51 93    MOV   A,[147]
4260: 08       PUSH  A
4261: 51 8C    MOV   A,[g_xBridgeMeasure]
4263: 08       PUSH  A
4264: 51 8D    MOV   A,[g_xBridgeMeasure+1]
4266: 08       PUSH  A
4267: 51 8E    MOV   A,[g_xBridgeMeasure+2]
4269: 08       PUSH  A
426A: 51 8F    MOV   A,[g_xBridgeMeasure+3]
426C: 08       PUSH  A
426D: 7C 12 F0 LCALL _Calculate_Swr
4270: 38 F4    ADD   SP,244
4272: 62 D0 02 MOV   REG[208],2
4275: 51 B5    MOV   A,[__r1]
4277: 08       PUSH  A
4278: 51 B6    MOV   A,[__r0]
427A: 62 D0 02 MOV   REG[208],2
427D: 53 EB    MOV   [gwSwr],A
427F: 18       POP   A
4280: 53 EC    MOV   [gwSwr+1],A
(0599) 		LCD_Position(ROW_SWR, 0);
4282: 10       PUSH  X
4283: 57 00    MOV   X,0
4285: 50 01    MOV   A,1
4287: 7C 0E 5E LCALL 0x0E5E
428A: 20       POP   X
(0600) 		LCD_PrCString(gBlankStr);
428B: 10       PUSH  X
428C: 50 03    MOV   A,3
428E: 08       PUSH  A
428F: 50 11    MOV   A,17
4291: 5C       MOV   X,A
4292: 18       POP   A
4293: 7C 0C D9 LCALL 0x0CD9
4296: 20       POP   X
(0601) 
(0602) 		LCD_Position(ROW_SWR, COL_SWR);
4297: 10       PUSH  X
4298: 57 00    MOV   X,0
429A: 50 01    MOV   A,1
429C: 7C 0E 5E LCALL 0x0E5E
429F: 20       POP   X
(0603) 		DISP_Swr(gwSwr);
42A0: 62 D0 02 MOV   REG[208],2
42A3: 51 EB    MOV   A,[gwSwr]
42A5: 08       PUSH  A
42A6: 51 EC    MOV   A,[gwSwr+1]
42A8: 08       PUSH  A
42A9: 7C 30 4B LCALL _DISP_Swr
42AC: 38 FE    ADD   SP,254
(0604) 										// Code to detect 2.0 SWR limits
(0605) 		if (gwSwr <= SWR_BANDWIDTH)
42AE: 62 D0 02 MOV   REG[208],2
42B1: 50 C8    MOV   A,200
42B3: 12 EC    SUB   A,[gwSwr+1]
42B5: 50 00    MOV   A,0
42B7: 1A EB    SBB   A,[gwSwr]
42B9: C0 38    JC    0x42F2
(0606) 		{
(0607) 			if (dwBwMinFreq==-1)
42BB: 3D 06 FF CMP   [X+6],255
42BE: B0 7C    JNZ   0x433B
42C0: 3D 07 FF CMP   [X+7],255
42C3: B0 77    JNZ   0x433B
42C5: 3D 08 FF CMP   [X+8],255
42C8: B0 72    JNZ   0x433B
42CA: 3D 09 FF CMP   [X+9],255
42CD: B0 6D    JNZ   0x433B
(0608) 			{
(0609) 				BUZZ_Beep();
42CF: 7C 12 76 LCALL _BUZZ_Beep
(0610) 				Delay_Ms(50);
42D2: 50 00    MOV   A,0
42D4: 08       PUSH  A
42D5: 50 32    MOV   A,50
42D7: 08       PUSH  A
42D8: 7C 53 01 LCALL _Delay_Ms
42DB: 38 FE    ADD   SP,254
(0611) 				BUZZ_Beep();
42DD: 7C 12 76 LCALL _BUZZ_Beep
(0612) 				dwBwMinFreq = dwCurrentFreq;
42E0: 52 00    MOV   A,[X+0]
42E2: 54 06    MOV   [X+6],A
42E4: 52 01    MOV   A,[X+1]
42E6: 54 07    MOV   [X+7],A
42E8: 52 02    MOV   A,[X+2]
42EA: 54 08    MOV   [X+8],A
42EC: 52 03    MOV   A,[X+3]
42EE: 54 09    MOV   [X+9],A
(0613) 			}
(0614) 		}
42F0: 80 4A    JMP   0x433B
(0615) 		else
(0616) 		{
(0617) 			if ((dwBwMinFreq!=-1)&&(dwBwMaxFreq==-1))
42F2: 3D 06 FF CMP   [X+6],255
42F5: B0 10    JNZ   0x4306
42F7: 3D 07 FF CMP   [X+7],255
42FA: B0 0B    JNZ   0x4306
42FC: 3D 08 FF CMP   [X+8],255
42FF: B0 06    JNZ   0x4306
4301: 3D 09 FF CMP   [X+9],255
4304: A0 36    JZ    0x433B
4306: 3D 0E FF CMP   [X+14],255
4309: B0 31    JNZ   0x433B
430B: 3D 0F FF CMP   [X+15],255
430E: B0 2C    JNZ   0x433B
4310: 3D 10 FF CMP   [X+16],255
4313: B0 27    JNZ   0x433B
4315: 3D 11 FF CMP   [X+17],255
4318: B0 22    JNZ   0x433B
(0618) 			{
(0619) 				BUZZ_Beep();
431A: 7C 12 76 LCALL _BUZZ_Beep
(0620) 				Delay_Ms(50);
431D: 50 00    MOV   A,0
431F: 08       PUSH  A
4320: 50 32    MOV   A,50
4322: 08       PUSH  A
4323: 7C 53 01 LCALL _Delay_Ms
4326: 38 FE    ADD   SP,254
(0621) 				BUZZ_Beep();
4328: 7C 12 76 LCALL _BUZZ_Beep
(0622) 				dwBwMaxFreq = dwCurrentFreq;
432B: 52 00    MOV   A,[X+0]
432D: 54 0E    MOV   [X+14],A
432F: 52 01    MOV   A,[X+1]
4331: 54 0F    MOV   [X+15],A
4333: 52 02    MOV   A,[X+2]
4335: 54 10    MOV   [X+16],A
4337: 52 03    MOV   A,[X+3]
4339: 54 11    MOV   [X+17],A
(0623) 			}
(0624) 		}
(0625) 		if (gwSwr <= wSwrMin)
433B: 62 D0 02 MOV   REG[208],2
433E: 52 05    MOV   A,[X+5]
4340: 12 EC    SUB   A,[gwSwr+1]
4342: 52 04    MOV   A,[X+4]
4344: 1A EB    SBB   A,[gwSwr]
4346: C0 1C    JC    0x4363
(0626) 		{
(0627) 			dwResonanceFreq = dwCurrentFreq;
4348: 52 00    MOV   A,[X+0]
434A: 54 12    MOV   [X+18],A
434C: 52 01    MOV   A,[X+1]
434E: 54 13    MOV   [X+19],A
4350: 52 02    MOV   A,[X+2]
4352: 54 14    MOV   [X+20],A
4354: 52 03    MOV   A,[X+3]
4356: 54 15    MOV   [X+21],A
(0628) 			wSwrMin = gwSwr;
4358: 62 D0 02 MOV   REG[208],2
435B: 51 EC    MOV   A,[gwSwr+1]
435D: 54 05    MOV   [X+5],A
435F: 51 EB    MOV   A,[gwSwr]
4361: 54 04    MOV   [X+4],A
(0629) 		}
(0630) 		dwCurrentFreq += GetStep(bStep);
4363: 52 FB    MOV   A,[X-5]
4365: 08       PUSH  A
4366: 7C 53 99 LCALL _GetStep
4369: 38 FF    ADD   SP,255
436B: 62 D0 02 MOV   REG[208],2
436E: 51 B3    MOV   A,[__r3]
4370: 05 03    ADD   [X+3],A
4372: 51 B4    MOV   A,[__r2]
4374: 0D 02    ADC   [X+2],A
4376: 51 B5    MOV   A,[__r1]
4378: 0D 01    ADC   [X+1],A
437A: 51 B6    MOV   A,[__r0]
437C: 0D 00    ADC   [X+0],A
(0631) 
(0632) 		if (KEYPAD_Get()==KBD_UP)		// Cancel
437E: 7C 32 8B LCALL _KEYPAD_Get
4381: 62 D0 02 MOV   REG[208],2
4384: 39 05    CMP   A,5
4386: B0 1D    JNZ   0x43A4
(0633) 		{
(0634) 			DDS_Set(0);
4388: 50 00    MOV   A,0
438A: 08       PUSH  A
438B: 08       PUSH  A
438C: 08       PUSH  A
438D: 08       PUSH  A
438E: 7C 28 DC LCALL _DDS_Set
4391: 38 FC    ADD   SP,252
(0635) 			return-1;
4393: 62 D0 02 MOV   REG[208],2
4396: 55 B6 FF MOV   [__r0],255
4399: 55 B5 FF MOV   [__r1],255
439C: 55 B4 FF MOV   [__r2],255
439F: 55 B3 FF MOV   [__r3],255
43A2: 80 E7    JMP   0x448A
(0636) 		}
(0637) 	} while (dwCurrentFreq < dwLimitFreq);
43A4: 52 03    MOV   A,[X+3]
43A6: 13 0D    SUB   A,[X+13]
43A8: 52 02    MOV   A,[X+2]
43AA: 1B 0C    SBB   A,[X+12]
43AC: 52 01    MOV   A,[X+1]
43AE: 1B 0B    SBB   A,[X+11]
43B0: 52 00    MOV   A,[X+0]
43B2: 1B 0A    SBB   A,[X+10]
43B4: CE 6E    JC    0x4223
(0638) 
(0639) 										// End of scanning
(0640) 	DDS_Set(0);
43B6: 50 00    MOV   A,0
43B8: 08       PUSH  A
43B9: 08       PUSH  A
43BA: 08       PUSH  A
43BB: 08       PUSH  A
43BC: 7C 28 DC LCALL _DDS_Set
43BF: 38 FC    ADD   SP,252
(0641) 	BUZZ_Beep();
43C1: 7C 12 76 LCALL _BUZZ_Beep
(0642) 	DISP_Clear();
43C4: 7C 32 83 LCALL _DISP_Clear
(0643) 	LCD_Position(0, 0);
43C7: 10       PUSH  X
43C8: 50 00    MOV   A,0
43CA: 5C       MOV   X,A
43CB: 7C 0E 5E LCALL 0x0E5E
43CE: 20       POP   X
(0644) 	if (dwResonanceFreq==-1)
43CF: 3D 12 FF CMP   [X+18],255
43D2: B0 1E    JNZ   0x43F1
43D4: 3D 13 FF CMP   [X+19],255
43D7: B0 19    JNZ   0x43F1
43D9: 3D 14 FF CMP   [X+20],255
43DC: B0 14    JNZ   0x43F1
43DE: 3D 15 FF CMP   [X+21],255
43E1: B0 0F    JNZ   0x43F1
(0645) 	{
(0646) 		LCD_PrCString(gErrNoMatchingStr);
43E3: 10       PUSH  X
43E4: 50 04    MOV   A,4
43E6: 08       PUSH  A
43E7: 50 BA    MOV   A,186
43E9: 5C       MOV   X,A
43EA: 18       POP   A
43EB: 7C 0C D9 LCALL 0x0CD9
43EE: 20       POP   X
(0647) 	}
43EF: 80 6A    JMP   0x445A
(0648) 	else
(0649) 	{
(0650) 		if (dwBwMaxFreq==-1)
43F1: 3D 0E FF CMP   [X+14],255
43F4: B0 20    JNZ   0x4415
43F6: 3D 0F FF CMP   [X+15],255
43F9: B0 1B    JNZ   0x4415
43FB: 3D 10 FF CMP   [X+16],255
43FE: B0 16    JNZ   0x4415
4400: 3D 11 FF CMP   [X+17],255
4403: B0 11    JNZ   0x4415
(0651) 			dwBwMaxFreq = dwCurrentFreq;
4405: 52 00    MOV   A,[X+0]
4407: 54 0E    MOV   [X+14],A
4409: 52 01    MOV   A,[X+1]
440B: 54 0F    MOV   [X+15],A
440D: 52 02    MOV   A,[X+2]
440F: 54 10    MOV   [X+16],A
4411: 52 03    MOV   A,[X+3]
4413: 54 11    MOV   [X+17],A
(0652) 
(0653) 										// Display bandwidth
(0654) 		LCD_Position(ROW_MODE, COL_MODE);
4415: 10       PUSH  X
4416: 50 00    MOV   A,0
4418: 5C       MOV   X,A
4419: 7C 0E 5E LCALL 0x0E5E
441C: 20       POP   X
(0655) 		LCD_PrCString(gBandWidthStr);
441D: 10       PUSH  X
441E: 50 04    MOV   A,4
4420: 08       PUSH  A
4421: 50 CA    MOV   A,202
4423: 5C       MOV   X,A
4424: 18       POP   A
4425: 7C 0C D9 LCALL 0x0CD9
4428: 20       POP   X
(0656) 		LCD_Position(ROW_FREQ, COL_FREQ);
4429: 10       PUSH  X
442A: 57 06    MOV   X,6
442C: 50 00    MOV   A,0
442E: 7C 0E 5E LCALL 0x0E5E
4431: 20       POP   X
(0657) 		DISP_Frequency(dwBwMaxFreq-dwBwMinFreq);
4432: 62 D0 02 MOV   REG[208],2
4435: 52 11    MOV   A,[X+17]
4437: 13 09    SUB   A,[X+9]
4439: 53 B3    MOV   [__r3],A
443B: 52 10    MOV   A,[X+16]
443D: 1B 08    SBB   A,[X+8]
443F: 53 B4    MOV   [__r2],A
4441: 52 0F    MOV   A,[X+15]
4443: 1B 07    SBB   A,[X+7]
4445: 53 B5    MOV   [__r1],A
4447: 52 0E    MOV   A,[X+14]
4449: 1B 06    SBB   A,[X+6]
444B: 08       PUSH  A
444C: 51 B5    MOV   A,[__r1]
444E: 08       PUSH  A
444F: 51 B4    MOV   A,[__r2]
4451: 08       PUSH  A
4452: 51 B3    MOV   A,[__r3]
4454: 08       PUSH  A
4455: 7C 2E E8 LCALL _DISP_Frequency
4458: 38 FC    ADD   SP,252
(0658) 	}
(0659) 										// Wait user action or timeout
(0660) 	LCD_Position(1, 0);
445A: 10       PUSH  X
445B: 57 00    MOV   X,0
445D: 50 01    MOV   A,1
445F: 7C 0E 5E LCALL 0x0E5E
4462: 20       POP   X
(0661) 	LCD_PrCString(gPressAnyKeyStr);
4463: 10       PUSH  X
4464: 50 04    MOV   A,4
4466: 08       PUSH  A
4467: 50 8F    MOV   A,143
4469: 5C       MOV   X,A
446A: 18       POP   A
446B: 7C 0C D9 LCALL 0x0CD9
446E: 20       POP   X
(0662) 	KEYPAD_WaitKey(TIME_WAIT_KEY_S);
446F: 50 1E    MOV   A,30
4471: 08       PUSH  A
4472: 7C 33 12 LCALL _KEYPAD_WaitKey
4475: 38 FF    ADD   SP,255
4477: 62 D0 02 MOV   REG[208],2
(0663) 
(0664) 	return dwResonanceFreq;
447A: 52 12    MOV   A,[X+18]
447C: 53 B6    MOV   [__r0],A
447E: 52 13    MOV   A,[X+19]
4480: 53 B5    MOV   [__r1],A
4482: 52 14    MOV   A,[X+20]
4484: 53 B4    MOV   [__r2],A
4486: 52 15    MOV   A,[X+21]
4488: 53 B3    MOV   [__r3],A
448A: 38 E9    ADD   SP,233
448C: 20       POP   X
448D: 7F       RET   
(0665) }
(0666) 
(0667) //-----------------------------------------------------------------------------
(0668) //  FUNCTION NAME:	Mode_Config
(0669) //
(0670) //  DESCRIPTION:
(0671) //
(0672) //	Configuration routine
(0673) //
(0674) //  ARGUMENTS:
(0675) //     none.
(0676) //
(0677) //  RETURNS:
(0678) //     none.
(0679) //
(0680) //-----------------------------------------------------------------------------
(0681) static void Mode_Config (void)
(0682) {
_Mode_Config:
  bUserIddle           --> X+3
  bStep                --> X+2
  bMenu                --> X+1
  bKey                 --> X+0
448E: 10       PUSH  X
448F: 4F       MOV   X,SP
4490: 38 06    ADD   SP,6
(0683) 	BYTE bMenu = 0;
4492: 56 01 00 MOV   [X+1],0
(0684) 	BYTE bKey;
(0685) 	BYTE bStep;
(0686) 	BYTE bUserIddle;
(0687) 
(0688) 	do
(0689) 	{
(0690) 										// Main configuration menu
(0691) 		DISP_Clear();
4495: 7C 32 83 LCALL _DISP_Clear
(0692) 		LCD_Position(0, 0);
4498: 10       PUSH  X
4499: 50 00    MOV   A,0
449B: 5C       MOV   X,A
449C: 7C 0E 5E LCALL 0x0E5E
449F: 20       POP   X
(0693) 		LCD_PrCString(gConfigStr[bMenu]);
44A0: 62 D0 02 MOV   REG[208],2
44A3: 52 01    MOV   A,[X+1]
44A5: 53 B5    MOV   [__r1],A
44A7: 55 B6 00 MOV   [__r0],0
44AA: 65 B5    ASL   [__r1]
44AC: 6B B6    RLC   [__r0]
44AE: 06 B5 B7 ADD   [__r1],183
44B1: 0E B6 02 ADC   [__r0],2
44B4: 51 B6    MOV   A,[__r0]
44B6: 60 D4    MOV   REG[212],A
44B8: 3E B5    MVI   A,[__r1]
44BA: 53 B6    MOV   [__r0],A
44BC: 3E B5    MVI   A,[__r1]
44BE: 53 B5    MOV   [__r1],A
44C0: 10       PUSH  X
44C1: 51 B6    MOV   A,[__r0]
44C3: 08       PUSH  A
44C4: 51 B5    MOV   A,[__r1]
44C6: 5C       MOV   X,A
44C7: 18       POP   A
44C8: 7C 0C D9 LCALL 0x0CD9
44CB: 20       POP   X
(0694) 		bKey = KEYPAD_WaitKey(TIME_WAIT_KEY_S);
44CC: 50 1E    MOV   A,30
44CE: 08       PUSH  A
44CF: 7C 33 12 LCALL _KEYPAD_WaitKey
44D2: 38 FF    ADD   SP,255
44D4: 62 D0 02 MOV   REG[208],2
44D7: 54 00    MOV   [X+0],A
(0695) 		if (bKey==0)
44D9: 3D 00 00 CMP   [X+0],0
44DC: B0 03    JNZ   0x44E0
(0696) 			break;
44DE: 82 2B    JMP   0x470A
(0697) 		if (bKey==KBD_CONFIG)
44E0: 3D 00 01 CMP   [X+0],1
44E3: B0 13    JNZ   0x44F7
(0698) 		{
(0699) 			if (++bMenu>=CONFIG_MAX)
44E5: 62 D0 02 MOV   REG[208],2
44E8: 52 01    MOV   A,[X+1]
44EA: 01 01    ADD   A,1
44EC: 54 01    MOV   [X+1],A
44EE: 39 05    CMP   A,5
44F0: C2 17    JC    0x4708
(0700) 				bMenu = 0;
44F2: 56 01 00 MOV   [X+1],0
(0701) 		}
44F5: 82 12    JMP   0x4708
(0702) 		else if (bKey==KBD_UP)
44F7: 3D 00 05 CMP   [X+0],5
44FA: B0 03    JNZ   0x44FE
(0703) 		{
(0704) 			break;
44FC: 82 0D    JMP   0x470A
(0705) 		}
(0706) 		else if (bKey==KBD_DWN)
44FE: 3D 00 06 CMP   [X+0],6
4501: B2 06    JNZ   0x4708
(0707) 		{
(0708) 			switch (bMenu)
4503: 52 01    MOV   A,[X+1]
4505: 54 05    MOV   [X+5],A
4507: 56 04 00 MOV   [X+4],0
450A: 3D 04 00 CMP   [X+4],0
450D: B0 06    JNZ   0x4514
450F: 3D 05 00 CMP   [X+5],0
4512: A0 2B    JZ    0x453E
4514: 3D 04 00 CMP   [X+4],0
4517: B0 06    JNZ   0x451E
4519: 3D 05 01 CMP   [X+5],1
451C: A0 26    JZ    0x4543
451E: 3D 04 00 CMP   [X+4],0
4521: B0 06    JNZ   0x4528
4523: 3D 05 02 CMP   [X+5],2
4526: A0 CA    JZ    0x45F1
4528: 3D 04 00 CMP   [X+4],0
452B: B0 06    JNZ   0x4532
452D: 3D 05 03 CMP   [X+5],3
4530: A1 6E    JZ    0x469F
4532: 3D 04 00 CMP   [X+4],0
4535: B0 06    JNZ   0x453C
4537: 3D 05 04 CMP   [X+5],4
453A: A1 8D    JZ    0x46C8
453C: 81 CB    JMP   0x4708
(0709) 			{
(0710) 				case CONFIG_PCLINK:
(0711) 					PcLink();
453E: 7C 48 EC LCALL _PcLink
(0712) 					break;
4541: 81 C6    JMP   0x4708
(0713) 
(0714) 				case CONFIG_STEP:
(0715) 					bStep = g_xConf.bStep;
4543: 62 D0 02 MOV   REG[208],2
4546: 51 ED    MOV   A,[g_xConf]
4548: 54 02    MOV   [X+2],A
(0716) 					do
(0717) 					{
(0718) 						DISP_Clear();
454A: 7C 32 83 LCALL _DISP_Clear
(0719) 						LCD_Position(0, 0);
454D: 10       PUSH  X
454E: 50 00    MOV   A,0
4550: 5C       MOV   X,A
4551: 7C 0E 5E LCALL 0x0E5E
4554: 20       POP   X
(0720) 						LCD_PrCString(gConfigStr[bMenu]);
4555: 62 D0 02 MOV   REG[208],2
4558: 52 01    MOV   A,[X+1]
455A: 53 B5    MOV   [__r1],A
455C: 55 B6 00 MOV   [__r0],0
455F: 65 B5    ASL   [__r1]
4561: 6B B6    RLC   [__r0]
4563: 06 B5 B7 ADD   [__r1],183
4566: 0E B6 02 ADC   [__r0],2
4569: 51 B6    MOV   A,[__r0]
456B: 60 D4    MOV   REG[212],A
456D: 3E B5    MVI   A,[__r1]
456F: 53 B6    MOV   [__r0],A
4571: 3E B5    MVI   A,[__r1]
4573: 53 B5    MOV   [__r1],A
4575: 10       PUSH  X
4576: 51 B6    MOV   A,[__r0]
4578: 08       PUSH  A
4579: 51 B5    MOV   A,[__r1]
457B: 5C       MOV   X,A
457C: 18       POP   A
457D: 7C 0C D9 LCALL 0x0CD9
4580: 20       POP   X
(0721) 						LCD_Position(1, 0);
4581: 10       PUSH  X
4582: 57 00    MOV   X,0
4584: 50 01    MOV   A,1
4586: 7C 0E 5E LCALL 0x0E5E
4589: 20       POP   X
(0722) 						LCD_PrCString(gStepStr[bStep]);
458A: 62 D0 02 MOV   REG[208],2
458D: 52 02    MOV   A,[X+2]
458F: 53 B5    MOV   [__r1],A
4591: 55 B6 00 MOV   [__r0],0
4594: 65 B5    ASL   [__r1]
4596: 6B B6    RLC   [__r0]
4598: 06 B5 CB ADD   [__r1],203
459B: 0E B6 02 ADC   [__r0],2
459E: 51 B6    MOV   A,[__r0]
45A0: 60 D4    MOV   REG[212],A
45A2: 3E B5    MVI   A,[__r1]
45A4: 53 B6    MOV   [__r0],A
45A6: 3E B5    MVI   A,[__r1]
45A8: 53 B5    MOV   [__r1],A
45AA: 10       PUSH  X
45AB: 51 B6    MOV   A,[__r0]
45AD: 08       PUSH  A
45AE: 51 B5    MOV   A,[__r1]
45B0: 5C       MOV   X,A
45B1: 18       POP   A
45B2: 7C 0C D9 LCALL 0x0CD9
45B5: 20       POP   X
(0723) 						bKey = KEYPAD_WaitKey(TIME_WAIT_KEY_S);
45B6: 50 1E    MOV   A,30
45B8: 08       PUSH  A
45B9: 7C 33 12 LCALL _KEYPAD_WaitKey
45BC: 38 FF    ADD   SP,255
45BE: 62 D0 02 MOV   REG[208],2
45C1: 54 00    MOV   [X+0],A
(0724) 						if (bKey==KBD_CONFIG)
45C3: 3D 00 01 CMP   [X+0],1
45C6: B0 10    JNZ   0x45D7
(0725) 						{
(0726) 							if (++bStep>=STEP_MAX)
45C8: 52 02    MOV   A,[X+2]
45CA: 01 01    ADD   A,1
45CC: 54 02    MOV   [X+2],A
45CE: 39 05    CMP   A,5
45D0: C0 1E    JC    0x45EF
(0727) 								bStep = 0;
45D2: 56 02 00 MOV   [X+2],0
(0728) 						}
45D5: 80 19    JMP   0x45EF
(0729) 						else if (bKey==KBD_UP)
45D7: 3D 00 05 CMP   [X+0],5
45DA: B0 03    JNZ   0x45DE
(0730) 						{
(0731) 							break;
45DC: 81 2B    JMP   0x4708
(0732) 						}
(0733) 						else if (bKey==KBD_DWN)
45DE: 3D 00 06 CMP   [X+0],6
45E1: B0 0D    JNZ   0x45EF
(0734) 						{
(0735) 							g_xConf.bStep = bStep;
45E3: 52 02    MOV   A,[X+2]
45E5: 62 D0 02 MOV   REG[208],2
45E8: 53 ED    MOV   [g_xConf],A
(0736) 							STR_SaveConfig();
45EA: 7C 51 57 LCALL _STR_SaveConfig
(0737) 							break;
45ED: 81 1A    JMP   0x4708
(0738) 						}
(0739) 					} while(TRUE);
45EF: 8F 5A    JMP   0x454A
(0740) 					break;
(0741) 
(0742) 				case CONFIG_IDDLE:
(0743) 					bUserIddle = g_xConf.bUserIddle;
45F1: 62 D0 02 MOV   REG[208],2
45F4: 51 EE    MOV   A,[g_xConf+1]
45F6: 54 03    MOV   [X+3],A
(0744) 					do
(0745) 					{
(0746) 						DISP_Clear();
45F8: 7C 32 83 LCALL _DISP_Clear
(0747) 						LCD_Position(0, 0);
45FB: 10       PUSH  X
45FC: 50 00    MOV   A,0
45FE: 5C       MOV   X,A
45FF: 7C 0E 5E LCALL 0x0E5E
4602: 20       POP   X
(0748) 						LCD_PrCString(gConfigStr[bMenu]);
4603: 62 D0 02 MOV   REG[208],2
4606: 52 01    MOV   A,[X+1]
4608: 53 B5    MOV   [__r1],A
460A: 55 B6 00 MOV   [__r0],0
460D: 65 B5    ASL   [__r1]
460F: 6B B6    RLC   [__r0]
4611: 06 B5 B7 ADD   [__r1],183
4614: 0E B6 02 ADC   [__r0],2
4617: 51 B6    MOV   A,[__r0]
4619: 60 D4    MOV   REG[212],A
461B: 3E B5    MVI   A,[__r1]
461D: 53 B6    MOV   [__r0],A
461F: 3E B5    MVI   A,[__r1]
4621: 53 B5    MOV   [__r1],A
4623: 10       PUSH  X
4624: 51 B6    MOV   A,[__r0]
4626: 08       PUSH  A
4627: 51 B5    MOV   A,[__r1]
4629: 5C       MOV   X,A
462A: 18       POP   A
462B: 7C 0C D9 LCALL 0x0CD9
462E: 20       POP   X
(0749) 						LCD_Position(1, 0);
462F: 10       PUSH  X
4630: 57 00    MOV   X,0
4632: 50 01    MOV   A,1
4634: 7C 0E 5E LCALL 0x0E5E
4637: 20       POP   X
(0750) 						LCD_PrCString(gIddleStr[bUserIddle]);
4638: 62 D0 02 MOV   REG[208],2
463B: 52 03    MOV   A,[X+3]
463D: 53 B5    MOV   [__r1],A
463F: 55 B6 00 MOV   [__r0],0
4642: 65 B5    ASL   [__r1]
4644: 6B B6    RLC   [__r0]
4646: 06 B5 D5 ADD   [__r1],213
4649: 0E B6 02 ADC   [__r0],2
464C: 51 B6    MOV   A,[__r0]
464E: 60 D4    MOV   REG[212],A
4650: 3E B5    MVI   A,[__r1]
4652: 53 B6    MOV   [__r0],A
4654: 3E B5    MVI   A,[__r1]
4656: 53 B5    MOV   [__r1],A
4658: 10       PUSH  X
4659: 51 B6    MOV   A,[__r0]
465B: 08       PUSH  A
465C: 51 B5    MOV   A,[__r1]
465E: 5C       MOV   X,A
465F: 18       POP   A
4660: 7C 0C D9 LCALL 0x0CD9
4663: 20       POP   X
(0751) 						bKey = KEYPAD_WaitKey(TIME_WAIT_KEY_S);
4664: 50 1E    MOV   A,30
4666: 08       PUSH  A
4667: 7C 33 12 LCALL _KEYPAD_WaitKey
466A: 38 FF    ADD   SP,255
466C: 62 D0 02 MOV   REG[208],2
466F: 54 00    MOV   [X+0],A
(0752) 						if (bKey==KBD_CONFIG)
4671: 3D 00 01 CMP   [X+0],1
4674: B0 10    JNZ   0x4685
(0753) 						{
(0754) 							if (++bUserIddle>=USER_IDDLE_MAX)
4676: 52 03    MOV   A,[X+3]
4678: 01 01    ADD   A,1
467A: 54 03    MOV   [X+3],A
467C: 39 04    CMP   A,4
467E: C0 1E    JC    0x469D
(0755) 								bUserIddle = 0;
4680: 56 03 00 MOV   [X+3],0
(0756) 						}
4683: 80 19    JMP   0x469D
(0757) 						else if (bKey==KBD_UP)
4685: 3D 00 05 CMP   [X+0],5
4688: B0 03    JNZ   0x468C
(0758) 						{
(0759) 							break;
468A: 80 7D    JMP   0x4708
(0760) 						}
(0761) 						else if (bKey==KBD_DWN)
468C: 3D 00 06 CMP   [X+0],6
468F: B0 0D    JNZ   0x469D
(0762) 						{
(0763) 							g_xConf.bUserIddle = bUserIddle;
4691: 52 03    MOV   A,[X+3]
4693: 62 D0 02 MOV   REG[208],2
4696: 53 EE    MOV   [g_xConf+1],A
(0764) 							STR_SaveConfig();
4698: 7C 51 57 LCALL _STR_SaveConfig
(0765) 							break;
469B: 80 6C    JMP   0x4708
(0766) 						}
(0767) 					} while(TRUE);
469D: 8F 5A    JMP   0x45F8
(0768) 					break;
(0769) 
(0770) 				case CONFIG_CALIB:
(0771) 					LCD_Position(1, 0);
469F: 10       PUSH  X
46A0: 57 00    MOV   X,0
46A2: 50 01    MOV   A,1
46A4: 7C 0E 5E LCALL 0x0E5E
46A7: 20       POP   X
(0772) 					LCD_PrCString(gConfirmStr);
46A8: 10       PUSH  X
46A9: 50 04    MOV   A,4
46AB: 08       PUSH  A
46AC: 50 B0    MOV   A,176
46AE: 5C       MOV   X,A
46AF: 18       POP   A
46B0: 7C 0C D9 LCALL 0x0CD9
46B3: 20       POP   X
(0773) 										// Wait key press
(0774) 					if (KEYPAD_WaitKey(TIME_WAIT_KEY_S) == KBD_DWN)
46B4: 50 1E    MOV   A,30
46B6: 08       PUSH  A
46B7: 7C 33 12 LCALL _KEYPAD_WaitKey
46BA: 38 FF    ADD   SP,255
46BC: 62 D0 02 MOV   REG[208],2
46BF: 39 06    CMP   A,6
46C1: B0 46    JNZ   0x4708
(0775) 						Calibrate_Reflectometer();
46C3: 7C 19 4C LCALL _Calibrate_Reflectometer
(0776) 					break;
46C6: 80 41    JMP   0x4708
(0777) 
(0778) 				case CONFIG_SW_LOAD:
(0779) 					LCD_Position(1, 0);
46C8: 10       PUSH  X
46C9: 57 00    MOV   X,0
46CB: 50 01    MOV   A,1
46CD: 7C 0E 5E LCALL 0x0E5E
46D0: 20       POP   X
(0780) 					LCD_PrCString(gConfirmStr);
46D1: 10       PUSH  X
46D2: 50 04    MOV   A,4
46D4: 08       PUSH  A
46D5: 50 B0    MOV   A,176
46D7: 5C       MOV   X,A
46D8: 18       POP   A
46D9: 7C 0C D9 LCALL 0x0CD9
46DC: 20       POP   X
(0781) 										// Wait key press
(0782) 					if (KEYPAD_WaitKey(TIME_WAIT_KEY_S) == KBD_DWN)
46DD: 50 1E    MOV   A,30
46DF: 08       PUSH  A
46E0: 7C 33 12 LCALL _KEYPAD_WaitKey
46E3: 38 FF    ADD   SP,255
46E5: 62 D0 02 MOV   REG[208],2
46E8: 39 06    CMP   A,6
46EA: B0 1D    JNZ   0x4708
(0783) 					{
(0784) 						DISP_Clear();
46EC: 7C 32 83 LCALL _DISP_Clear
(0785) 						LCD_Position(0, 0);
46EF: 10       PUSH  X
46F0: 50 00    MOV   A,0
46F2: 5C       MOV   X,A
46F3: 7C 0E 5E LCALL 0x0E5E
46F6: 20       POP   X
(0786) 						LCD_PrCString(gSwLoadingStr);
46F7: 10       PUSH  X
46F8: 50 04    MOV   A,4
46FA: 08       PUSH  A
46FB: 50 D4    MOV   A,212
46FD: 5C       MOV   X,A
46FE: 18       POP   A
46FF: 7C 0C D9 LCALL 0x0CD9
4702: 20       POP   X
(0787) 
(0788) 						// Perform Software Reset
(0789) 						M8C_DisableGInt;
4703: 70 FE    AND   F,254
(0790) 						asm ("ljmp 0x0000");
4705: 7D 00 00 LJMP  0x0000
(0791) 						//M8C_Reset;		// Doesn't work always
(0792) 					}
(0793) 					break;
(0794) 			}
(0795) 		}
(0796) 	} while (TRUE);
4708: 8D 8C    JMP   0x4495
470A: 38 FA    ADD   SP,250
470C: 20       POP   X
470D: 7F       RET   

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\measure.c
(0001) //*****************************************************************************/
(0002) //  This file is a part of the "SARK100 SWR Analyzer firmware"
(0003) //
(0004) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
(0005) //  Melchor Varela, Madrid, Spain.
(0006) //  melchor.varela@gmail.com
(0007) //
(0008) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0009) //  and/or modify it under the terms of the GNU General Public License as
(0010) //  published by the Free Software Foundation, either version 3 of the License,
(0011) //  or (at your option) any later version.
(0012) //
(0013) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
(0014) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0015) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
(0016) //  GNU General Public License for more details.
(0017) //
(0018) //  You should have received a copy of the GNU General Public License
(0019) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0020) //  see <http://www.gnu.org/licenses/>.
(0021) //*****************************************************************************/
(0022) //*****************************************************************************/
(0023) //
(0024) //	PROJECT:	SARK100 SWR Analyzer
(0025) // 	FILE NAME: 	MEASURE.C
(0026) // 	AUTHOR:		EA4FRB - Melchor Varela
(0027) //
(0028) // 	DESCRIPTION
(0029) //
(0030) //	Measure reflectometer voltages
(0031) //
(0032) // 	HISTORY
(0033) //
(0034) //	NAME   	DATE		REMARKS
(0035) //
(0036) //	MVM	   	DEC2009		Creation
(0037) //
(0038) //*****************************************************************************/
(0039) 
(0040) #include <m8c.h>        				// Part specific constants and macros
(0041) #include <math.h>
(0042) 
(0043) #include "PSoCAPI.h"
(0044) #include "psocgpioint.h"
(0045) #include "util.h"
(0046) 
(0047) #include "measure.h"
(0048) #include "glb_data.h"
(0049) 
(0050) //-----------------------------------------------------------------------------
(0051) //  Defines
(0052) //-----------------------------------------------------------------------------
(0053) #define NUM_AVE_SAMPLES			8		// Maximum 16
(0054) 
(0055) //-----------------------------------------------------------------------------
(0056) //  Prototypes
(0057) //-----------------------------------------------------------------------------
(0058) static DWORD TakeSample (void);
(0059) 
(0060) //-----------------------------------------------------------------------------
(0061) //  FUNCTION NAME:	Do_Measure
(0062) //
(0063) //  DESCRIPTION:
(0064) //
(0065) //	Measure reflectometer voltages.
(0066) //
(0067) //  ARGUMENTS:
(0068) //
(0069) //  RETURNS:
(0070) //     g_xBridgeMeasure
(0071) //
(0072) //-----------------------------------------------------------------------------
(0073) void Do_Measure ( void )
(0074) {
(0075) 										// Read Vf
(0076) 	AMUX4_ADC_InputSelect(AMUX4_ADC_PORT0_1);
_Do_Measure:
470E: 10       PUSH  X
470F: 50 00    MOV   A,0
4711: 7C 0F 81 LCALL 0x0F81
4714: 20       POP   X
(0077) 	g_xBridgeMeasure.Vf = TakeSample();
4715: 90 CB    CALL  _TakeSample
4717: 62 D0 02 MOV   REG[208],2
471A: 51 B6    MOV   A,[__r0]
471C: 08       PUSH  A
471D: 51 B5    MOV   A,[__r1]
471F: 08       PUSH  A
4720: 51 B4    MOV   A,[__r2]
4722: 08       PUSH  A
4723: 51 B3    MOV   A,[__r3]
4725: 62 D0 02 MOV   REG[208],2
4728: 53 8F    MOV   [g_xBridgeMeasure+3],A
472A: 18       POP   A
472B: 53 8E    MOV   [g_xBridgeMeasure+2],A
472D: 18       POP   A
472E: 53 8D    MOV   [g_xBridgeMeasure+1],A
4730: 18       POP   A
4731: 53 8C    MOV   [g_xBridgeMeasure],A
(0078) 
(0079) 										// Read Va
(0080) 	AMUX4_ADC_InputSelect(AMUX4_ADC_PORT0_7);
4733: 10       PUSH  X
4734: 50 03    MOV   A,3
4736: 7C 0F 81 LCALL 0x0F81
4739: 20       POP   X
(0081) 	g_xBridgeMeasure.Va = TakeSample();
473A: 90 A6    CALL  _TakeSample
473C: 62 D0 02 MOV   REG[208],2
473F: 51 B6    MOV   A,[__r0]
4741: 08       PUSH  A
4742: 51 B5    MOV   A,[__r1]
4744: 08       PUSH  A
4745: 51 B4    MOV   A,[__r2]
4747: 08       PUSH  A
4748: 51 B3    MOV   A,[__r3]
474A: 62 D0 02 MOV   REG[208],2
474D: 53 97    MOV   [151],A
474F: 18       POP   A
4750: 53 96    MOV   [150],A
4752: 18       POP   A
4753: 53 95    MOV   [149],A
4755: 18       POP   A
4756: 53 94    MOV   [148],A
(0082) 
(0083) 										// Read Vz
(0084) 	AMUX4_ADC_InputSelect(AMUX4_ADC_PORT0_5);
4758: 10       PUSH  X
4759: 50 02    MOV   A,2
475B: 7C 0F 81 LCALL 0x0F81
475E: 20       POP   X
(0085) 	g_xBridgeMeasure.Vz = TakeSample();
475F: 90 81    CALL  _TakeSample
4761: 62 D0 02 MOV   REG[208],2
4764: 51 B6    MOV   A,[__r0]
4766: 08       PUSH  A
4767: 51 B5    MOV   A,[__r1]
4769: 08       PUSH  A
476A: 51 B4    MOV   A,[__r2]
476C: 08       PUSH  A
476D: 51 B3    MOV   A,[__r3]
476F: 62 D0 02 MOV   REG[208],2
4772: 53 9B    MOV   [155],A
4774: 18       POP   A
4775: 53 9A    MOV   [154],A
4777: 18       POP   A
4778: 53 99    MOV   [153],A
477A: 18       POP   A
477B: 53 98    MOV   [152],A
(0086) 
(0087) 										// Read Vr
(0088) 										// Gain is set to double because dynamic range is half
(0089) 	PGA_ADC_SetGain(PGA_ADC_G5_33);
477D: 10       PUSH  X
477E: 50 28    MOV   A,40
4780: 7C 0C AB LCALL 0x0CAB
4783: 20       POP   X
(0090) 	Delay_Ms(1);
4784: 50 00    MOV   A,0
4786: 08       PUSH  A
4787: 50 01    MOV   A,1
4789: 08       PUSH  A
478A: 7C 53 01 LCALL _Delay_Ms
478D: 38 FE    ADD   SP,254
(0091) 	AMUX4_ADC_InputSelect(AMUX4_ADC_PORT0_3);
478F: 10       PUSH  X
4790: 50 01    MOV   A,1
4792: 7C 0F 81 LCALL 0x0F81
4795: 20       POP   X
(0092) 	g_xBridgeMeasure.Vr = TakeSample();
4796: 90 4A    CALL  _TakeSample
4798: 62 D0 02 MOV   REG[208],2
479B: 51 B6    MOV   A,[__r0]
479D: 08       PUSH  A
479E: 51 B5    MOV   A,[__r1]
47A0: 08       PUSH  A
47A1: 51 B4    MOV   A,[__r2]
47A3: 08       PUSH  A
47A4: 51 B3    MOV   A,[__r3]
47A6: 62 D0 02 MOV   REG[208],2
47A9: 53 93    MOV   [147],A
47AB: 18       POP   A
47AC: 53 92    MOV   [146],A
47AE: 18       POP   A
47AF: 53 91    MOV   [145],A
47B1: 18       POP   A
47B2: 53 90    MOV   [144],A
(0093) 
(0094) 	PGA_ADC_SetGain(PGA_ADC_G2_67);		// Restores gain
47B4: 10       PUSH  X
47B5: 50 58    MOV   A,88
47B7: 7C 0C AB LCALL 0x0CAB
47BA: 20       POP   X
47BB: 7F       RET   
(0095) }
(0096) //-----------------------------------------------------------------------------
(0097) //  FUNCTION NAME:	Do_MeasureRfLevel
(0098) //
(0099) //  DESCRIPTION:
(0100) //
(0101) //	Measure Rf Level
(0102) //
(0103) //  ARGUMENTS:
(0104) //
(0105) //  RETURNS:
(0106) //     g_xBridgeMeasure
(0107) //
(0108) //-----------------------------------------------------------------------------
(0109) void Do_MeasureRfLevel ( void )
(0110) {
(0111) 										// Read Vz
(0112) 	AMUX4_ADC_InputSelect(AMUX4_ADC_PORT0_5);
_Do_MeasureRfLevel:
47BC: 10       PUSH  X
47BD: 50 02    MOV   A,2
47BF: 7C 0F 81 LCALL 0x0F81
47C2: 20       POP   X
(0113) 	g_xBridgeMeasure.Vz = TakeSample();
47C3: 90 1D    CALL  _TakeSample
47C5: 62 D0 02 MOV   REG[208],2
47C8: 51 B6    MOV   A,[__r0]
47CA: 08       PUSH  A
47CB: 51 B5    MOV   A,[__r1]
47CD: 08       PUSH  A
47CE: 51 B4    MOV   A,[__r2]
47D0: 08       PUSH  A
47D1: 51 B3    MOV   A,[__r3]
47D3: 62 D0 02 MOV   REG[208],2
47D6: 53 9B    MOV   [155],A
47D8: 18       POP   A
47D9: 53 9A    MOV   [154],A
47DB: 18       POP   A
47DC: 53 99    MOV   [153],A
47DE: 18       POP   A
47DF: 53 98    MOV   [152],A
47E1: 7F       RET   
(0114) }
(0115) 
(0116) //-----------------------------------------------------------------------------
(0117) //  FUNCTION NAME:	TakeSample
(0118) //
(0119) //  DESCRIPTION:
(0120) //
(0121) //	Takes sample from ADC using correlated double sampling
(0122) //
(0123) //  ARGUMENTS:
(0124) //     none.
(0125) //
(0126) //  RETURNS:
(0127) //     Measured value
(0128) //
(0129) //-----------------------------------------------------------------------------
(0130) static DWORD TakeSample (void)
(0131) {
_TakeSample:
  wZero                --> X+3
  wVal                 --> X+1
  ii                   --> X+0
47E2: 10       PUSH  X
47E3: 4F       MOV   X,SP
47E4: 38 05    ADD   SP,5
(0132) 	WORD wVal = 0;
47E6: 56 02 00 MOV   [X+2],0
47E9: 56 01 00 MOV   [X+1],0
(0133) 	WORD wZero;
(0134) 	BYTE ii;
(0135) 										// Correlated double sampling
(0136) 	PGA_ADC_GAIN_CR1 &= ~1;				// Set input to RefLO
47EC: 41 72 FE AND   REG[114],254
(0137) 	ADCINC12_GetSamples(1);
47EF: 10       PUSH  X
47F0: 50 01    MOV   A,1
47F2: 7C 10 2D LCALL 0x102D
47F5: 20       POP   X
(0138) 										// Wait for data to be ready.
(0139) 	while(ADCINC12_fIsDataAvailable() == 0);
47F6: 10       PUSH  X
47F7: 7C 10 69 LCALL 0x1069
47FA: 62 D0 02 MOV   REG[208],2
47FD: 20       POP   X
47FE: 39 00    CMP   A,0
4800: AF F5    JZ    0x47F6
(0140) 	wZero = (ADCINC12_iGetData()+2048);
4802: 10       PUSH  X
4803: 7C 10 6F LCALL 0x106F
4806: 62 D0 02 MOV   REG[208],2
4809: 53 B5    MOV   [__r1],A
480B: 5A B6    MOV   [__r0],X
480D: 20       POP   X
480E: 06 B5 00 ADD   [__r1],0
4811: 0E B6 08 ADC   [__r0],8
4814: 51 B5    MOV   A,[__r1]
4816: 54 04    MOV   [X+4],A
4818: 51 B6    MOV   A,[__r0]
481A: 54 03    MOV   [X+3],A
(0141) 	ADCINC12_ClearFlag();
481C: 10       PUSH  X
481D: 7C 10 77 LCALL 0x1077
4820: 20       POP   X
(0142) 
(0143) 	PGA_ADC_GAIN_CR1 |= 1;				// Set input to PortInp
4821: 43 72 01 OR    REG[114],1
(0144) 
(0145) 	if (g_bScanning == FALSE)			// If not scanning do some averaging
4824: 62 D0 02 MOV   REG[208],2
4827: 3C F4 00 CMP   [g_bScanning],0
482A: B0 53    JNZ   0x487E
(0146) 	{
(0147) 		ADCINC12_GetSamples(NUM_AVE_SAMPLES);
482C: 10       PUSH  X
482D: 50 08    MOV   A,8
482F: 7C 10 2D LCALL 0x102D
4832: 20       POP   X
(0148) 		for (ii=0;ii<NUM_AVE_SAMPLES;ii++)
4833: 56 00 00 MOV   [X+0],0
4836: 80 2E    JMP   0x4865
(0149) 		{
(0150) 										// Wait for data to be ready.
(0151) 			while(ADCINC12_fIsDataAvailable() == 0);
4838: 10       PUSH  X
4839: 7C 10 69 LCALL 0x1069
483C: 62 D0 02 MOV   REG[208],2
483F: 20       POP   X
4840: 39 00    CMP   A,0
4842: AF F5    JZ    0x4838
(0152) 			wVal += (ADCINC12_iGetData()+2048);
4844: 10       PUSH  X
4845: 7C 10 6F LCALL 0x106F
4848: 62 D0 02 MOV   REG[208],2
484B: 53 B5    MOV   [__r1],A
484D: 5A B6    MOV   [__r0],X
484F: 20       POP   X
4850: 06 B5 00 ADD   [__r1],0
4853: 0E B6 08 ADC   [__r0],8
4856: 51 B5    MOV   A,[__r1]
4858: 05 02    ADD   [X+2],A
485A: 51 B6    MOV   A,[__r0]
485C: 0D 01    ADC   [X+1],A
(0153) 			ADCINC12_ClearFlag();
485E: 10       PUSH  X
485F: 7C 10 77 LCALL 0x1077
4862: 20       POP   X
4863: 77 00    INC   [X+0]
4865: 3D 00 08 CMP   [X+0],8
4868: CF CF    JC    0x4838
(0154) 		}
(0155) 		wVal /= NUM_AVE_SAMPLES;
486A: 70 FB    AND   F,251
486C: 6F 01    RRC   [X+1]
486E: 6F 02    RRC   [X+2]
4870: 70 FB    AND   F,251
4872: 6F 01    RRC   [X+1]
4874: 6F 02    RRC   [X+2]
4876: 70 FB    AND   F,251
4878: 6F 01    RRC   [X+1]
487A: 6F 02    RRC   [X+2]
(0156) 	}
487C: 80 33    JMP   0x48B0
(0157) 	else
(0158) 	{
(0159) 		ADCINC12_GetSamples(1);
487E: 10       PUSH  X
487F: 50 01    MOV   A,1
4881: 7C 10 2D LCALL 0x102D
4884: 20       POP   X
(0160) 										// Wait for data to be ready.
(0161) 		while(ADCINC12_fIsDataAvailable() == 0);
4885: 10       PUSH  X
4886: 7C 10 69 LCALL 0x1069
4889: 62 D0 02 MOV   REG[208],2
488C: 20       POP   X
488D: 39 00    CMP   A,0
488F: AF F5    JZ    0x4885
(0162) 		wVal = (ADCINC12_iGetData()+2048);
4891: 10       PUSH  X
4892: 7C 10 6F LCALL 0x106F
4895: 62 D0 02 MOV   REG[208],2
4898: 53 B5    MOV   [__r1],A
489A: 5A B6    MOV   [__r0],X
489C: 20       POP   X
489D: 06 B5 00 ADD   [__r1],0
48A0: 0E B6 08 ADC   [__r0],8
48A3: 51 B5    MOV   A,[__r1]
48A5: 54 02    MOV   [X+2],A
48A7: 51 B6    MOV   A,[__r0]
48A9: 54 01    MOV   [X+1],A
(0163) 		ADCINC12_ClearFlag();
48AB: 10       PUSH  X
48AC: 7C 10 77 LCALL 0x1077
48AF: 20       POP   X
(0164) 	}
(0165) 
(0166) 	if (wVal >= wZero)
48B0: 52 02    MOV   A,[X+2]
48B2: 13 04    SUB   A,[X+4]
48B4: 52 01    MOV   A,[X+1]
48B6: 1B 03    SBB   A,[X+3]
48B8: C0 20    JC    0x48D9
(0167) 		return wVal-wZero;
48BA: 62 D0 02 MOV   REG[208],2
48BD: 52 02    MOV   A,[X+2]
48BF: 13 04    SUB   A,[X+4]
48C1: 53 B5    MOV   [__r1],A
48C3: 52 01    MOV   A,[X+1]
48C5: 1B 03    SBB   A,[X+3]
48C7: 53 B6    MOV   [__r0],A
48C9: 51 B5    MOV   A,[__r1]
48CB: 53 B3    MOV   [__r3],A
48CD: 51 B6    MOV   A,[__r0]
48CF: 53 B4    MOV   [__r2],A
48D1: 55 B5 00 MOV   [__r1],0
48D4: 55 B6 00 MOV   [__r0],0
48D7: 80 10    JMP   0x48E8
(0168) 	else
(0169) 		return 0;
48D9: 62 D0 02 MOV   REG[208],2
48DC: 55 B6 00 MOV   [__r0],0
48DF: 55 B5 00 MOV   [__r1],0
48E2: 55 B4 00 MOV   [__r2],0
48E5: 55 B3 00 MOV   [__r3],0
48E8: 38 FB    ADD   SP,251
48EA: 20       POP   X
48EB: 7F       RET   

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\pclink.c
(0001) //*****************************************************************************/
(0002) //  This file is a part of the "SARK100 SWR Analyzer firmware"
(0003) //
(0004) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
(0005) //  Melchor Varela, Madrid, Spain.
(0006) //  melchor.varela@gmail.com
(0007) //
(0008) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0009) //  and/or modify it under the terms of the GNU General Public License as
(0010) //  published by the Free Software Foundation, either version 3 of the License,
(0011) //  or (at your option) any later version.
(0012) //
(0013) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
(0014) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0015) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
(0016) //  GNU General Public License for more details.
(0017) //
(0018) //  You should have received a copy of the GNU General Public License
(0019) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0020) //  see <http://www.gnu.org/licenses/>.
(0021) //*****************************************************************************/
(0022) //*****************************************************************************/
(0023) //
(0024) //	PROJECT:	SARK100 SWR Analyzer
(0025) // 	FILE NAME: 	PCLINK.C
(0026) // 	AUTHOR:		EA4FRB - Melchor Varela
(0027) //
(0028) // 	DESCRIPTION
(0029) //
(0030) //	PC link routines for update measurements
(0031) //
(0032) // 	HISTORY
(0033) //
(0034) //	NAME   	DATE		REMARKS
(0035) //
(0036) //	MVM	   	DEC 2009	Creation
(0037) //
(0038) //*****************************************************************************/
(0039) #include <stdlib.h>
(0040) #include <string.h>
(0041) #include <m8c.h>
(0042) #include "PSoCAPI.h"
(0043) #include "keypad.h"
(0044) #include "msg_generic.h"
(0045) #include "dds.h"
(0046) #include "glb_data.h"
(0047) #include "calibrate_reflectometer.h"
(0048) #include "calcs.h"
(0049) #include "util.h"
(0050) 
(0051) //-----------------------------------------------------------------------------
(0052) //  Private data:
(0053) //-----------------------------------------------------------------------------
(0054) static BYTE const gszCmdOn		[] = "on";
(0055) static BYTE const gszCmdOff		[] = "off";
(0056) static BYTE const gszCmdFreq	[] = "freq";
(0057) static BYTE const gszCmdMeasImp	[] = "imp";
(0058) static BYTE const gszCmdMeasRaw	[] = "raw";
(0059) static BYTE const gszCmdScan	[] = "scan";
(0060) static BYTE const gszCmdScanRaw	[] = "scanr";
(0061) 
(0062) static BYTE const gszWelcome	[] = "\r\n" PRODUCT_NAME_STR " SWR Analyzer " VERSION_STR "\r\n";
(0063) static BYTE const gszCmdPrompt	[] = "\r\n>>";
(0064) static BYTE const gszWaitLink	[] = "Waiting Link";
(0065) static BYTE const gszOk			[] = "\r\nOK\r\n";
(0066) static BYTE const gszSwrOvf		[] = "9.99";
(0067) static BYTE const gszOvf		[] = "9999";
(0068) static BYTE const gszStart		[] = "\r\nStart\r\n";
(0069) static BYTE const gszEnd		[] = "End\r\n";
(0070) 
(0071) static BYTE const gszErrFreqNotSet	[] = "\r\nError: freq not set\r\n";
(0072) static BYTE const gszErrExpectFreq	[] = "\r\nError: expected freq val\r\n";
(0073) static BYTE const gszErrExpectStep	[] = "\r\nError: expected step val\r\n";
(0074) static BYTE const gszErrInvalidFreq	[] = "\r\nError: invalid freq\r\n";
(0075) static BYTE const gszErrCmdNotFound1[] = "\r\nCommand <";
(0076) static BYTE const gszErrCmdNotFound2[] = "> not found\r\n";
(0077) 
(0078) //-----------------------------------------------------------------------------
(0079) //  Prototypes
(0080) //-----------------------------------------------------------------------------
(0081) static void Cmd_Off (void);
(0082) static void Cmd_On (void);
(0083) static void Cmd_Freq (void);
(0084) static void Cmd_Imp (void);
(0085) static void Cmd_Raw (void);
(0086) static void Cmd_Scan (BYTE bRaw);
(0087) 
(0088) //-----------------------------------------------------------------------------
(0089) //  Private data
(0090) //-----------------------------------------------------------------------------
(0091) static DWORD gdwCurrentFreq = -1;
(0092) 
(0093) //-----------------------------------------------------------------------------
(0094) //  FUNCTION NAME:	PcLink
(0095) //
(0096) //  DESCRIPTION:
(0097) //
(0098) //	PC link routines for update measurements
(0099) //
(0100) //  ARGUMENTS:
(0101) //     none.
(0102) //
(0103) //  RETURNS:
(0104) //     none.
(0105) //
(0106) //-----------------------------------------------------------------------------
(0107) void PcLink (void)
(0108) {
_PcLink:
  strPtr               --> X+0
48EC: 10       PUSH  X
48ED: 4F       MOV   X,SP
48EE: 38 02    ADD   SP,2
(0109) 	char * strPtr; 						// Parameter pointer
(0110) 
(0111) 	UART_CmdReset(); 					// Initialize receiver/cmd buffer
48F0: 10       PUSH  X
48F1: 7C 0A D8 LCALL 0x0AD8
48F4: 20       POP   X
(0112) 	UART_IntCntl(UART_ENABLE_RX_INT); 	// Enable RX interrupts
48F5: 10       PUSH  X
48F6: 50 01    MOV   A,1
48F8: 7C 09 D5 LCALL 0x09D5
48FB: 20       POP   X
(0113) 	UART_Start(UART_PARITY_NONE); 		// Enable UART
48FC: 10       PUSH  X
48FD: 50 00    MOV   A,0
48FF: 7C 09 A6 LCALL 0x09A6
4902: 20       POP   X
(0114) 
(0115) 	M8C_EnableGInt ;
4903: 71 01    OR    F,1
(0116) 
(0117)     UART_PutChar(12); 					// Clear the screen
4905: 10       PUSH  X
4906: 50 0C    MOV   A,12
4908: 7C 0A 1A LCALL 0x0A1A
490B: 20       POP   X
(0118) 	UART_CPutString(gszWelcome);
490C: 10       PUSH  X
490D: 50 04    MOV   A,4
490F: 08       PUSH  A
4910: 50 FE    MOV   A,254
4912: 5C       MOV   X,A
4913: 18       POP   A
4914: 7C 0A BD LCALL 0x0ABD
4917: 20       POP   X
(0119) 	UART_CPutString(gszCmdPrompt);
4918: 10       PUSH  X
4919: 50 05    MOV   A,5
491B: 08       PUSH  A
491C: 50 1B    MOV   A,27
491E: 5C       MOV   X,A
491F: 18       POP   A
4920: 7C 0A BD LCALL 0x0ABD
4923: 20       POP   X
(0120) 
(0121) 	LCD_Position(1, 0);
4924: 10       PUSH  X
4925: 57 00    MOV   X,0
4927: 50 01    MOV   A,1
4929: 7C 0E 5E LCALL 0x0E5E
492C: 20       POP   X
(0122) 	LCD_PrCString(gszWaitLink);
492D: 10       PUSH  X
492E: 50 05    MOV   A,5
4930: 08       PUSH  A
4931: 50 20    MOV   A,32
4933: 5C       MOV   X,A
4934: 18       POP   A
4935: 7C 0C D9 LCALL 0x0CD9
4938: 20       POP   X
4939: 81 98    JMP   0x4AD2
(0123) 	while(TRUE)
(0124) 	{
(0125) 		if (KEYPAD_Get() == KBD_UP)
493B: 7C 32 8B LCALL _KEYPAD_Get
493E: 62 D0 02 MOV   REG[208],2
4941: 39 05    CMP   A,5
4943: B0 03    JNZ   0x4947
(0126) 			break;
4945: 81 8E    JMP   0x4AD4
(0127) 
(0128) 		if(UART_bCmdCheck()) 			// Wait for command
4947: 10       PUSH  X
4948: 7C 0A EE LCALL 0x0AEE
494B: 62 D0 02 MOV   REG[208],2
494E: 20       POP   X
494F: 39 00    CMP   A,0
4951: A1 80    JZ    0x4AD2
(0129) 		{								// More than delimiter?
(0130) 			if(strPtr = UART_szGetParam())
4953: 10       PUSH  X
4954: 7C 0B 07 LCALL 0x0B07
4957: 62 D0 02 MOV   REG[208],2
495A: 53 B6    MOV   [__r0],A
495C: 5A B5    MOV   [__r1],X
495E: 20       POP   X
495F: 51 B5    MOV   A,[__r1]
4961: 54 01    MOV   [X+1],A
4963: 51 B6    MOV   A,[__r0]
4965: 54 00    MOV   [X+0],A
4967: 3C B6 00 CMP   [__r0],0
496A: B0 06    JNZ   0x4971
496C: 3C B5 00 CMP   [__r1],0
496F: A1 51    JZ    0x4AC1
(0131) 			{
(0132) 				LCD_Position(1, 0);
4971: 10       PUSH  X
4972: 57 00    MOV   X,0
4974: 50 01    MOV   A,1
4976: 7C 0E 5E LCALL 0x0E5E
4979: 20       POP   X
(0133) 				LCD_PrCString(gBlankStr);
497A: 10       PUSH  X
497B: 50 03    MOV   A,3
497D: 08       PUSH  A
497E: 50 11    MOV   A,17
4980: 5C       MOV   X,A
4981: 18       POP   A
4982: 7C 0C D9 LCALL 0x0CD9
4985: 20       POP   X
(0134) 				LCD_Position(1, 0);
4986: 10       PUSH  X
4987: 57 00    MOV   X,0
4989: 50 01    MOV   A,1
498B: 7C 0E 5E LCALL 0x0E5E
498E: 20       POP   X
(0135) 				LCD_PrString(strPtr);
498F: 10       PUSH  X
4990: 52 00    MOV   A,[X+0]
4992: 08       PUSH  A
4993: 52 01    MOV   A,[X+1]
4995: 5C       MOV   X,A
4996: 18       POP   A
4997: 7C 0D 15 LCALL 0x0D15
499A: 20       POP   X
(0136)     			if(!cstrcmp((const char*)gszCmdOn,(char*)strPtr))
499B: 52 00    MOV   A,[X+0]
499D: 08       PUSH  A
499E: 52 01    MOV   A,[X+1]
49A0: 08       PUSH  A
49A1: 50 04    MOV   A,4
49A3: 08       PUSH  A
49A4: 50 DF    MOV   A,223
49A6: 08       PUSH  A
49A7: 7C 57 EA LCALL _cstrcmpLMM
49AA: 38 FC    ADD   SP,252
49AC: 62 D0 02 MOV   REG[208],2
49AF: 3C B6 00 CMP   [__r0],0
49B2: B0 0A    JNZ   0x49BD
49B4: 3C B5 00 CMP   [__r1],0
49B7: B0 05    JNZ   0x49BD
(0137) 				{
(0138) 					Cmd_On();
49B9: 91 2D    CALL  _Cmd_On
(0139) 				}
49BB: 81 05    JMP   0x4AC1
(0140)     			else if(!cstrcmp((const char*)gszCmdOff,(char*)strPtr))
49BD: 52 00    MOV   A,[X+0]
49BF: 08       PUSH  A
49C0: 52 01    MOV   A,[X+1]
49C2: 08       PUSH  A
49C3: 50 04    MOV   A,4
49C5: 08       PUSH  A
49C6: 50 E2    MOV   A,226
49C8: 08       PUSH  A
49C9: 7C 57 EA LCALL _cstrcmpLMM
49CC: 38 FC    ADD   SP,252
49CE: 62 D0 02 MOV   REG[208],2
49D1: 3C B6 00 CMP   [__r0],0
49D4: B0 0A    JNZ   0x49DF
49D6: 3C B5 00 CMP   [__r1],0
49D9: B0 05    JNZ   0x49DF
(0141) 				{
(0142) 					Cmd_Off();
49DB: 91 51    CALL  _Cmd_Off
(0143) 				}
49DD: 80 E3    JMP   0x4AC1
(0144)     			else if(!cstrcmp((const char*)gszCmdScan,(char*)strPtr))
49DF: 52 00    MOV   A,[X+0]
49E1: 08       PUSH  A
49E2: 52 01    MOV   A,[X+1]
49E4: 08       PUSH  A
49E5: 50 04    MOV   A,4
49E7: 08       PUSH  A
49E8: 50 F3    MOV   A,243
49EA: 08       PUSH  A
49EB: 7C 57 EA LCALL _cstrcmpLMM
49EE: 38 FC    ADD   SP,252
49F0: 62 D0 02 MOV   REG[208],2
49F3: 3C B6 00 CMP   [__r0],0
49F6: B0 0F    JNZ   0x4A06
49F8: 3C B5 00 CMP   [__r1],0
49FB: B0 0A    JNZ   0x4A06
(0145)     			{
(0146) 					Cmd_Scan(FALSE);
49FD: 50 00    MOV   A,0
49FF: 08       PUSH  A
4A00: 94 75    CALL  _Cmd_Scan
4A02: 38 FF    ADD   SP,255
(0147) 				}
4A04: 80 BC    JMP   0x4AC1
(0148)     			else if(!cstrcmp((const char*)gszCmdScanRaw,(char*)strPtr))
4A06: 52 00    MOV   A,[X+0]
4A08: 08       PUSH  A
4A09: 52 01    MOV   A,[X+1]
4A0B: 08       PUSH  A
4A0C: 50 04    MOV   A,4
4A0E: 08       PUSH  A
4A0F: 50 F8    MOV   A,248
4A11: 08       PUSH  A
4A12: 7C 57 EA LCALL _cstrcmpLMM
4A15: 38 FC    ADD   SP,252
4A17: 62 D0 02 MOV   REG[208],2
4A1A: 3C B6 00 CMP   [__r0],0
4A1D: B0 0F    JNZ   0x4A2D
4A1F: 3C B5 00 CMP   [__r1],0
4A22: B0 0A    JNZ   0x4A2D
(0149)     			{
(0150) 					Cmd_Scan(TRUE);
4A24: 50 01    MOV   A,1
4A26: 08       PUSH  A
4A27: 94 4E    CALL  _Cmd_Scan
4A29: 38 FF    ADD   SP,255
(0151) 				}
4A2B: 80 95    JMP   0x4AC1
(0152)     			else if(!cstrcmp((const char*)gszCmdFreq,(char*)strPtr))
4A2D: 52 00    MOV   A,[X+0]
4A2F: 08       PUSH  A
4A30: 52 01    MOV   A,[X+1]
4A32: 08       PUSH  A
4A33: 50 04    MOV   A,4
4A35: 08       PUSH  A
4A36: 50 E6    MOV   A,230
4A38: 08       PUSH  A
4A39: 7C 57 EA LCALL _cstrcmpLMM
4A3C: 38 FC    ADD   SP,252
4A3E: 62 D0 02 MOV   REG[208],2
4A41: 3C B6 00 CMP   [__r0],0
4A44: B0 0A    JNZ   0x4A4F
4A46: 3C B5 00 CMP   [__r1],0
4A49: B0 05    JNZ   0x4A4F
(0153) 				{
(0154) 					Cmd_Freq();
4A4B: 90 F9    CALL  _Cmd_Freq
(0155) 				}
4A4D: 80 73    JMP   0x4AC1
(0156)     			else if(!cstrcmp((const char*)gszCmdMeasImp,(char*)strPtr))
4A4F: 52 00    MOV   A,[X+0]
4A51: 08       PUSH  A
4A52: 52 01    MOV   A,[X+1]
4A54: 08       PUSH  A
4A55: 50 04    MOV   A,4
4A57: 08       PUSH  A
4A58: 50 EB    MOV   A,235
4A5A: 08       PUSH  A
4A5B: 7C 57 EA LCALL _cstrcmpLMM
4A5E: 38 FC    ADD   SP,252
4A60: 62 D0 02 MOV   REG[208],2
4A63: 3C B6 00 CMP   [__r0],0
4A66: B0 0F    JNZ   0x4A76
4A68: 3C B5 00 CMP   [__r1],0
4A6B: B0 0A    JNZ   0x4A76
(0157) 				{
(0158) 					UART_PutCRLF();
4A6D: 10       PUSH  X
4A6E: 7C 0A CF LCALL 0x0ACF
4A71: 20       POP   X
(0159) 					Cmd_Imp();
4A72: 91 AC    CALL  _Cmd_Imp
(0160) 				}
4A74: 80 4C    JMP   0x4AC1
(0161)     			else if(!cstrcmp((const char*)gszCmdMeasRaw,(char*)strPtr))
4A76: 52 00    MOV   A,[X+0]
4A78: 08       PUSH  A
4A79: 52 01    MOV   A,[X+1]
4A7B: 08       PUSH  A
4A7C: 50 04    MOV   A,4
4A7E: 08       PUSH  A
4A7F: 50 EF    MOV   A,239
4A81: 08       PUSH  A
4A82: 7C 57 EA LCALL _cstrcmpLMM
4A85: 38 FC    ADD   SP,252
4A87: 62 D0 02 MOV   REG[208],2
4A8A: 3C B6 00 CMP   [__r0],0
4A8D: B0 0F    JNZ   0x4A9D
4A8F: 3C B5 00 CMP   [__r1],0
4A92: B0 0A    JNZ   0x4A9D
(0162) 				{
(0163) 					UART_PutCRLF();
4A94: 10       PUSH  X
4A95: 7C 0A CF LCALL 0x0ACF
4A98: 20       POP   X
(0164) 					Cmd_Raw();
4A99: 93 02    CALL  _Cmd_Raw
(0165) 				}
4A9B: 80 25    JMP   0x4AC1
(0166) 				else
(0167) 				{
(0168) 					UART_CPutString(gszErrCmdNotFound1);
4A9D: 10       PUSH  X
4A9E: 50 05    MOV   A,5
4AA0: 08       PUSH  A
4AA1: 50 B8    MOV   A,184
4AA3: 5C       MOV   X,A
4AA4: 18       POP   A
4AA5: 7C 0A BD LCALL 0x0ABD
4AA8: 20       POP   X
(0169) 					UART_PutString(strPtr);
4AA9: 10       PUSH  X
4AAA: 52 00    MOV   A,[X+0]
4AAC: 08       PUSH  A
4AAD: 52 01    MOV   A,[X+1]
4AAF: 5C       MOV   X,A
4AB0: 18       POP   A
4AB1: 7C 0A 57 LCALL 0x0A57
4AB4: 20       POP   X
(0170) 					UART_CPutString(gszErrCmdNotFound2);
4AB5: 10       PUSH  X
4AB6: 50 05    MOV   A,5
4AB8: 08       PUSH  A
4AB9: 50 C4    MOV   A,196
4ABB: 5C       MOV   X,A
4ABC: 18       POP   A
4ABD: 7C 0A BD LCALL 0x0ABD
4AC0: 20       POP   X
(0171) 				}
(0172) 			}
(0173) 			UART_CmdReset(); // Reset command buffer
4AC1: 10       PUSH  X
4AC2: 7C 0A D8 LCALL 0x0AD8
4AC5: 20       POP   X
(0174) 			UART_CPutString(gszCmdPrompt);
4AC6: 10       PUSH  X
4AC7: 50 05    MOV   A,5
4AC9: 08       PUSH  A
4ACA: 50 1B    MOV   A,27
4ACC: 5C       MOV   X,A
4ACD: 18       POP   A
4ACE: 7C 0A BD LCALL 0x0ABD
4AD1: 20       POP   X
4AD2: 8E 68    JMP   0x493B
(0175) 		}
(0176) 	}
(0177) 	DDS_Set(0);
4AD4: 50 00    MOV   A,0
4AD6: 08       PUSH  A
4AD7: 08       PUSH  A
4AD8: 08       PUSH  A
4AD9: 08       PUSH  A
4ADA: 7C 28 DC LCALL _DDS_Set
4ADD: 38 FC    ADD   SP,252
(0178) 	UART_Stop();
4ADF: 10       PUSH  X
4AE0: 7C 09 AF LCALL 0x09AF
4AE3: 20       POP   X
4AE4: 38 FE    ADD   SP,254
4AE6: 20       POP   X
4AE7: 7F       RET   
(0179) }
(0180) 
(0181) //-----------------------------------------------------------------------------
(0182) //  FUNCTION NAME:	Cmd_On
(0183) //
(0184) //  DESCRIPTION:
(0185) //
(0186) //	Process on (enable DDS) command
(0187) //
(0188) //  ARGUMENTS:
(0189) //     none.
(0190) //
(0191) //  RETURNS:
(0192) //     none.
(0193) //
(0194) //-----------------------------------------------------------------------------
(0195) static void Cmd_On (void)
(0196) {
(0197) 	if (gdwCurrentFreq==-1)
_Cmd_On:
4AE8: 62 D0 02 MOV   REG[208],2
4AEB: 3C DD FF CMP   [gdwCurrentFreq],255
4AEE: B0 1E    JNZ   0x4B0D
4AF0: 3C DE FF CMP   [gdwCurrentFreq+1],255
4AF3: B0 19    JNZ   0x4B0D
4AF5: 3C DF FF CMP   [gdwCurrentFreq+2],255
4AF8: B0 14    JNZ   0x4B0D
4AFA: 3C E0 FF CMP   [gdwCurrentFreq+3],255
4AFD: B0 0F    JNZ   0x4B0D
(0198) 	{
(0199) 		UART_CPutString(gszErrFreqNotSet);
4AFF: 10       PUSH  X
4B00: 50 05    MOV   A,5
4B02: 08       PUSH  A
4B03: 50 4E    MOV   A,78
4B05: 5C       MOV   X,A
4B06: 18       POP   A
4B07: 7C 0A BD LCALL 0x0ABD
4B0A: 20       POP   X
(0200) 	}
4B0B: 80 21    JMP   0x4B2D
(0201) 	else
(0202) 	{
(0203) 		DDS_Set(gdwCurrentFreq);
4B0D: 62 D0 02 MOV   REG[208],2
4B10: 51 DD    MOV   A,[gdwCurrentFreq]
4B12: 08       PUSH  A
4B13: 51 DE    MOV   A,[gdwCurrentFreq+1]
4B15: 08       PUSH  A
4B16: 51 DF    MOV   A,[gdwCurrentFreq+2]
4B18: 08       PUSH  A
4B19: 51 E0    MOV   A,[gdwCurrentFreq+3]
4B1B: 08       PUSH  A
4B1C: 7C 28 DC LCALL _DDS_Set
4B1F: 38 FC    ADD   SP,252
(0204) 		UART_CPutString(gszOk);
4B21: 10       PUSH  X
4B22: 50 05    MOV   A,5
4B24: 08       PUSH  A
4B25: 50 2D    MOV   A,45
4B27: 5C       MOV   X,A
4B28: 18       POP   A
4B29: 7C 0A BD LCALL 0x0ABD
4B2C: 20       POP   X
(0205) 	}
4B2D: 7F       RET   
(0206) }
(0207) 
(0208) //-----------------------------------------------------------------------------
(0209) //  FUNCTION NAME:	Cmd_Off
(0210) //
(0211) //  DESCRIPTION:
(0212) //
(0213) //	Process on command
(0214) //
(0215) //  ARGUMENTS:
(0216) //     none.
(0217) //
(0218) //  RETURNS:
(0219) //     none.
(0220) //
(0221) //-----------------------------------------------------------------------------
(0222) static void Cmd_Off (void)
(0223) {
(0224) 	DDS_Set(0);
_Cmd_Off:
4B2E: 50 00    MOV   A,0
4B30: 08       PUSH  A
4B31: 08       PUSH  A
4B32: 08       PUSH  A
4B33: 08       PUSH  A
4B34: 7C 28 DC LCALL _DDS_Set
4B37: 38 FC    ADD   SP,252
(0225) 	UART_CPutString(gszOk);
4B39: 10       PUSH  X
4B3A: 50 05    MOV   A,5
4B3C: 08       PUSH  A
4B3D: 50 2D    MOV   A,45
4B3F: 5C       MOV   X,A
4B40: 18       POP   A
4B41: 7C 0A BD LCALL 0x0ABD
4B44: 20       POP   X
4B45: 7F       RET   
(0226) }
(0227) 
(0228) //-----------------------------------------------------------------------------
(0229) //  FUNCTION NAME:	Cmd_Freq
(0230) //
(0231) //  DESCRIPTION:
(0232) //
(0233) //	Process freq (set frequency) command
(0234) //
(0235) //  ARGUMENTS:
(0236) //     none.
(0237) //
(0238) //  RETURNS:
(0239) //     none.
(0240) //
(0241) //-----------------------------------------------------------------------------
(0242) static void Cmd_Freq (void)
(0243) {
_Cmd_Freq:
  strPtr               --> X+1
  bBand                --> X+0
4B46: 10       PUSH  X
4B47: 4F       MOV   X,SP
4B48: 38 03    ADD   SP,3
(0244) 	char * strPtr; 						// Parameter pointer
(0245) 	BYTE bBand;
(0246) 
(0247) 	do
(0248) 	{
(0249) 		strPtr = UART_szGetParam();
4B4A: 10       PUSH  X
4B4B: 7C 0B 07 LCALL 0x0B07
4B4E: 62 D0 02 MOV   REG[208],2
4B51: 53 B6    MOV   [__r0],A
4B53: 5A B5    MOV   [__r1],X
4B55: 20       POP   X
4B56: 51 B5    MOV   A,[__r1]
4B58: 54 02    MOV   [X+2],A
4B5A: 51 B6    MOV   A,[__r0]
4B5C: 54 01    MOV   [X+1],A
(0250) 		if (strPtr==NULL)
4B5E: 3D 01 00 CMP   [X+1],0
4B61: B0 14    JNZ   0x4B76
4B63: 3D 02 00 CMP   [X+2],0
4B66: B0 0F    JNZ   0x4B76
(0251) 		{
(0252) 			UART_CPutString(gszErrExpectFreq);
4B68: 10       PUSH  X
4B69: 50 05    MOV   A,5
4B6B: 08       PUSH  A
4B6C: 50 66    MOV   A,102
4B6E: 5C       MOV   X,A
4B6F: 18       POP   A
4B70: 7C 0A BD LCALL 0x0ABD
4B73: 20       POP   X
(0253) 			break;
4B74: 80 A7    JMP   0x4C1C
(0254) 		}
(0255) 		gdwCurrentFreq = atol(strPtr);
4B76: 52 01    MOV   A,[X+1]
4B78: 08       PUSH  A
4B79: 52 02    MOV   A,[X+2]
4B7B: 08       PUSH  A
4B7C: 7C 58 46 LCALL _atol
4B7F: 38 FE    ADD   SP,254
4B81: 62 D0 02 MOV   REG[208],2
4B84: 51 B6    MOV   A,[__r0]
4B86: 08       PUSH  A
4B87: 51 B5    MOV   A,[__r1]
4B89: 08       PUSH  A
4B8A: 51 B4    MOV   A,[__r2]
4B8C: 08       PUSH  A
4B8D: 51 B3    MOV   A,[__r3]
4B8F: 62 D0 02 MOV   REG[208],2
4B92: 53 E0    MOV   [gdwCurrentFreq+3],A
4B94: 18       POP   A
4B95: 53 DF    MOV   [gdwCurrentFreq+2],A
4B97: 18       POP   A
4B98: 53 DE    MOV   [gdwCurrentFreq+1],A
4B9A: 18       POP   A
4B9B: 53 DD    MOV   [gdwCurrentFreq],A
(0256) 		bBand = GetBand(gdwCurrentFreq);
4B9D: 51 DD    MOV   A,[gdwCurrentFreq]
4B9F: 08       PUSH  A
4BA0: 51 DE    MOV   A,[gdwCurrentFreq+1]
4BA2: 08       PUSH  A
4BA3: 51 DF    MOV   A,[gdwCurrentFreq+2]
4BA5: 08       PUSH  A
4BA6: 51 E0    MOV   A,[gdwCurrentFreq+3]
4BA8: 08       PUSH  A
4BA9: 7C 54 82 LCALL _GetBand
4BAC: 38 FC    ADD   SP,252
4BAE: 62 D0 02 MOV   REG[208],2
4BB1: 54 00    MOV   [X+0],A
(0257) 		if (bBand==-1)
4BB3: 3D 00 FF CMP   [X+0],255
4BB6: B0 0F    JNZ   0x4BC6
(0258) 		{
(0259) 			UART_CPutString(gszErrInvalidFreq);
4BB8: 10       PUSH  X
4BB9: 50 05    MOV   A,5
4BBB: 08       PUSH  A
4BBC: 50 A0    MOV   A,160
4BBE: 5C       MOV   X,A
4BBF: 18       POP   A
4BC0: 7C 0A BD LCALL 0x0ABD
4BC3: 20       POP   X
(0260) 			break;
4BC4: 80 57    JMP   0x4C1C
(0261) 		}
(0262) 		g_xBridgeCorrect = g_xBandCorrFactor[bBand];
4BC6: 62 D0 02 MOV   REG[208],2
4BC9: 52 00    MOV   A,[X+0]
4BCB: 53 B5    MOV   [__r1],A
4BCD: 50 00    MOV   A,0
4BCF: 08       PUSH  A
4BD0: 51 B5    MOV   A,[__r1]
4BD2: 08       PUSH  A
4BD3: 50 00    MOV   A,0
4BD5: 08       PUSH  A
4BD6: 50 0C    MOV   A,12
4BD8: 08       PUSH  A
4BD9: 7C 56 FD LCALL __mul16
4BDC: 38 FC    ADD   SP,252
4BDE: 51 AC    MOV   A,[__rX]
4BE0: 53 B5    MOV   [__r1],A
4BE2: 51 AB    MOV   A,[__rY]
4BE4: 53 B6    MOV   [__r0],A
4BE6: 06 B5 0B ADD   [__r1],11
4BE9: 0E B6 00 ADC   [__r0],0
4BEC: 55 B3 EB MOV   [__r3],235
4BEF: 55 B4 00 MOV   [__r2],0
4BF2: 51 B6    MOV   A,[__r0]
4BF4: 60 D4    MOV   REG[212],A
4BF6: 51 B4    MOV   A,[__r2]
4BF8: 60 D5    MOV   REG[213],A
4BFA: 10       PUSH  X
4BFB: 57 0C    MOV   X,12
4BFD: 62 D0 02 MOV   REG[208],2
4C00: 3E B5    MVI   A,[__r1]
4C02: 3F B3    MVI   [__r3],A
4C04: 79       DEC   X
4C05: BF F7    JNZ   0x4BFD
4C07: 20       POP   X
(0263) 		Adjust_Dds_Gain(bBand);
4C08: 52 00    MOV   A,[X+0]
4C0A: 08       PUSH  A
4C0B: 7C 25 35 LCALL _Adjust_Dds_Gain
4C0E: 38 FF    ADD   SP,255
(0264) 		UART_CPutString(gszOk);
4C10: 10       PUSH  X
4C11: 50 05    MOV   A,5
4C13: 08       PUSH  A
4C14: 50 2D    MOV   A,45
4C16: 5C       MOV   X,A
4C17: 18       POP   A
4C18: 7C 0A BD LCALL 0x0ABD
4C1B: 20       POP   X
(0265) 	} while (FALSE);
4C1C: 38 FD    ADD   SP,253
4C1E: 20       POP   X
4C1F: 7F       RET   
(0266) }
(0267) 
(0268) //-----------------------------------------------------------------------------
(0269) //  FUNCTION NAME:	Cmd_Imp
(0270) //
(0271) //  DESCRIPTION:
(0272) //
(0273) //	Process imp (impedance) command
(0274) //
(0275) //  ARGUMENTS:
(0276) //     none.
(0277) //
(0278) //  RETURNS:
(0279) //     none.
(0280) //
(0281) //-----------------------------------------------------------------------------
(0282) static void Cmd_Imp (void)
(0283) {
_Cmd_Imp:
  szMsg                --> X+0
4C20: 10       PUSH  X
4C21: 4F       MOV   X,SP
4C22: 38 14    ADD   SP,20
(0284) 	BYTE szMsg[20];
(0285) 
(0286) 	Do_Measure();
4C24: 7C 47 0E LCALL _Do_Measure
(0287) 	Do_Correct();
4C27: 7C 23 F1 LCALL _Do_Correct
(0288) 
(0289) 	gwSwr = Calculate_Swr(g_xBridgeMeasure.Vf, g_xBridgeMeasure.Vr);
4C2A: 62 D0 02 MOV   REG[208],2
4C2D: 51 90    MOV   A,[144]
4C2F: 08       PUSH  A
4C30: 51 91    MOV   A,[145]
4C32: 08       PUSH  A
4C33: 51 92    MOV   A,[146]
4C35: 08       PUSH  A
4C36: 51 93    MOV   A,[147]
4C38: 08       PUSH  A
4C39: 51 8C    MOV   A,[g_xBridgeMeasure]
4C3B: 08       PUSH  A
4C3C: 51 8D    MOV   A,[g_xBridgeMeasure+1]
4C3E: 08       PUSH  A
4C3F: 51 8E    MOV   A,[g_xBridgeMeasure+2]
4C41: 08       PUSH  A
4C42: 51 8F    MOV   A,[g_xBridgeMeasure+3]
4C44: 08       PUSH  A
4C45: 7C 12 F0 LCALL _Calculate_Swr
4C48: 38 F8    ADD   SP,248
4C4A: 62 D0 02 MOV   REG[208],2
4C4D: 51 B5    MOV   A,[__r1]
4C4F: 08       PUSH  A
4C50: 51 B6    MOV   A,[__r0]
4C52: 62 D0 02 MOV   REG[208],2
4C55: 53 EB    MOV   [gwSwr],A
4C57: 18       POP   A
4C58: 53 EC    MOV   [gwSwr+1],A
(0290) 	gwZ = Calculate_Z(g_xBridgeMeasure.Vz, g_xBridgeMeasure.Va);
4C5A: 62 D0 02 MOV   REG[208],2
4C5D: 51 94    MOV   A,[148]
4C5F: 08       PUSH  A
4C60: 51 95    MOV   A,[149]
4C62: 08       PUSH  A
4C63: 51 96    MOV   A,[150]
4C65: 08       PUSH  A
4C66: 51 97    MOV   A,[151]
4C68: 08       PUSH  A
4C69: 51 98    MOV   A,[152]
4C6B: 08       PUSH  A
4C6C: 51 99    MOV   A,[153]
4C6E: 08       PUSH  A
4C6F: 51 9A    MOV   A,[154]
4C71: 08       PUSH  A
4C72: 51 9B    MOV   A,[155]
4C74: 08       PUSH  A
4C75: 7C 13 BC LCALL _Calculate_Z
4C78: 38 F8    ADD   SP,248
4C7A: 62 D0 02 MOV   REG[208],2
4C7D: 51 B5    MOV   A,[__r1]
4C7F: 08       PUSH  A
4C80: 51 B6    MOV   A,[__r0]
4C82: 62 D0 02 MOV   REG[208],2
4C85: 53 E9    MOV   [gwZ],A
4C87: 18       POP   A
4C88: 53 EA    MOV   [gwZ+1],A
(0291) 	gwR = Calculate_R(gwZ, gwSwr);
4C8A: 62 D0 02 MOV   REG[208],2
4C8D: 51 EB    MOV   A,[gwSwr]
4C8F: 08       PUSH  A
4C90: 51 EC    MOV   A,[gwSwr+1]
4C92: 08       PUSH  A
4C93: 62 D0 02 MOV   REG[208],2
4C96: 51 E9    MOV   A,[gwZ]
4C98: 08       PUSH  A
4C99: 51 EA    MOV   A,[gwZ+1]
4C9B: 08       PUSH  A
4C9C: 7C 14 5E LCALL _Calculate_R
4C9F: 38 FC    ADD   SP,252
4CA1: 62 D0 02 MOV   REG[208],2
4CA4: 51 B5    MOV   A,[__r1]
4CA6: 08       PUSH  A
4CA7: 51 B6    MOV   A,[__r0]
4CA9: 62 D0 02 MOV   REG[208],2
4CAC: 53 E5    MOV   [gwR],A
4CAE: 18       POP   A
4CAF: 53 E6    MOV   [gwR+1],A
(0292) 	gwX = Calculate_X(gwZ, gwR);
4CB1: 51 E5    MOV   A,[gwR]
4CB3: 08       PUSH  A
4CB4: 51 E6    MOV   A,[gwR+1]
4CB6: 08       PUSH  A
4CB7: 62 D0 02 MOV   REG[208],2
4CBA: 51 E9    MOV   A,[gwZ]
4CBC: 08       PUSH  A
4CBD: 51 EA    MOV   A,[gwZ+1]
4CBF: 08       PUSH  A
4CC0: 7C 15 6D LCALL _Calculate_X
4CC3: 38 FC    ADD   SP,252
4CC5: 62 D0 02 MOV   REG[208],2
4CC8: 51 B5    MOV   A,[__r1]
4CCA: 08       PUSH  A
4CCB: 51 B6    MOV   A,[__r0]
4CCD: 62 D0 02 MOV   REG[208],2
4CD0: 53 E7    MOV   [gwX],A
4CD2: 18       POP   A
4CD3: 53 E8    MOV   [gwX+1],A
(0293) 
(0294) 	itoa(szMsg, gwSwr, 10);
4CD5: 50 00    MOV   A,0
4CD7: 08       PUSH  A
4CD8: 50 0A    MOV   A,10
4CDA: 08       PUSH  A
4CDB: 62 D0 02 MOV   REG[208],2
4CDE: 51 EB    MOV   A,[gwSwr]
4CE0: 08       PUSH  A
4CE1: 51 EC    MOV   A,[gwSwr+1]
4CE3: 08       PUSH  A
4CE4: 62 D0 02 MOV   REG[208],2
4CE7: 50 07    MOV   A,7
4CE9: 08       PUSH  A
4CEA: 10       PUSH  X
4CEB: 7C 59 A6 LCALL _itoa
4CEE: 38 FA    ADD   SP,250
(0295) 	UART_PutChar( szMsg[0] );
4CF0: 10       PUSH  X
4CF1: 52 00    MOV   A,[X+0]
4CF3: 7C 0A 1A LCALL 0x0A1A
4CF6: 20       POP   X
(0296) 	UART_PutChar( '.' );
4CF7: 10       PUSH  X
4CF8: 50 2E    MOV   A,46
4CFA: 7C 0A 1A LCALL 0x0A1A
4CFD: 20       POP   X
(0297) 	UART_PutChar( szMsg[1] );
4CFE: 10       PUSH  X
4CFF: 52 01    MOV   A,[X+1]
4D01: 7C 0A 1A LCALL 0x0A1A
4D04: 20       POP   X
(0298) 	UART_PutChar( szMsg[2] );
4D05: 10       PUSH  X
4D06: 52 02    MOV   A,[X+2]
4D08: 7C 0A 1A LCALL 0x0A1A
4D0B: 20       POP   X
(0299) 
(0300) 	UART_PutChar(',');
4D0C: 10       PUSH  X
4D0D: 50 2C    MOV   A,44
4D0F: 7C 0A 1A LCALL 0x0A1A
4D12: 20       POP   X
(0301) 	itoa(szMsg, gwR, 10);
4D13: 50 00    MOV   A,0
4D15: 08       PUSH  A
4D16: 50 0A    MOV   A,10
4D18: 08       PUSH  A
4D19: 62 D0 02 MOV   REG[208],2
4D1C: 51 E5    MOV   A,[gwR]
4D1E: 08       PUSH  A
4D1F: 51 E6    MOV   A,[gwR+1]
4D21: 08       PUSH  A
4D22: 62 D0 02 MOV   REG[208],2
4D25: 50 07    MOV   A,7
4D27: 08       PUSH  A
4D28: 10       PUSH  X
4D29: 7C 59 A6 LCALL _itoa
4D2C: 38 FA    ADD   SP,250
(0302) 	UART_PutString(szMsg);
4D2E: 62 D0 02 MOV   REG[208],2
4D31: 10       PUSH  X
4D32: 50 07    MOV   A,7
4D34: 08       PUSH  A
4D35: 18       POP   A
4D36: 7C 0A 57 LCALL 0x0A57
4D39: 20       POP   X
(0303) 
(0304) 	UART_PutChar(',');
4D3A: 10       PUSH  X
4D3B: 50 2C    MOV   A,44
4D3D: 7C 0A 1A LCALL 0x0A1A
4D40: 20       POP   X
(0305) 	itoa(szMsg, gwX, 10);
4D41: 50 00    MOV   A,0
4D43: 08       PUSH  A
4D44: 50 0A    MOV   A,10
4D46: 08       PUSH  A
4D47: 62 D0 02 MOV   REG[208],2
4D4A: 51 E7    MOV   A,[gwX]
4D4C: 08       PUSH  A
4D4D: 51 E8    MOV   A,[gwX+1]
4D4F: 08       PUSH  A
4D50: 62 D0 02 MOV   REG[208],2
4D53: 50 07    MOV   A,7
4D55: 08       PUSH  A
4D56: 10       PUSH  X
4D57: 7C 59 A6 LCALL _itoa
4D5A: 38 FA    ADD   SP,250
(0306) 	UART_PutString(szMsg);
4D5C: 62 D0 02 MOV   REG[208],2
4D5F: 10       PUSH  X
4D60: 50 07    MOV   A,7
4D62: 08       PUSH  A
4D63: 18       POP   A
4D64: 7C 0A 57 LCALL 0x0A57
4D67: 20       POP   X
(0307) 
(0308) 	UART_PutChar(',');
4D68: 10       PUSH  X
4D69: 50 2C    MOV   A,44
4D6B: 7C 0A 1A LCALL 0x0A1A
4D6E: 20       POP   X
(0309) 	itoa(szMsg, gwZ, 10);
4D6F: 50 00    MOV   A,0
4D71: 08       PUSH  A
4D72: 50 0A    MOV   A,10
4D74: 08       PUSH  A
4D75: 62 D0 02 MOV   REG[208],2
4D78: 51 E9    MOV   A,[gwZ]
4D7A: 08       PUSH  A
4D7B: 51 EA    MOV   A,[gwZ+1]
4D7D: 08       PUSH  A
4D7E: 62 D0 02 MOV   REG[208],2
4D81: 50 07    MOV   A,7
4D83: 08       PUSH  A
4D84: 10       PUSH  X
4D85: 7C 59 A6 LCALL _itoa
4D88: 38 FA    ADD   SP,250
(0310) 	UART_PutString(szMsg);
4D8A: 62 D0 02 MOV   REG[208],2
4D8D: 10       PUSH  X
4D8E: 50 07    MOV   A,7
4D90: 08       PUSH  A
4D91: 18       POP   A
4D92: 7C 0A 57 LCALL 0x0A57
(0311) 
(0312) 	UART_PutCRLF();
4D95: 7C 0A CF LCALL 0x0ACF
4D98: 20       POP   X
4D99: 38 EC    ADD   SP,236
4D9B: 20       POP   X
4D9C: 7F       RET   
(0313) }
(0314) 
(0315) //-----------------------------------------------------------------------------
(0316) //  FUNCTION NAME:	Cmd_Raw
(0317) //
(0318) //  DESCRIPTION:
(0319) //
(0320) //	Process raw (raw measurement data) command
(0321) //
(0322) //  ARGUMENTS:
(0323) //     none.
(0324) //
(0325) //  RETURNS:
(0326) //     none.
(0327) //
(0328) //-----------------------------------------------------------------------------
(0329) static void Cmd_Raw (void)
(0330) {
_Cmd_Raw:
  szMsg                --> X+0
4D9D: 10       PUSH  X
4D9E: 4F       MOV   X,SP
4D9F: 38 14    ADD   SP,20
(0331) 	BYTE szMsg[20];
(0332) 
(0333) 	Do_Measure();
4DA1: 7C 47 0E LCALL _Do_Measure
(0334) 	Do_Correct();
4DA4: 7C 23 F1 LCALL _Do_Correct
(0335) 
(0336) 	ltoa(szMsg, g_xBridgeMeasure.Vf, 10);
4DA7: 50 00    MOV   A,0
4DA9: 08       PUSH  A
4DAA: 50 0A    MOV   A,10
4DAC: 08       PUSH  A
4DAD: 62 D0 02 MOV   REG[208],2
4DB0: 51 8C    MOV   A,[g_xBridgeMeasure]
4DB2: 08       PUSH  A
4DB3: 51 8D    MOV   A,[g_xBridgeMeasure+1]
4DB5: 08       PUSH  A
4DB6: 51 8E    MOV   A,[g_xBridgeMeasure+2]
4DB8: 08       PUSH  A
4DB9: 51 8F    MOV   A,[g_xBridgeMeasure+3]
4DBB: 08       PUSH  A
4DBC: 62 D0 02 MOV   REG[208],2
4DBF: 50 07    MOV   A,7
4DC1: 08       PUSH  A
4DC2: 10       PUSH  X
4DC3: 7C 5B 7F LCALL _ltoa
4DC6: 38 F8    ADD   SP,248
(0337) 	UART_PutString(szMsg);
4DC8: 62 D0 02 MOV   REG[208],2
4DCB: 10       PUSH  X
4DCC: 50 07    MOV   A,7
4DCE: 08       PUSH  A
4DCF: 18       POP   A
4DD0: 7C 0A 57 LCALL 0x0A57
4DD3: 20       POP   X
(0338) 
(0339) 	UART_PutChar(',');
4DD4: 10       PUSH  X
4DD5: 50 2C    MOV   A,44
4DD7: 7C 0A 1A LCALL 0x0A1A
4DDA: 20       POP   X
(0340) 	ltoa(szMsg, g_xBridgeMeasure.Vr, 10);
4DDB: 50 00    MOV   A,0
4DDD: 08       PUSH  A
4DDE: 50 0A    MOV   A,10
4DE0: 08       PUSH  A
4DE1: 62 D0 02 MOV   REG[208],2
4DE4: 51 90    MOV   A,[144]
4DE6: 08       PUSH  A
4DE7: 51 91    MOV   A,[145]
4DE9: 08       PUSH  A
4DEA: 51 92    MOV   A,[146]
4DEC: 08       PUSH  A
4DED: 51 93    MOV   A,[147]
4DEF: 08       PUSH  A
4DF0: 62 D0 02 MOV   REG[208],2
4DF3: 50 07    MOV   A,7
4DF5: 08       PUSH  A
4DF6: 10       PUSH  X
4DF7: 7C 5B 7F LCALL _ltoa
4DFA: 38 F8    ADD   SP,248
(0341) 	UART_PutString(szMsg);
4DFC: 62 D0 02 MOV   REG[208],2
4DFF: 10       PUSH  X
4E00: 50 07    MOV   A,7
4E02: 08       PUSH  A
4E03: 18       POP   A
4E04: 7C 0A 57 LCALL 0x0A57
4E07: 20       POP   X
(0342) 
(0343) 	UART_PutChar(',');
4E08: 10       PUSH  X
4E09: 50 2C    MOV   A,44
4E0B: 7C 0A 1A LCALL 0x0A1A
4E0E: 20       POP   X
(0344) 	ltoa(szMsg, g_xBridgeMeasure.Vz, 10);
4E0F: 50 00    MOV   A,0
4E11: 08       PUSH  A
4E12: 50 0A    MOV   A,10
4E14: 08       PUSH  A
4E15: 62 D0 02 MOV   REG[208],2
4E18: 51 98    MOV   A,[152]
4E1A: 08       PUSH  A
4E1B: 51 99    MOV   A,[153]
4E1D: 08       PUSH  A
4E1E: 51 9A    MOV   A,[154]
4E20: 08       PUSH  A
4E21: 51 9B    MOV   A,[155]
4E23: 08       PUSH  A
4E24: 62 D0 02 MOV   REG[208],2
4E27: 50 07    MOV   A,7
4E29: 08       PUSH  A
4E2A: 10       PUSH  X
4E2B: 7C 5B 7F LCALL _ltoa
4E2E: 38 F8    ADD   SP,248
(0345) 	UART_PutString(szMsg);
4E30: 62 D0 02 MOV   REG[208],2
4E33: 10       PUSH  X
4E34: 50 07    MOV   A,7
4E36: 08       PUSH  A
4E37: 18       POP   A
4E38: 7C 0A 57 LCALL 0x0A57
4E3B: 20       POP   X
(0346) 
(0347) 	UART_PutChar(',');
4E3C: 10       PUSH  X
4E3D: 50 2C    MOV   A,44
4E3F: 7C 0A 1A LCALL 0x0A1A
4E42: 20       POP   X
(0348) 	ltoa(szMsg, g_xBridgeMeasure.Va, 10);
4E43: 50 00    MOV   A,0
4E45: 08       PUSH  A
4E46: 50 0A    MOV   A,10
4E48: 08       PUSH  A
4E49: 62 D0 02 MOV   REG[208],2
4E4C: 51 94    MOV   A,[148]
4E4E: 08       PUSH  A
4E4F: 51 95    MOV   A,[149]
4E51: 08       PUSH  A
4E52: 51 96    MOV   A,[150]
4E54: 08       PUSH  A
4E55: 51 97    MOV   A,[151]
4E57: 08       PUSH  A
4E58: 62 D0 02 MOV   REG[208],2
4E5B: 50 07    MOV   A,7
4E5D: 08       PUSH  A
4E5E: 10       PUSH  X
4E5F: 7C 5B 7F LCALL _ltoa
4E62: 38 F8    ADD   SP,248
(0349) 	UART_PutString(szMsg);
4E64: 62 D0 02 MOV   REG[208],2
4E67: 10       PUSH  X
4E68: 50 07    MOV   A,7
4E6A: 08       PUSH  A
4E6B: 18       POP   A
4E6C: 7C 0A 57 LCALL 0x0A57
(0350) 
(0351) 	UART_PutCRLF();
4E6F: 7C 0A CF LCALL 0x0ACF
4E72: 20       POP   X
4E73: 38 EC    ADD   SP,236
4E75: 20       POP   X
4E76: 7F       RET   
(0352) }
(0353) 
(0354) //-----------------------------------------------------------------------------
(0355) //  FUNCTION NAME:	Cmd_Scan
(0356) //
(0357) //  DESCRIPTION:
(0358) //
(0359) //	Process scan command
(0360) //
(0361) //  ARGUMENTS:
(0362) //     none.
(0363) //
(0364) //  RETURNS:
(0365) //     none.
(0366) //
(0367) //-----------------------------------------------------------------------------
(0368) static void Cmd_Scan (BYTE bRaw)
(0369) {
_Cmd_Scan:
  dwLimitFreq          --> X+16
  strPtr               --> X+14
  dwStepFreq           --> X+10
  dwEndFreq            --> X+6
  bBandSave            --> X+5
  bBand                --> X+4
  dwFreq               --> X+0
  bRaw                 --> X-4
4E77: 10       PUSH  X
4E78: 4F       MOV   X,SP
4E79: 38 14    ADD   SP,20
(0370) 	DWORD dwFreq;
(0371) 	DWORD dwEndFreq;
(0372) 	DWORD dwLimitFreq;
(0373) 	DWORD dwStepFreq;
(0374) 	BYTE bBand;
(0375) 	BYTE bBandSave;
(0376) 	char * strPtr; 						// Parameter pointer
(0377) 
(0378) 	g_bScanning = FALSE;
4E7B: 62 D0 02 MOV   REG[208],2
4E7E: 55 F4 00 MOV   [g_bScanning],0
(0379) 	do
(0380) 	{
(0381) 										// Get start frequency
(0382) 		strPtr = UART_szGetParam();
4E81: 10       PUSH  X
4E82: 7C 0B 07 LCALL 0x0B07
4E85: 62 D0 02 MOV   REG[208],2
4E88: 53 B6    MOV   [__r0],A
4E8A: 5A B5    MOV   [__r1],X
4E8C: 20       POP   X
4E8D: 51 B5    MOV   A,[__r1]
4E8F: 54 0F    MOV   [X+15],A
4E91: 51 B6    MOV   A,[__r0]
4E93: 54 0E    MOV   [X+14],A
(0383) 		if (strPtr==NULL)
4E95: 3D 0E 00 CMP   [X+14],0
4E98: B0 14    JNZ   0x4EAD
4E9A: 3D 0F 00 CMP   [X+15],0
4E9D: B0 0F    JNZ   0x4EAD
(0384) 		{
(0385) 			UART_CPutString(gszErrExpectFreq);
4E9F: 10       PUSH  X
4EA0: 50 05    MOV   A,5
4EA2: 08       PUSH  A
4EA3: 50 66    MOV   A,102
4EA5: 5C       MOV   X,A
4EA6: 18       POP   A
4EA7: 7C 0A BD LCALL 0x0ABD
4EAA: 20       POP   X
(0386) 			break;
4EAB: 81 F7    JMP   0x50A3
(0387) 		}
(0388) 		dwFreq = atol(strPtr);
4EAD: 52 0E    MOV   A,[X+14]
4EAF: 08       PUSH  A
4EB0: 52 0F    MOV   A,[X+15]
4EB2: 08       PUSH  A
4EB3: 7C 58 46 LCALL _atol
4EB6: 62 D0 02 MOV   REG[208],2
4EB9: 51 B6    MOV   A,[__r0]
4EBB: 54 00    MOV   [X+0],A
4EBD: 51 B5    MOV   A,[__r1]
4EBF: 54 01    MOV   [X+1],A
4EC1: 51 B4    MOV   A,[__r2]
4EC3: 54 02    MOV   [X+2],A
4EC5: 51 B3    MOV   A,[__r3]
4EC7: 54 03    MOV   [X+3],A
(0389) 		bBand = GetBand(dwFreq);
4EC9: 52 00    MOV   A,[X+0]
4ECB: 08       PUSH  A
4ECC: 52 01    MOV   A,[X+1]
4ECE: 08       PUSH  A
4ECF: 52 02    MOV   A,[X+2]
4ED1: 08       PUSH  A
4ED2: 52 03    MOV   A,[X+3]
4ED4: 08       PUSH  A
4ED5: 7C 54 82 LCALL _GetBand
4ED8: 38 FA    ADD   SP,250
4EDA: 62 D0 02 MOV   REG[208],2
4EDD: 54 04    MOV   [X+4],A
(0390) 		if (bBand==-1)
4EDF: 3D 04 FF CMP   [X+4],255
4EE2: B0 0F    JNZ   0x4EF2
(0391) 		{
(0392) 			UART_CPutString(gszErrInvalidFreq);
4EE4: 10       PUSH  X
4EE5: 50 05    MOV   A,5
4EE7: 08       PUSH  A
4EE8: 50 A0    MOV   A,160
4EEA: 5C       MOV   X,A
4EEB: 18       POP   A
4EEC: 7C 0A BD LCALL 0x0ABD
4EEF: 20       POP   X
(0393) 			break;
4EF0: 81 B2    JMP   0x50A3
(0394) 		}
(0395) 										// Get end frequency
(0396) 		strPtr = UART_szGetParam();
4EF2: 10       PUSH  X
4EF3: 7C 0B 07 LCALL 0x0B07
4EF6: 62 D0 02 MOV   REG[208],2
4EF9: 53 B6    MOV   [__r0],A
4EFB: 5A B5    MOV   [__r1],X
4EFD: 20       POP   X
4EFE: 51 B5    MOV   A,[__r1]
4F00: 54 0F    MOV   [X+15],A
4F02: 51 B6    MOV   A,[__r0]
4F04: 54 0E    MOV   [X+14],A
(0397) 		if (strPtr==NULL)
4F06: 3D 0E 00 CMP   [X+14],0
4F09: B0 14    JNZ   0x4F1E
4F0B: 3D 0F 00 CMP   [X+15],0
4F0E: B0 0F    JNZ   0x4F1E
(0398) 		{
(0399) 			UART_CPutString(gszErrExpectFreq);
4F10: 10       PUSH  X
4F11: 50 05    MOV   A,5
4F13: 08       PUSH  A
4F14: 50 66    MOV   A,102
4F16: 5C       MOV   X,A
4F17: 18       POP   A
4F18: 7C 0A BD LCALL 0x0ABD
4F1B: 20       POP   X
(0400) 			break;
4F1C: 81 86    JMP   0x50A3
(0401) 		}
(0402) 		dwEndFreq = atol(strPtr);
4F1E: 52 0E    MOV   A,[X+14]
4F20: 08       PUSH  A
4F21: 52 0F    MOV   A,[X+15]
4F23: 08       PUSH  A
4F24: 7C 58 46 LCALL _atol
4F27: 62 D0 02 MOV   REG[208],2
4F2A: 51 B6    MOV   A,[__r0]
4F2C: 54 06    MOV   [X+6],A
4F2E: 51 B5    MOV   A,[__r1]
4F30: 54 07    MOV   [X+7],A
4F32: 51 B4    MOV   A,[__r2]
4F34: 54 08    MOV   [X+8],A
4F36: 51 B3    MOV   A,[__r3]
4F38: 54 09    MOV   [X+9],A
(0403) 		bBand = GetBand(dwEndFreq);
4F3A: 52 06    MOV   A,[X+6]
4F3C: 08       PUSH  A
4F3D: 52 07    MOV   A,[X+7]
4F3F: 08       PUSH  A
4F40: 52 08    MOV   A,[X+8]
4F42: 08       PUSH  A
4F43: 52 09    MOV   A,[X+9]
4F45: 08       PUSH  A
4F46: 7C 54 82 LCALL _GetBand
4F49: 38 FA    ADD   SP,250
4F4B: 62 D0 02 MOV   REG[208],2
4F4E: 54 04    MOV   [X+4],A
(0404) 		if (bBand==-1)
4F50: 3D 04 FF CMP   [X+4],255
4F53: B0 0F    JNZ   0x4F63
(0405) 		{
(0406) 			UART_CPutString(gszErrInvalidFreq);
4F55: 10       PUSH  X
4F56: 50 05    MOV   A,5
4F58: 08       PUSH  A
4F59: 50 A0    MOV   A,160
4F5B: 5C       MOV   X,A
4F5C: 18       POP   A
4F5D: 7C 0A BD LCALL 0x0ABD
4F60: 20       POP   X
(0407) 			break;
4F61: 81 41    JMP   0x50A3
(0408) 		}
(0409) 
(0410) 										// Get step value
(0411) 		strPtr = UART_szGetParam();
4F63: 10       PUSH  X
4F64: 7C 0B 07 LCALL 0x0B07
4F67: 62 D0 02 MOV   REG[208],2
4F6A: 53 B6    MOV   [__r0],A
4F6C: 5A B5    MOV   [__r1],X
4F6E: 20       POP   X
4F6F: 51 B5    MOV   A,[__r1]
4F71: 54 0F    MOV   [X+15],A
4F73: 51 B6    MOV   A,[__r0]
4F75: 54 0E    MOV   [X+14],A
(0412) 		if (strPtr==NULL)
4F77: 3D 0E 00 CMP   [X+14],0
4F7A: B0 14    JNZ   0x4F8F
4F7C: 3D 0F 00 CMP   [X+15],0
4F7F: B0 0F    JNZ   0x4F8F
(0413) 		{
(0414) 			UART_CPutString(gszErrExpectStep);
4F81: 10       PUSH  X
4F82: 50 05    MOV   A,5
4F84: 08       PUSH  A
4F85: 50 83    MOV   A,131
4F87: 5C       MOV   X,A
4F88: 18       POP   A
4F89: 7C 0A BD LCALL 0x0ABD
4F8C: 20       POP   X
(0415) 			break;
4F8D: 81 15    JMP   0x50A3
(0416) 		}
(0417) 		dwStepFreq = atol(strPtr);
4F8F: 52 0E    MOV   A,[X+14]
4F91: 08       PUSH  A
4F92: 52 0F    MOV   A,[X+15]
4F94: 08       PUSH  A
4F95: 7C 58 46 LCALL _atol
4F98: 38 FE    ADD   SP,254
4F9A: 62 D0 02 MOV   REG[208],2
4F9D: 51 B6    MOV   A,[__r0]
4F9F: 54 0A    MOV   [X+10],A
4FA1: 51 B5    MOV   A,[__r1]
4FA3: 54 0B    MOV   [X+11],A
4FA5: 51 B4    MOV   A,[__r2]
4FA7: 54 0C    MOV   [X+12],A
4FA9: 51 B3    MOV   A,[__r3]
4FAB: 54 0D    MOV   [X+13],A
(0418) 
(0419) 		UART_CPutString(gszStart);
4FAD: 10       PUSH  X
4FAE: 50 05    MOV   A,5
4FB0: 08       PUSH  A
4FB1: 50 3E    MOV   A,62
4FB3: 5C       MOV   X,A
4FB4: 18       POP   A
4FB5: 7C 0A BD LCALL 0x0ABD
4FB8: 20       POP   X
(0420) 
(0421) 		for (bBandSave=-1; dwFreq < dwEndFreq;)
4FB9: 56 05 FF MOV   [X+5],255
4FBC: 80 A6    JMP   0x5063
(0422) 		{
(0423) 			DDS_Set(dwFreq);
4FBE: 52 00    MOV   A,[X+0]
4FC0: 08       PUSH  A
4FC1: 52 01    MOV   A,[X+1]
4FC3: 08       PUSH  A
4FC4: 52 02    MOV   A,[X+2]
4FC6: 08       PUSH  A
4FC7: 52 03    MOV   A,[X+3]
4FC9: 08       PUSH  A
4FCA: 7C 28 DC LCALL _DDS_Set
4FCD: 38 FC    ADD   SP,252
(0424) 			Delay_Ms(10);
4FCF: 50 00    MOV   A,0
4FD1: 08       PUSH  A
4FD2: 50 0A    MOV   A,10
4FD4: 08       PUSH  A
4FD5: 7C 53 01 LCALL _Delay_Ms
(0425) 
(0426) 			bBand = GetBand(dwFreq);
4FD8: 52 00    MOV   A,[X+0]
4FDA: 08       PUSH  A
4FDB: 52 01    MOV   A,[X+1]
4FDD: 08       PUSH  A
4FDE: 52 02    MOV   A,[X+2]
4FE0: 08       PUSH  A
4FE1: 52 03    MOV   A,[X+3]
4FE3: 08       PUSH  A
4FE4: 7C 54 82 LCALL _GetBand
4FE7: 38 FA    ADD   SP,250
4FE9: 62 D0 02 MOV   REG[208],2
4FEC: 54 04    MOV   [X+4],A
(0427) 			if (bBand!=bBandSave)
4FEE: 52 04    MOV   A,[X+4]
4FF0: 3B 05    CMP   A,[X+5]
4FF2: A0 55    JZ    0x5048
(0428) 			{
(0429) 				bBandSave=bBand;
4FF4: 52 04    MOV   A,[X+4]
4FF6: 54 05    MOV   [X+5],A
(0430) 				g_xBridgeCorrect = g_xBandCorrFactor[bBand];
4FF8: 52 04    MOV   A,[X+4]
4FFA: 53 B5    MOV   [__r1],A
4FFC: 50 00    MOV   A,0
4FFE: 08       PUSH  A
4FFF: 51 B5    MOV   A,[__r1]
5001: 08       PUSH  A
5002: 50 00    MOV   A,0
5004: 08       PUSH  A
5005: 50 0C    MOV   A,12
5007: 08       PUSH  A
5008: 7C 56 FD LCALL __mul16
500B: 38 FC    ADD   SP,252
500D: 51 AC    MOV   A,[__rX]
500F: 53 B5    MOV   [__r1],A
5011: 51 AB    MOV   A,[__rY]
5013: 53 B6    MOV   [__r0],A
5015: 06 B5 0B ADD   [__r1],11
5018: 0E B6 00 ADC   [__r0],0
501B: 55 B3 EB MOV   [__r3],235
501E: 55 B4 00 MOV   [__r2],0
5021: 51 B6    MOV   A,[__r0]
5023: 60 D4    MOV   REG[212],A
5025: 51 B4    MOV   A,[__r2]
5027: 60 D5    MOV   REG[213],A
5029: 10       PUSH  X
502A: 57 0C    MOV   X,12
502C: 62 D0 02 MOV   REG[208],2
502F: 3E B5    MVI   A,[__r1]
5031: 3F B3    MVI   [__r3],A
5033: 79       DEC   X
5034: BF F7    JNZ   0x502C
5036: 20       POP   X
(0431) 				Adjust_Dds_Gain(bBand);
5037: 52 04    MOV   A,[X+4]
5039: 08       PUSH  A
503A: 7C 25 35 LCALL _Adjust_Dds_Gain
(0432) 				Delay_Ms(50);
503D: 50 00    MOV   A,0
503F: 08       PUSH  A
5040: 50 32    MOV   A,50
5042: 08       PUSH  A
5043: 7C 53 01 LCALL _Delay_Ms
5046: 38 FD    ADD   SP,253
(0433) 			}
(0434) 			if (bRaw)
5048: 3D FC 00 CMP   [X-4],0
504B: A0 05    JZ    0x5051
(0435) 				Cmd_Raw();
504D: 9D 4E    CALL  _Cmd_Raw
504F: 80 03    JMP   0x5053
(0436) 			else
(0437) 				Cmd_Imp();
5051: 9B CD    CALL  _Cmd_Imp
(0438) 			dwFreq += dwStepFreq;
5053: 52 0D    MOV   A,[X+13]
5055: 05 03    ADD   [X+3],A
5057: 52 0C    MOV   A,[X+12]
5059: 0D 02    ADC   [X+2],A
505B: 52 0B    MOV   A,[X+11]
505D: 0D 01    ADC   [X+1],A
505F: 52 0A    MOV   A,[X+10]
5061: 0D 00    ADC   [X+0],A
5063: 52 03    MOV   A,[X+3]
5065: 13 09    SUB   A,[X+9]
5067: 52 02    MOV   A,[X+2]
5069: 1B 08    SBB   A,[X+8]
506B: 52 01    MOV   A,[X+1]
506D: 1B 07    SBB   A,[X+7]
506F: 52 00    MOV   A,[X+0]
5071: 1B 06    SBB   A,[X+6]
5073: CF 4A    JC    0x4FBE
(0439) 		}
(0440) 		UART_CPutString(gszEnd);
5075: 10       PUSH  X
5076: 50 05    MOV   A,5
5078: 08       PUSH  A
5079: 50 48    MOV   A,72
507B: 5C       MOV   X,A
507C: 18       POP   A
507D: 7C 0A BD LCALL 0x0ABD
5080: 20       POP   X
(0441) 		if (gdwCurrentFreq==-1)
5081: 62 D0 02 MOV   REG[208],2
5084: 3C DD FF CMP   [gdwCurrentFreq],255
5087: B0 1B    JNZ   0x50A3
5089: 3C DE FF CMP   [gdwCurrentFreq+1],255
508C: B0 16    JNZ   0x50A3
508E: 3C DF FF CMP   [gdwCurrentFreq+2],255
5091: B0 11    JNZ   0x50A3
5093: 3C E0 FF CMP   [gdwCurrentFreq+3],255
5096: B0 0C    JNZ   0x50A3
(0442) 		{
(0443) 			DDS_Set(0);
5098: 50 00    MOV   A,0
509A: 08       PUSH  A
509B: 08       PUSH  A
509C: 08       PUSH  A
509D: 08       PUSH  A
509E: 7C 28 DC LCALL _DDS_Set
50A1: 38 FC    ADD   SP,252
(0444) 		}
(0445) 	} while (FALSE);
(0446) 
(0447) 	g_bScanning = FALSE;
50A3: 62 D0 02 MOV   REG[208],2
50A6: 55 F4 00 MOV   [g_bScanning],0
50A9: 38 EC    ADD   SP,236
50AB: 20       POP   X
50AC: 7F       RET   

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\sleep_timer.c
(0001) //*****************************************************************************/
(0002) //  This file is a part of the "SARK100 SWR Analyzer firmware"
(0003) //
(0004) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
(0005) //  Melchor Varela, Madrid, Spain.
(0006) //  melchor.varela@gmail.com
(0007) //
(0008) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0009) //  and/or modify it under the terms of the GNU General Public License as
(0010) //  published by the Free Software Foundation, either version 3 of the License,
(0011) //  or (at your option) any later version.
(0012) //
(0013) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
(0014) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0015) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
(0016) //  GNU General Public License for more details.
(0017) //
(0018) //  You should have received a copy of the GNU General Public License
(0019) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0020) //  see <http://www.gnu.org/licenses/>.
(0021) //*****************************************************************************/
(0022) //*****************************************************************************/
(0023) //
(0024) //	PROJECT:	SARK100 SWR Analyzer
(0025) // 	FILE NAME: 	SLEEP_TIMER.C
(0026) // 	AUTHOR:		Melchor Varela
(0027) //
(0028) // 	DESCRIPTION
(0029) //
(0030) //	Sleep timer interrupt
(0031) //
(0032) // 	HISTORY
(0033) //
(0034) //	NAME   	DATE		REMARKS
(0035) //
(0036) //	MVM	   	DEC 2009	Creation
(0037) //
(0038) //*****************************************************************************/
(0039) #include "m8c.h"
(0040) #include "glb_data.h"
(0041) 
(0042) //-----------------------------------------------------------------------------
(0043) //  Public data
(0044) //-----------------------------------------------------------------------------
(0045) 
(0046) //-----------------------------------------------------------------------------
(0047) //  Private static data
(0048) //-----------------------------------------------------------------------------
(0049) static volatile BYTE gTickCount = 1;	// Prescaler to generate one second
(0050) 
(0051) //-----------------------------------------------------------------------------
(0052) //  FUNCTION NAME: SleepTimerINT
(0053) //
(0054) //  DESCRIPTION:
(0055) //
(0056) //	Sleep timer interrupt sevice routine. Period 8Hz.
(0057) //
(0058) //  ARGUMENTS:
(0059) //    none.
(0060) //
(0061) //  RETURNS:
(0062) //    none.
(0063) //
(0064) //-----------------------------------------------------------------------------
(0065) #pragma interrupt_handler 	SleepTimerINT
(0066) 
(0067) void SleepTimerINT ( void )
(0068) {
_SleepTimerINT:
50AD: 71 C0    OR    F,192
50AF: 08       PUSH  A
50B0: 5D D0    MOV   A,REG[208]
50B2: 08       PUSH  A
(0069) 	M8C_ClearWDTAndSleep;
50B3: 62 E3 38 MOV   REG[227],56
(0070) 
(0071) 	if (g_bMeasureCounter)
50B6: 62 D0 02 MOV   REG[208],2
50B9: 3C F1 00 CMP   [g_bMeasureCounter],0
50BC: A0 03    JZ    0x50C0
(0072) 		g_bMeasureCounter--;
50BE: 7A F1    DEC   [g_bMeasureCounter]
(0073) 	if (g_bDebounceCounter)
50C0: 62 D0 02 MOV   REG[208],2
50C3: 3C F2 00 CMP   [g_bDebounceCounter],0
50C6: A0 03    JZ    0x50CA
(0074) 		g_bDebounceCounter--;
50C8: 7A F2    DEC   [g_bDebounceCounter]
(0075) 
(0076) 	if( --gTickCount )
50CA: 62 D0 00 MOV   REG[208],0
50CD: 51 F7    MOV   A,[gTickCount]
50CF: 11 01    SUB   A,1
50D1: 53 F7    MOV   [gTickCount],A
50D3: 62 D0 02 MOV   REG[208],2
50D6: 39 00    CMP   A,0
50D8: A0 03    JZ    0x50DC
(0077)     	return;
50DA: 80 1B    JMP   0x50F6
(0078) 	gTickCount = 8;
50DC: 62 D0 00 MOV   REG[208],0
50DF: 55 F7 08 MOV   [gTickCount],8
(0079) 	
(0080) 										// One second
(0081) 	if (g_bSpeedKeyCounter)
50E2: 62 D0 02 MOV   REG[208],2
50E5: 3C F3 00 CMP   [g_bSpeedKeyCounter],0
50E8: A0 03    JZ    0x50EC
(0082) 		g_bSpeedKeyCounter--;
50EA: 7A F3    DEC   [g_bSpeedKeyCounter]
(0083) 
(0084) 	if (g_bIddleCounter)
50EC: 62 D0 02 MOV   REG[208],2
50EF: 3C F0 00 CMP   [g_bIddleCounter],0
50F2: A0 03    JZ    0x50F6
(0085) 		g_bIddleCounter--;
50F4: 7A F0    DEC   [g_bIddleCounter]
50F6: 18       POP   A
50F7: 60 D0    MOV   REG[208],A
50F9: 18       POP   A
50FA: 7E       RETI  

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\storage.c
(0001) //*****************************************************************************/
(0002) //  This file is a part of the "SARK100 SWR Analyzer firmware"
(0003) //
(0004) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
(0005) //  Melchor Varela, Madrid, Spain.
(0006) //  melchor.varela@gmail.com
(0007) //
(0008) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0009) //  and/or modify it under the terms of the GNU General Public License as
(0010) //  published by the Free Software Foundation, either version 3 of the License,
(0011) //  or (at your option) any later version.
(0012) //
(0013) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
(0014) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0015) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
(0016) //  GNU General Public License for more details.
(0017) //
(0018) //  You should have received a copy of the GNU General Public License
(0019) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0020) //  see <http://www.gnu.org/licenses/>.
(0021) //*****************************************************************************/
(0022) //*****************************************************************************/
(0023) //
(0024) //	PROJECT:	SARK100 SWR Analyzer
(0025) // 	FILE NAME: 	STORAGE.C
(0026) // 	AUTHOR:		EA4FRB - Melchor Varela
(0027) //
(0028) // 	DESCRIPTION
(0029) //
(0030) //	EEPROM storage functions
(0031) //
(0032) // 	HISTORY
(0033) //
(0034) //	NAME   	DATE		REMARKS
(0035) //
(0036) //	MVM	   	DEC 2009	Creation
(0037) //
(0038) //*****************************************************************************/
(0039) #include <stdlib.h>
(0040) #include <string.h>
(0041) #include <m8c.h>
(0042) #include "PSoCAPI.h"
(0043) 
(0044) #include "glb_data.h"
(0045) 
(0046) //-----------------------------------------------------------------------------
(0047) //  Macros
(0048) //-----------------------------------------------------------------------------
(0049) #define offsetof(st, m) \
(0050)     ((size_t) ( (char *)&((st *)(0))->m - (char *)0 ))
(0051) 
(0052) //-----------------------------------------------------------------------------
(0053) //  Defines
(0054) //-----------------------------------------------------------------------------
(0055) #define MAGIC_NUMBER	0x55ab
(0056) 
(0057) //-----------------------------------------------------------------------------
(0058) //  Typedefs
(0059) //-----------------------------------------------------------------------------
(0060) typedef struct							// Structure stored in EEPROM
(0061) {
(0062) 										// Calibration data
(0063) 	BRIDGE_CORRECT xBandCorrFactor[BAND_MAX];
(0064) 	BYTE bGainDDS[BAND_MAX];
(0065) 	BRIDGE_VOLTAGES xBridgeOffset;
(0066) 	BYTE bIsCalibrated;
(0067) 
(0068) 										// Configuration data
(0069) 	CONFIG_DATA xConf;
(0070) 
(0071) 										// Integrity control
(0072) 	WORD wMagic;
(0073) } RECORD_DATA;
(0074) 
(0075) //-----------------------------------------------------------------------------
(0076) //  FUNCTION NAME:	STR_SaveCalibration
(0077) //
(0078) //  DESCRIPTION:
(0079) //
(0080) //	Save calibration data in EEPROM
(0081) //
(0082) //  ARGUMENTS:
(0083) //     none.
(0084) //
(0085) //  RETURNS:
(0086) //     none.
(0087) //
(0088) //-----------------------------------------------------------------------------
(0089) void STR_SaveCalibration ( void )
(0090) {
(0091) 	E2PROM_bE2Write(offsetof(RECORD_DATA,xBandCorrFactor), (unsigned char*) &g_xBandCorrFactor[0], sizeof(g_xBandCorrFactor), 25);
_STR_SaveCalibration:
50FB: 10       PUSH  X
50FC: 50 19    MOV   A,25
50FE: 08       PUSH  A
50FF: 50 00    MOV   A,0
5101: 08       PUSH  A
5102: 50 A8    MOV   A,168
5104: 08       PUSH  A
5105: 50 00    MOV   A,0
5107: 08       PUSH  A
5108: 50 0B    MOV   A,11
510A: 08       PUSH  A
510B: 50 00    MOV   A,0
510D: 08       PUSH  A
510E: 08       PUSH  A
510F: 7C 0F 6A LCALL 0x0F6A
5112: 62 D0 02 MOV   REG[208],2
5115: 38 F9    ADD   SP,249
5117: 20       POP   X
(0092) 	E2PROM_bE2Write(offsetof(RECORD_DATA,bIsCalibrated), &g_bIsCalibrated, sizeof(g_bIsCalibrated), 25);
5118: 10       PUSH  X
5119: 50 19    MOV   A,25
511B: 08       PUSH  A
511C: 50 00    MOV   A,0
511E: 08       PUSH  A
511F: 50 01    MOV   A,1
5121: 08       PUSH  A
5122: 50 02    MOV   A,2
5124: 08       PUSH  A
5125: 50 F5    MOV   A,245
5127: 08       PUSH  A
5128: 50 00    MOV   A,0
512A: 08       PUSH  A
512B: 50 C6    MOV   A,198
512D: 08       PUSH  A
512E: 7C 0F 6A LCALL 0x0F6A
5131: 62 D0 02 MOV   REG[208],2
5134: 38 F9    ADD   SP,249
5136: 20       POP   X
(0093) 	E2PROM_bE2Write(offsetof(RECORD_DATA,bGainDDS), (unsigned char*) &g_bGainDDS[0], sizeof(g_bGainDDS), 25);
5137: 10       PUSH  X
5138: 50 19    MOV   A,25
513A: 08       PUSH  A
513B: 50 00    MOV   A,0
513D: 08       PUSH  A
513E: 50 0E    MOV   A,14
5140: 08       PUSH  A
5141: 50 02    MOV   A,2
5143: 08       PUSH  A
5144: 50 9C    MOV   A,156
5146: 08       PUSH  A
5147: 50 00    MOV   A,0
5149: 08       PUSH  A
514A: 50 A8    MOV   A,168
514C: 08       PUSH  A
514D: 7C 0F 6A LCALL 0x0F6A
5150: 62 D0 02 MOV   REG[208],2
5153: 38 F9    ADD   SP,249
5155: 20       POP   X
5156: 7F       RET   
(0094) }
(0095) 
(0096) //-----------------------------------------------------------------------------
(0097) //  FUNCTION NAME:	STR_SaveConfig
(0098) //
(0099) //  DESCRIPTION:
(0100) //
(0101) //	Save configuration data
(0102) //
(0103) //  ARGUMENTS:
(0104) //     none.
(0105) //
(0106) //  RETURNS:
(0107) //     none.
(0108) //
(0109) //-----------------------------------------------------------------------------
(0110) void STR_SaveConfig ( void )
(0111) {
(0112) 	E2PROM_bE2Write(offsetof(RECORD_DATA,xConf), (unsigned char*)&g_xConf, sizeof(g_xConf), 25);
_STR_SaveConfig:
5157: 10       PUSH  X
5158: 50 19    MOV   A,25
515A: 08       PUSH  A
515B: 50 00    MOV   A,0
515D: 08       PUSH  A
515E: 50 02    MOV   A,2
5160: 08       PUSH  A
5161: 50 02    MOV   A,2
5163: 08       PUSH  A
5164: 50 ED    MOV   A,237
5166: 08       PUSH  A
5167: 50 00    MOV   A,0
5169: 08       PUSH  A
516A: 50 C7    MOV   A,199
516C: 08       PUSH  A
516D: 7C 0F 6A LCALL 0x0F6A
5170: 62 D0 02 MOV   REG[208],2
5173: 38 F9    ADD   SP,249
5175: 20       POP   X
5176: 7F       RET   
(0113) }
(0114) //-----------------------------------------------------------------------------
(0115) //  FUNCTION NAME:	STR_Restore
(0116) //
(0117) //  DESCRIPTION:
(0118) //
(0119) //	Restores EEPROM data. In case of not initialized set defaults
(0120) //
(0121) //  ARGUMENTS:
(0122) //     none.
(0123) //
(0124) //  RETURNS:
(0125) //     none.
(0126) //
(0127) //-----------------------------------------------------------------------------
(0128) void STR_Restore ( void )
(0129) {
_STR_Restore:
  cRc                  --> X+3
  magic                --> X+1
  bBand                --> X+0
5177: 10       PUSH  X
5178: 4F       MOV   X,SP
5179: 38 04    ADD   SP,4
(0130) 	WORD magic;
(0131) 	BYTE bBand;
(0132) 	CHAR cRc;
(0133) 
(0134) 	E2PROM_E2Read(offsetof(RECORD_DATA,wMagic), (unsigned char*) &magic, sizeof(WORD));
517B: 10       PUSH  X
517C: 50 00    MOV   A,0
517E: 08       PUSH  A
517F: 50 02    MOV   A,2
5181: 08       PUSH  A
5182: 62 D0 02 MOV   REG[208],2
5185: 5A B5    MOV   [__r1],X
5187: 06 B5 01 ADD   [__r1],1
518A: 50 07    MOV   A,7
518C: 08       PUSH  A
518D: 51 B5    MOV   A,[__r1]
518F: 08       PUSH  A
5190: 50 00    MOV   A,0
5192: 08       PUSH  A
5193: 50 C9    MOV   A,201
5195: 08       PUSH  A
5196: 7C 0F 76 LCALL 0x0F76
5199: 38 FA    ADD   SP,250
519B: 20       POP   X
(0135) 	if (magic != MAGIC_NUMBER)
519C: 3D 01 55 CMP   [X+1],85
519F: B0 06    JNZ   0x51A6
51A1: 3D 02 AB CMP   [X+2],171
51A4: A0 F6    JZ    0x529B
(0136) 	{
(0137) 										// Set defaults
(0138) 		for (bBand=0;bBand<BAND_MAX;bBand++)
51A6: 56 00 00 MOV   [X+0],0
51A9: 80 AC    JMP   0x5256
(0139) 		{
(0140) 			g_xBandCorrFactor[bBand] = g_xDefBandSettings[bBand].xBridgeCorrect;
51AB: 62 D0 02 MOV   REG[208],2
51AE: 52 00    MOV   A,[X+0]
51B0: 53 B5    MOV   [__r1],A
51B2: 50 00    MOV   A,0
51B4: 08       PUSH  A
51B5: 51 B5    MOV   A,[__r1]
51B7: 08       PUSH  A
51B8: 50 00    MOV   A,0
51BA: 08       PUSH  A
51BB: 50 0D    MOV   A,13
51BD: 08       PUSH  A
51BE: 7C 56 FD LCALL __mul16
51C1: 38 FC    ADD   SP,252
51C3: 51 AC    MOV   A,[__rX]
51C5: 53 B5    MOV   [__r1],A
51C7: 51 AB    MOV   A,[__rY]
51C9: 53 B6    MOV   [__r0],A
51CB: 06 B5 39 ADD   [__r1],57
51CE: 0E B6 02 ADC   [__r0],2
51D1: 52 00    MOV   A,[X+0]
51D3: 53 B3    MOV   [__r3],A
51D5: 50 00    MOV   A,0
51D7: 08       PUSH  A
51D8: 51 B3    MOV   A,[__r3]
51DA: 08       PUSH  A
51DB: 50 00    MOV   A,0
51DD: 08       PUSH  A
51DE: 50 0C    MOV   A,12
51E0: 08       PUSH  A
51E1: 7C 56 FD LCALL __mul16
51E4: 38 FC    ADD   SP,252
51E6: 51 AC    MOV   A,[__rX]
51E8: 53 B3    MOV   [__r3],A
51EA: 51 AB    MOV   A,[__rY]
51EC: 53 B4    MOV   [__r2],A
51EE: 06 B3 0B ADD   [__r3],11
51F1: 0E B4 00 ADC   [__r2],0
51F4: 51 B4    MOV   A,[__r2]
51F6: 60 D5    MOV   REG[213],A
51F8: 10       PUSH  X
51F9: 55 AC 00 MOV   [__rX],0
51FC: 51 B6    MOV   A,[__r0]
51FE: 58 B5    MOV   X,[__r1]
5200: 08       PUSH  A
5201: 28       ROMX  
5202: 62 D0 02 MOV   REG[208],2
5205: 3F B3    MVI   [__r3],A
5207: 18       POP   A
5208: 75       INC   X
5209: 09 00    ADC   A,0
520B: 76 AC    INC   [__rX]
520D: 3C AC 0C CMP   [__rX],12
5210: BF EF    JNZ   0x5200
5212: 20       POP   X
(0141) 			g_bGainDDS[bBand] =	g_xDefBandSettings[bBand].bGain;
5213: 52 00    MOV   A,[X+0]
5215: 53 B5    MOV   [__r1],A
5217: 50 00    MOV   A,0
5219: 08       PUSH  A
521A: 51 B5    MOV   A,[__r1]
521C: 08       PUSH  A
521D: 50 00    MOV   A,0
521F: 08       PUSH  A
5220: 50 0D    MOV   A,13
5222: 08       PUSH  A
5223: 7C 56 FD LCALL __mul16
5226: 38 FC    ADD   SP,252
5228: 51 AC    MOV   A,[__rX]
522A: 53 B5    MOV   [__r1],A
522C: 51 AB    MOV   A,[__rY]
522E: 53 B6    MOV   [__r0],A
5230: 06 B5 38 ADD   [__r1],56
5233: 0E B6 02 ADC   [__r0],2
5236: 51 B6    MOV   A,[__r0]
5238: 10       PUSH  X
5239: 58 B5    MOV   X,[__r1]
523B: 28       ROMX  
523C: 20       POP   X
523D: 53 B6    MOV   [__r0],A
523F: 52 00    MOV   A,[X+0]
5241: 53 B3    MOV   [__r3],A
5243: 55 B4 00 MOV   [__r2],0
5246: 06 B3 9C ADD   [__r3],156
5249: 0E B4 02 ADC   [__r2],2
524C: 51 B4    MOV   A,[__r2]
524E: 60 D5    MOV   REG[213],A
5250: 51 B6    MOV   A,[__r0]
5252: 3F B3    MVI   [__r3],A
5254: 77 00    INC   [X+0]
5256: 3D 00 0E CMP   [X+0],14
5259: CF 51    JC    0x51AB
(0142) 		}
(0143) 
(0144) 		g_bIsCalibrated = FALSE;
525B: 62 D0 02 MOV   REG[208],2
525E: 55 F5 00 MOV   [g_bIsCalibrated],0
(0145) 
(0146) 		STR_SaveCalibration();
5261: 9E 98    CALL  _STR_SaveCalibration
(0147) 
(0148) 		g_xConf.bUserIddle = USER_IDDLE_90S;
5263: 62 D0 02 MOV   REG[208],2
5266: 55 EE 03 MOV   [g_xConf+1],3
(0149) 		g_xConf.bStep = STEP_10KHZ;
5269: 55 ED 03 MOV   [g_xConf],3
(0150) 		STR_SaveConfig();
526C: 9E E9    CALL  _STR_SaveConfig
(0151) 
(0152) 		magic = MAGIC_NUMBER;
526E: 56 02 AB MOV   [X+2],171
5271: 56 01 55 MOV   [X+1],85
(0153) 		E2PROM_bE2Write(offsetof(RECORD_DATA,wMagic), (unsigned char*) &magic, sizeof(magic), 25);
5274: 10       PUSH  X
5275: 50 19    MOV   A,25
5277: 08       PUSH  A
5278: 50 00    MOV   A,0
527A: 08       PUSH  A
527B: 50 02    MOV   A,2
527D: 08       PUSH  A
527E: 62 D0 02 MOV   REG[208],2
5281: 5A B5    MOV   [__r1],X
5283: 06 B5 01 ADD   [__r1],1
5286: 50 07    MOV   A,7
5288: 08       PUSH  A
5289: 51 B5    MOV   A,[__r1]
528B: 08       PUSH  A
528C: 50 00    MOV   A,0
528E: 08       PUSH  A
528F: 50 C9    MOV   A,201
5291: 08       PUSH  A
5292: 7C 0F 6A LCALL 0x0F6A
5295: 62 D0 02 MOV   REG[208],2
5298: 38 F9    ADD   SP,249
529A: 20       POP   X
(0154) 	}
(0155) 	E2PROM_E2Read(offsetof(RECORD_DATA,xBandCorrFactor), (unsigned char*) &g_xBandCorrFactor[0], sizeof(g_xBandCorrFactor));
529B: 10       PUSH  X
529C: 50 00    MOV   A,0
529E: 08       PUSH  A
529F: 50 A8    MOV   A,168
52A1: 08       PUSH  A
52A2: 50 00    MOV   A,0
52A4: 08       PUSH  A
52A5: 50 0B    MOV   A,11
52A7: 08       PUSH  A
52A8: 50 00    MOV   A,0
52AA: 08       PUSH  A
52AB: 08       PUSH  A
52AC: 7C 0F 76 LCALL 0x0F76
52AF: 38 FA    ADD   SP,250
52B1: 20       POP   X
(0156) 	E2PROM_E2Read(offsetof(RECORD_DATA,bIsCalibrated), &g_bIsCalibrated, sizeof(g_bIsCalibrated));
52B2: 10       PUSH  X
52B3: 50 00    MOV   A,0
52B5: 08       PUSH  A
52B6: 50 01    MOV   A,1
52B8: 08       PUSH  A
52B9: 50 02    MOV   A,2
52BB: 08       PUSH  A
52BC: 50 F5    MOV   A,245
52BE: 08       PUSH  A
52BF: 50 00    MOV   A,0
52C1: 08       PUSH  A
52C2: 50 C6    MOV   A,198
52C4: 08       PUSH  A
52C5: 7C 0F 76 LCALL 0x0F76
52C8: 38 FA    ADD   SP,250
52CA: 20       POP   X
(0157) 	E2PROM_E2Read(offsetof(RECORD_DATA,bGainDDS), (unsigned char*)&g_bGainDDS[0], sizeof(g_bGainDDS));
52CB: 10       PUSH  X
52CC: 50 00    MOV   A,0
52CE: 08       PUSH  A
52CF: 50 0E    MOV   A,14
52D1: 08       PUSH  A
52D2: 50 02    MOV   A,2
52D4: 08       PUSH  A
52D5: 50 9C    MOV   A,156
52D7: 08       PUSH  A
52D8: 50 00    MOV   A,0
52DA: 08       PUSH  A
52DB: 50 A8    MOV   A,168
52DD: 08       PUSH  A
52DE: 7C 0F 76 LCALL 0x0F76
52E1: 38 FA    ADD   SP,250
52E3: 20       POP   X
(0158) 	E2PROM_E2Read(offsetof(RECORD_DATA,xConf), (unsigned char*)&g_xConf, sizeof(g_xConf));
52E4: 10       PUSH  X
52E5: 50 00    MOV   A,0
52E7: 08       PUSH  A
52E8: 50 02    MOV   A,2
52EA: 08       PUSH  A
52EB: 50 02    MOV   A,2
52ED: 08       PUSH  A
52EE: 50 ED    MOV   A,237
52F0: 08       PUSH  A
52F1: 50 00    MOV   A,0
52F3: 08       PUSH  A
52F4: 50 C7    MOV   A,199
52F6: 08       PUSH  A
52F7: 7C 0F 76 LCALL 0x0F76
52FA: 38 FA    ADD   SP,250
52FC: 20       POP   X
52FD: 38 FC    ADD   SP,252
52FF: 20       POP   X
5300: 7F       RET   

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\util.c
(0001) //*****************************************************************************/
(0002) //  This file is a part of the "SARK100 SWR Analyzer firmware"
(0003) //
(0004) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
(0005) //  Melchor Varela, Madrid, Spain.
(0006) //  melchor.varela@gmail.com
(0007) //
(0008) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0009) //  and/or modify it under the terms of the GNU General Public License as
(0010) //  published by the Free Software Foundation, either version 3 of the License,
(0011) //  or (at your option) any later version.
(0012) //
(0013) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
(0014) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0015) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
(0016) //  GNU General Public License for more details.
(0017) //
(0018) //  You should have received a copy of the GNU General Public License
(0019) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0020) //  see <http://www.gnu.org/licenses/>.
(0021) //*****************************************************************************/
(0022) //*****************************************************************************/
(0023) //
(0024) //	PROJECT:	SARK100 SWR Analyzer
(0025) // 	FILE NAME: 	UTIL.C
(0026) // 	AUTHOR:		EA4FRB - Melchor Varela
(0027) //
(0028) // 	DESCRIPTION
(0029) //
(0030) //	Utility functions
(0031) //
(0032) // 	HISTORY
(0033) //
(0034) //	NAME   	DATE		REMARKS
(0035) //
(0036) //	MVM	   	DEC 2009	Creation
(0037) //
(0038) //*****************************************************************************/
(0039) 
(0040) #include <m8c.h>        		// Part specific constants and macros
(0041) #include "PSoCAPI.h"    		// PSoC API definitions for all User Modules
(0042) #include "psocgpioint.h"
(0043) #include "glb_data.h"
(0044) #include "util.h"
(0045) 
(0046) //-----------------------------------------------------------------------------
(0047) //  FUNCTION NAME:	Delay_Ms
(0048) //
(0049) //  DESCRIPTION:
(0050) //
(0051) //	Wait for a number of ms
(0052) //
(0053) //  ARGUMENTS:
(0054) //     ms	Milliseconds
(0055) //
(0056) //  RETURNS:
(0057) //     none.
(0058) //
(0059) //-----------------------------------------------------------------------------
(0060) void Delay_Ms(WORD ms)
(0061) {
_Delay_Ms:
  ms                   --> X-5
5301: 10       PUSH  X
5302: 4F       MOV   X,SP
(0062) 	Timer16_Delay_WritePeriod((ms * 33)+1);
5303: 62 D0 02 MOV   REG[208],2
5306: 52 FB    MOV   A,[X-5]
5308: 08       PUSH  A
5309: 52 FC    MOV   A,[X-4]
530B: 08       PUSH  A
530C: 50 00    MOV   A,0
530E: 08       PUSH  A
530F: 50 21    MOV   A,33
5311: 08       PUSH  A
5312: 7C 56 FD LCALL __mul16
5315: 38 FC    ADD   SP,252
5317: 51 AC    MOV   A,[__rX]
5319: 53 B5    MOV   [__r1],A
531B: 51 AB    MOV   A,[__rY]
531D: 53 B6    MOV   [__r0],A
531F: 06 B5 01 ADD   [__r1],1
5322: 0E B6 00 ADC   [__r0],0
5325: 10       PUSH  X
5326: 51 B6    MOV   A,[__r0]
5328: 08       PUSH  A
5329: 51 B5    MOV   A,[__r1]
532B: 20       POP   X
532C: 7C 0B 82 LCALL 0x0B82
(0063) 	Timer16_Delay_Start();
532F: 7C 0B 7A LCALL 0x0B7A
5332: 20       POP   X
(0064) 
(0065) 	while (Timer16_Delay_wReadTimer()!=0)
5333: 10       PUSH  X
5334: 7C 0B CA LCALL 0x0BCA
5337: 62 D0 02 MOV   REG[208],2
533A: 5A B6    MOV   [__r0],X
533C: 20       POP   X
533D: 3C B6 00 CMP   [__r0],0
5340: BF F2    JNZ   0x5333
5342: 39 00    CMP   A,0
5344: BF EE    JNZ   0x5333
(0066) 	{;}
(0067) 	Timer16_Delay_Stop();
5346: 10       PUSH  X
5347: 7C 0B 7E LCALL 0x0B7E
534A: 20       POP   X
534B: 20       POP   X
534C: 7F       RET   
(0068) }
(0069) 
(0070) 
(0071) //-----------------------------------------------------------------------------
(0072) //  FUNCTION NAME: BcdToHex
(0073) //
(0074) //  DESCRIPTION:
(0075) //
(0076) //	Converts bcd coded byte to hexadecimal.
(0077) //
(0078) //  ARGUMENTS:
(0079) //    bcd = bcd value.
(0080) //
(0081) //  RETURNS:
(0082) //    Hexadecimal representation of bcd value.
(0083) //
(0084) //-----------------------------------------------------------------------------
(0085) BYTE BcdToHex ( BYTE bcd )
(0086) {
_BcdToHex:
  bcd                  --> X-4
534D: 10       PUSH  X
534E: 4F       MOV   X,SP
(0087) 	return ((BYTE)((bcd&0xf0)>>4)*10)+(BYTE)(bcd&0x0f);
534F: 62 D0 02 MOV   REG[208],2
5352: 52 FC    MOV   A,[X-4]
5354: 21 F0    AND   A,240
5356: 67       ASR   A
5357: 67       ASR   A
5358: 67       ASR   A
5359: 67       ASR   A
535A: 21 0F    AND   A,15
535C: 60 E8    MOV   REG[232],A
535E: 62 E9 0A MOV   REG[233],10
5361: 40       NOP   
5362: 5D EB    MOV   A,REG[235]
5364: 53 B6    MOV   [__r0],A
5366: 52 FC    MOV   A,[X-4]
5368: 21 0F    AND   A,15
536A: 04 B6    ADD   [__r0],A
536C: 51 B6    MOV   A,[__r0]
536E: 20       POP   X
536F: 7F       RET   
(0088) }
(0089) 
(0090) //-----------------------------------------------------------------------------
(0091) //  FUNCTION NAME: HexToBcd
(0092) //
(0093) //  DESCRIPTION:
(0094) //
(0095) //	Converts hexadecimal number to bcd.
(0096) //
(0097) //  ARGUMENTS:
(0098) //    hex = hexadecimal representation of bcd value.
(0099) //
(0100) //  RETURNS:
(0101) //    bcd value.
(0102) //
(0103) //-----------------------------------------------------------------------------
(0104) BYTE HexToBcd ( BYTE hex )
(0105) {
_HexToBcd:
  hex                  --> X-4
5370: 10       PUSH  X
5371: 4F       MOV   X,SP
(0106) 	return ((BYTE)(hex/10)<<4) | (BYTE)(hex%10);
5372: 62 D0 02 MOV   REG[208],2
5375: 50 0A    MOV   A,10
5377: 08       PUSH  A
5378: 52 FC    MOV   A,[X-4]
537A: 08       PUSH  A
537B: 7C 55 FB LCALL __divmodu_8X8_8
537E: 18       POP   A
537F: 38 FF    ADD   SP,255
5381: 64       ASL   A
5382: 64       ASL   A
5383: 64       ASL   A
5384: 64       ASL   A
5385: 53 B6    MOV   [__r0],A
5387: 50 0A    MOV   A,10
5389: 08       PUSH  A
538A: 52 FC    MOV   A,[X-4]
538C: 08       PUSH  A
538D: 7C 55 FB LCALL __divmodu_8X8_8
5390: 38 FF    ADD   SP,255
5392: 18       POP   A
5393: 2C B6    OR    [__r0],A
5395: 51 B6    MOV   A,[__r0]
5397: 20       POP   X
5398: 7F       RET   
(0107) }
(0108) 
(0109) //-----------------------------------------------------------------------------
(0110) //  FUNCTION NAME:	GetStep
(0111) //
(0112) //  DESCRIPTION:
(0113) //
(0114) //	Gets the step value in Hz from the step index value
(0115) //
(0116) //  ARGUMENTS:
(0117) //		bStep	Integer describing frequency step value
(0118) //
(0119) //  RETURNS:
(0120) //     Step value in Hz
(0121) //
(0122) //-----------------------------------------------------------------------------
(0123) DWORD GetStep (BYTE bStep)
(0124) {
_GetStep:
  bStep                --> X-4
5399: 10       PUSH  X
539A: 4F       MOV   X,SP
539B: 38 02    ADD   SP,2
(0125) 	switch (bStep)
539D: 52 FC    MOV   A,[X-4]
539F: 54 01    MOV   [X+1],A
53A1: 56 00 00 MOV   [X+0],0
53A4: 3D 00 00 CMP   [X+0],0
53A7: B0 06    JNZ   0x53AE
53A9: 3D 01 00 CMP   [X+1],0
53AC: A0 2B    JZ    0x53D8
53AE: 3D 00 00 CMP   [X+0],0
53B1: B0 06    JNZ   0x53B8
53B3: 3D 01 01 CMP   [X+1],1
53B6: A0 32    JZ    0x53E9
53B8: 3D 00 00 CMP   [X+0],0
53BB: B0 06    JNZ   0x53C2
53BD: 3D 01 02 CMP   [X+1],2
53C0: A0 39    JZ    0x53FA
53C2: 3D 00 00 CMP   [X+0],0
53C5: B0 06    JNZ   0x53CC
53C7: 3D 01 03 CMP   [X+1],3
53CA: A0 40    JZ    0x540B
53CC: 3D 00 00 CMP   [X+0],0
53CF: B0 06    JNZ   0x53D6
53D1: 3D 01 04 CMP   [X+1],4
53D4: A0 47    JZ    0x541C
53D6: 80 12    JMP   0x53E9
(0126) 	{
(0127) 		case STEP_10HZ:
(0128) 			return 10;
53D8: 62 D0 02 MOV   REG[208],2
53DB: 55 B6 00 MOV   [__r0],0
53DE: 55 B5 00 MOV   [__r1],0
53E1: 55 B4 00 MOV   [__r2],0
53E4: 55 B3 0A MOV   [__r3],10
53E7: 80 43    JMP   0x542B
(0129) 		default:
(0130) 		case STEP_100HZ:
(0131) 			return 100;
53E9: 62 D0 02 MOV   REG[208],2
53EC: 55 B6 00 MOV   [__r0],0
53EF: 55 B5 00 MOV   [__r1],0
53F2: 55 B4 00 MOV   [__r2],0
53F5: 55 B3 64 MOV   [__r3],100
53F8: 80 32    JMP   0x542B
(0132) 		case STEP_1KHZ:
(0133) 			return 1000;
53FA: 62 D0 02 MOV   REG[208],2
53FD: 55 B6 00 MOV   [__r0],0
5400: 55 B5 00 MOV   [__r1],0
5403: 55 B4 03 MOV   [__r2],3
5406: 55 B3 E8 MOV   [__r3],232
5409: 80 21    JMP   0x542B
(0134) 		case STEP_10KHZ:
(0135) 			return 10000;
540B: 62 D0 02 MOV   REG[208],2
540E: 55 B6 00 MOV   [__r0],0
5411: 55 B5 00 MOV   [__r1],0
5414: 55 B4 27 MOV   [__r2],39
5417: 55 B3 10 MOV   [__r3],16
541A: 80 10    JMP   0x542B
(0136) 		case STEP_100KHZ:
(0137) 			return 100000;
541C: 62 D0 02 MOV   REG[208],2
541F: 55 B6 00 MOV   [__r0],0
5422: 55 B5 01 MOV   [__r1],1
5425: 55 B4 86 MOV   [__r2],134
5428: 55 B3 A0 MOV   [__r3],160
542B: 38 FE    ADD   SP,254
542D: 20       POP   X
542E: 7F       RET   
(0138) 	}
(0139) }
(0140) 
(0141) //-----------------------------------------------------------------------------
(0142) //  FUNCTION NAME:	GetUserIddle
(0143) //
(0144) //  DESCRIPTION:
(0145) //
(0146) //	Gets the user iddle timeout from index
(0147) //
(0148) //  ARGUMENTS:
(0149) //		bUserIddle	User iddle index val
(0150) //
(0151) //  RETURNS:
(0152) //     Step value in Hz
(0153) //
(0154) //-----------------------------------------------------------------------------
(0155) BYTE GetUserIddle (BYTE bUserIddle)
(0156) {
_GetUserIddle:
  bUserIddle           --> X-4
542F: 10       PUSH  X
5430: 4F       MOV   X,SP
5431: 38 02    ADD   SP,2
(0157) 	switch (bUserIddle)
5433: 52 FC    MOV   A,[X-4]
5435: 54 01    MOV   [X+1],A
5437: 56 00 00 MOV   [X+0],0
543A: 3D 00 00 CMP   [X+0],0
543D: B0 06    JNZ   0x5444
543F: 3D 01 00 CMP   [X+1],0
5442: A0 21    JZ    0x5464
5444: 3D 00 00 CMP   [X+0],0
5447: B0 06    JNZ   0x544E
5449: 3D 01 01 CMP   [X+1],1
544C: A0 1E    JZ    0x546B
544E: 3D 00 00 CMP   [X+0],0
5451: B0 06    JNZ   0x5458
5453: 3D 01 02 CMP   [X+1],2
5456: A0 1B    JZ    0x5472
5458: 3D 00 00 CMP   [X+0],0
545B: B0 06    JNZ   0x5462
545D: 3D 01 03 CMP   [X+1],3
5460: A0 18    JZ    0x5479
5462: 80 08    JMP   0x546B
(0158) 	{
(0159) 		case USER_IDDLE_NONE:
(0160) 			return 0;
5464: 62 D0 02 MOV   REG[208],2
5467: 50 00    MOV   A,0
5469: 80 14    JMP   0x547E
(0161) 		default:
(0162) 		case USER_IDDLE_30S:
(0163) 			return 30;
546B: 62 D0 02 MOV   REG[208],2
546E: 50 1E    MOV   A,30
5470: 80 0D    JMP   0x547E
(0164) 		case USER_IDDLE_60S:
(0165) 			return 60;
5472: 62 D0 02 MOV   REG[208],2
5475: 50 3C    MOV   A,60
5477: 80 06    JMP   0x547E
(0166) 		case USER_IDDLE_90S:
(0167) 			return 90;
5479: 62 D0 02 MOV   REG[208],2
547C: 50 5A    MOV   A,90
547E: 38 FE    ADD   SP,254
5480: 20       POP   X
5481: 7F       RET   
(0168) 	}
(0169) }
(0170) 
(0171) //-----------------------------------------------------------------------------
(0172) //  FUNCTION NAME:	GetBand
(0173) //
(0174) //  DESCRIPTION:
(0175) //
(0176) //	Get band index for a given frequency
(0177) //
(0178) //  ARGUMENTS:
(0179) //     dwFreq		Frequency in Hz
(0180) //
(0181) //  RETURNS:
(0182) //     none.
(0183) //
(0184) //-----------------------------------------------------------------------------
(0185) BYTE GetBand (DWORD dwFreq)
(0186) {
_GetBand:
  bBand                --> X+0
  dwFreq               --> X-7
5482: 10       PUSH  X
5483: 4F       MOV   X,SP
5484: 38 01    ADD   SP,1
(0187) 	BYTE bBand;
(0188) 
(0189) 	for (bBand=0; bBand<BAND_MAX; bBand++)
5486: 56 00 00 MOV   [X+0],0
5489: 80 D2    JMP   0x555C
(0190) 	{
(0191) 		if (dwFreq >= (g_xBandLimits[bBand].low*BAND_FREQ_MULT) &&
548B: 62 D0 02 MOV   REG[208],2
548E: 52 00    MOV   A,[X+0]
5490: 53 B5    MOV   [__r1],A
5492: 50 00    MOV   A,0
5494: 08       PUSH  A
5495: 51 B5    MOV   A,[__r1]
5497: 08       PUSH  A
5498: 50 00    MOV   A,0
549A: 08       PUSH  A
549B: 50 06    MOV   A,6
549D: 08       PUSH  A
549E: 7C 56 FD LCALL __mul16
54A1: 38 FC    ADD   SP,252
54A3: 51 AC    MOV   A,[__rX]
54A5: 53 B5    MOV   [__r1],A
54A7: 51 AB    MOV   A,[__rY]
54A9: 53 B6    MOV   [__r0],A
54AB: 51 B5    MOV   A,[__r1]
54AD: 01 C2    ADD   A,194
54AF: 53 B3    MOV   [__r3],A
54B1: 51 B6    MOV   A,[__r0]
54B3: 09 01    ADC   A,1
54B5: 10       PUSH  X
54B6: 08       PUSH  A
54B7: 58 B3    MOV   X,[__r3]
54B9: 28       ROMX  
54BA: 53 B4    MOV   [__r2],A
54BC: 18       POP   A
54BD: 75       INC   X
54BE: 09 00    ADC   A,0
54C0: 28       ROMX  
54C1: 20       POP   X
54C2: 53 AF    MOV   [__r7],A
54C4: 51 B4    MOV   A,[__r2]
54C6: 53 B0    MOV   [__r6],A
54C8: 50 00    MOV   A,0
54CA: 08       PUSH  A
54CB: 08       PUSH  A
54CC: 51 B0    MOV   A,[__r6]
54CE: 08       PUSH  A
54CF: 51 AF    MOV   A,[__r7]
54D1: 08       PUSH  A
54D2: 50 00    MOV   A,0
54D4: 08       PUSH  A
54D5: 50 01    MOV   A,1
54D7: 08       PUSH  A
54D8: 50 86    MOV   A,134
54DA: 08       PUSH  A
54DB: 50 A0    MOV   A,160
54DD: 08       PUSH  A
54DE: 7C 57 3B LCALL __mul_32X32_32
54E1: 38 FC    ADD   SP,252
54E3: 18       POP   A
54E4: 53 AF    MOV   [__r7],A
54E6: 18       POP   A
54E7: 53 B0    MOV   [__r6],A
54E9: 18       POP   A
54EA: 53 B1    MOV   [__r5],A
54EC: 18       POP   A
54ED: 53 B2    MOV   [__r4],A
54EF: 52 FC    MOV   A,[X-4]
54F1: 12 AF    SUB   A,[__r7]
54F3: 52 FB    MOV   A,[X-5]
54F5: 1A B0    SBB   A,[__r6]
54F7: 52 FA    MOV   A,[X-6]
54F9: 1A B1    SBB   A,[__r5]
54FB: 52 F9    MOV   A,[X-7]
54FD: 1A B2    SBB   A,[__r4]
54FF: C0 5A    JC    0x555A
5501: 62 D0 02 MOV   REG[208],2
5504: 06 B5 C6 ADD   [__r1],198
5507: 0E B6 01 ADC   [__r0],1
550A: 51 B6    MOV   A,[__r0]
550C: 10       PUSH  X
550D: 08       PUSH  A
550E: 58 B5    MOV   X,[__r1]
5510: 28       ROMX  
5511: 53 B6    MOV   [__r0],A
5513: 18       POP   A
5514: 75       INC   X
5515: 09 00    ADC   A,0
5517: 28       ROMX  
5518: 20       POP   X
5519: 53 B3    MOV   [__r3],A
551B: 51 B6    MOV   A,[__r0]
551D: 53 B4    MOV   [__r2],A
551F: 50 00    MOV   A,0
5521: 08       PUSH  A
5522: 08       PUSH  A
5523: 51 B4    MOV   A,[__r2]
5525: 08       PUSH  A
5526: 51 B3    MOV   A,[__r3]
5528: 08       PUSH  A
5529: 50 00    MOV   A,0
552B: 08       PUSH  A
552C: 50 01    MOV   A,1
552E: 08       PUSH  A
552F: 50 86    MOV   A,134
5531: 08       PUSH  A
5532: 50 A0    MOV   A,160
5534: 08       PUSH  A
5535: 7C 57 3B LCALL __mul_32X32_32
5538: 38 FC    ADD   SP,252
553A: 18       POP   A
553B: 53 B3    MOV   [__r3],A
553D: 18       POP   A
553E: 53 B4    MOV   [__r2],A
5540: 18       POP   A
5541: 53 B5    MOV   [__r1],A
5543: 18       POP   A
5544: 53 B6    MOV   [__r0],A
5546: 52 FC    MOV   A,[X-4]
5548: 12 B3    SUB   A,[__r3]
554A: 52 FB    MOV   A,[X-5]
554C: 1A B4    SBB   A,[__r2]
554E: 52 FA    MOV   A,[X-6]
5550: 1A B5    SBB   A,[__r1]
5552: 52 F9    MOV   A,[X-7]
5554: 1A B6    SBB   A,[__r0]
5556: D0 03    JNC   0x555A
(0192) 			dwFreq < (g_xBandLimits[bBand].high*BAND_FREQ_MULT))
(0193) 			break;
5558: 80 08    JMP   0x5561
555A: 77 00    INC   [X+0]
555C: 3D 00 0E CMP   [X+0],14
555F: CF 2B    JC    0x548B
(0194) 	}
(0195) 	if (bBand>=BAND_MAX)
5561: 3D 00 0E CMP   [X+0],14
5564: C0 36    JC    0x559B
(0196) 	{
(0197) 		if (dwFreq>FREQ_MAX)
5566: 50 00    MOV   A,0
5568: 13 FC    SUB   A,[X-4]
556A: 50 87    MOV   A,135
556C: 1B FB    SBB   A,[X-5]
556E: 50 93    MOV   A,147
5570: 1B FA    SBB   A,[X-6]
5572: 50 03    MOV   A,3
5574: 1B F9    SBB   A,[X-7]
5576: D0 08    JNC   0x557F
(0198) 			return -1;
5578: 62 D0 02 MOV   REG[208],2
557B: 50 FF    MOV   A,255
557D: 80 22    JMP   0x55A0
(0199) 		if (dwFreq<FREQ_MIN)
557F: 52 FC    MOV   A,[X-4]
5581: 11 40    SUB   A,64
5583: 52 FB    MOV   A,[X-5]
5585: 19 42    SBB   A,66
5587: 52 FA    MOV   A,[X-6]
5589: 19 0F    SBB   A,15
558B: 52 F9    MOV   A,[X-7]
558D: 19 00    SBB   A,0
558F: D0 08    JNC   0x5598
(0200) 			return -1;
5591: 62 D0 02 MOV   REG[208],2
5594: 50 FF    MOV   A,255
5596: 80 09    JMP   0x55A0
(0201) 		bBand=BAND_MAX-1;
5598: 56 00 0D MOV   [X+0],13
(0202) 	}
(0203) 	return bBand;
7400: 71 10    OR    F,16

FILE: .\boot.asm
7402: 62 E3 87 MOV   REG[227],135  (0791) ; Generated by PSoC Designer 5.0.972.0
7405: 70 EF    AND   F,239         (0792) ;
                                   (0793) ;@Id: boot.tpl#895 @
7407: 41 FE FB AND   REG[254],251  (0794) ;=============================================================================
                                   (0795) ;  FILENAME:   boot.asm
                                   (0796) ;  VERSION:    4.18
740A: 50 80    MOV   A,128         (0797) ;  DATE:       28 June 2007
740C: 4E       SWAP  SP,A          (0798) ;
                                   (0799) ;  DESCRIPTION:
                                   (0800) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                   (0801) ;
                                   (0802) ;  Copyright (C) Cypress Semiconductor 2000-2005. All rights reserved.
                                   (0803) ;
                                   (0804) ; NOTES:
                                   (0805) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                   (0806) ; the project's root directory to create BOOT.ASM. Any changes made to
                                   (0807) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0808) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0809) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
740D: 55 F8 00 MOV   [bLastKey+2],0(0810) ; are not accidentally modified.
7410: 55 F9 00 MOV   [bLastKey+3],0(0811) ;
                                   (0812) ;=============================================================================
                                   (0813) 
7413: 71 10    OR    F,16          (0814) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
7415: 62 E0 02 MOV   REG[224],2    (0815) include "m8c.inc"			;Part specific file
7418: 43 E7 80 OR    REG[231],128  (0816) include "m8ssc.inc"			;Part specific file
741B: 70 EF    AND   F,239         (0817) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
741D: 62 E3 38 MOV   REG[227],56   (0818) 
                                   (0819) ;--------------------------------------
                                   (0820) ; Export Declarations
                                   (0821) ;--------------------------------------
                                   (0822) 
7420: 62 71 05 MOV   REG[113],5    (0823) export __Start
7423: 62 75 05 MOV   REG[117],5    (0824) IF	(TOOLCHAIN & HITECH)
7426: 62 79 05 MOV   REG[121],5    (0825) ELSE
7429: 62 7D 05 MOV   REG[125],5    (0826) export __bss_start
                                   (0827) export __data_start
                                   (0828) export __idata_start
                                   (0829) export __func_lit_start
                                   (0830) export __text_start
                                   (0831) ENDIF
742C: 62 D1 07 MOV   REG[209],7    (0832) export  _bGetPowerSetting
742F: 50 00    MOV   A,0           (0833) export   bGetPowerSetting
7431: 4E       SWAP  SP,A          (0834) 
7432: 62 D3 07 MOV   REG[211],7    (0835) 
7435: 62 D0 00 MOV   REG[208],0    (0836) ;--------------------------------------
7438: 62 D5 00 MOV   REG[213],0    (0837) ; Optimization flags
743B: 62 D4 00 MOV   REG[212],0    (0838) ;--------------------------------------
                                   (0839) ;
                                   (0840) ; To change the value of these flags, modify the file boot.tpl, not
743E: 71 C0    OR    F,192         (0841) ; boot.asm. See the notes in the banner comment at the beginning of
                                   (0842) ; this file.
                                   (0843) 
                                   (0844) ; Optimization for Assembly language (only) projects and C-language projects
                                   (0845) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                   (0846) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0847) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0848) ;
                                   (0849) IF	(TOOLCHAIN & HITECH)
                                   (0850) ; The C compiler will customize the startup code - it's not required here
                                   (0851) 
                                   (0852) C_LANGUAGE_SUPPORT:              equ 0
                                   (0853) ELSE
                                   (0854) C_LANGUAGE_SUPPORT:              equ 1
                                   (0855) ENDIF
                                   (0856) 
                                   (0857) 
7440: 7C 7A C3 LCALL 0x7AC3        (0858) ; The following equate is required for proper operation. Reseting its value
                                   (0859) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                   (0860) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                   (0861) ; and PLL_Lock must take place within user code. See the family data sheet for
                                   (0862) ; the requirements of starting the ECO and PLL lock mode.
                                   (0863) ;
                                   (0864) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                   (0865) ;                invoking main
                                   (0866) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
                                   (0867) ;               the time code in main starts executing.
                                   (0868) ;
                                   (0869) WAIT_FOR_32K:                    equ 1
                                   (0870) 
                                   (0871) 
                                   (0872) ; For historical reasons, by default the boot code uses an lcall instruction
                                   (0873) ; to invoke the user's _main code. If _main executes a return instruction,
                                   (0874) ; boot provides an infinite loop. By changing the following equate from zero
                                   (0875) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0876) ; bytes on the stack which are otherwise required for the return address. If
                                   (0877) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                   (0878) ; release, the C compiler automatically places an infinite loop at the end
                                   (0879) ; of main, rather than a return instruction.)
                                   (0880) ;
                                   (0881) ENABLE_LJMP_TO_MAIN:             equ 0
                                   (0882) 
                                   (0883) 
                                   (0884) ;-----------------------------------------------------------------------------
                                   (0885) ; Interrupt Vector Table
7443: 71 10    OR    F,16          (0886) ;-----------------------------------------------------------------------------
                                   (0887) ;
                                   (0888) ; Interrupt vector table entries are 4 bytes long.  Each one contains
7445: 43 E3 20 OR    REG[227],32   (0889) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                   (0890) ; very short ISRs could be encoded within the table itself. Normally,
                                   (0891) ; vector jump targets are modified automatically according to the user
                                   (0892) ; modules selected. This occurs when the 'Generate Application' opera-
7448: 70 EF    AND   F,239         (0893) ; tion is run causing PSoC Designer to create boot.asm and the other
                                   (0894) ; configuration files. If you need to hard code a vector, update the
                                   (0895) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0896) ; of this file.
                                   (0897) ;-----------------------------------------------------------------------------
                                   (0898) 
                                   (0899)     AREA TOP (ROM, ABS, CON)
                                   (0900) 
                                   (0901)     org   0                        ;Reset Interrupt Vector
744A: 62 E0 00 MOV   REG[224],0    (0902) IF	(TOOLCHAIN & HITECH)
                                   (0903) ;   jmp   __Start                  ;C compiler fills in this vector
                                   (0904) ELSE
                                   (0905)     ljmp   __Boot_Start                  ;First instruction executed following a Reset
744D: 71 10    OR    F,16          (0906) ;    jmp   __Start                  ;First instruction executed following a Reset
                                   (0907) ENDIF
744F: 62 E0 02 MOV   REG[224],2    (0908) 
7452: 70 EF    AND   F,239         (0909)     org   04h                      ;Supply Monitor Interrupt Vector
                                   (0910)     halt                           ;Stop execution if power falls too low
                                   (0911) 
                                   (0912)     org   08h                      ;Analog Column 0 Interrupt Vector
                                   (0913)     ljmp  0x0068
                                   (0914)     reti
7454: 62 E2 00 MOV   REG[226],0    (0915) 
                                   (0916)     org   0Ch                      ;Analog Column 1 Interrupt Vector
7457: 7C 78 3C LCALL _BootLoader   (0917)     ljmp  0x006C
                                   (0918)     reti
_Boot_ASCIItoBYTE:
  byte                 --> X+0
  High                 --> X-5
  Low                  --> X-4
745C: 10       PUSH  X             (0919) 
745D: 4F       MOV   X,SP
745E: 38 01    ADD   SP,1

FILE: C:\pchome\SWRANA~1\prj\SARK10~1\SARK10~1\SARK10~1\bootloader.c
(0066) //*****************************************************************************/
(0067) //  This file is a part of the "SARK100 SWR Analyzer firmware"
7460: 3D FB 61 CMP   [X-5],97
7463: C0 17    JC    0x747B
7465: 62 D0 02 MOV   REG[208],2
7468: 52 FB    MOV   A,[X-5]
746A: 11 61    SUB   A,97
746C: 53 B6    MOV   [__r0],A
746E: 06 B6 0A ADD   [__r0],10
7471: 51 B6    MOV   A,[__r0]
7473: 64       ASL   A
7474: 64       ASL   A
7475: 64       ASL   A
7476: 64       ASL   A
7477: 54 00    MOV   [X+0],A
7479: 80 0E    JMP   0x7488
747B: 62 D0 02 MOV   REG[208],2
747E: 52 FB    MOV   A,[X-5]
7480: 11 30    SUB   A,48
7482: 64       ASL   A
7483: 64       ASL   A
7484: 64       ASL   A
7485: 64       ASL   A
7486: 54 00    MOV   [X+0],A
(0068) //
7488: 3D FC 61 CMP   [X-4],97
748B: C0 15    JC    0x74A1
748D: 62 D0 02 MOV   REG[208],2
7490: 52 FC    MOV   A,[X-4]
7492: 11 61    SUB   A,97
7494: 53 B6    MOV   [__r0],A
7496: 06 B6 0A ADD   [__r0],10
7499: 52 00    MOV   A,[X+0]
749B: 2A B6    OR    A,[__r0]
749D: 54 00    MOV   [X+0],A
749F: 80 10    JMP   0x74B0
74A1: 62 D0 02 MOV   REG[208],2
74A4: 52 FC    MOV   A,[X-4]
74A6: 11 30    SUB   A,48
74A8: 53 B6    MOV   [__r0],A
74AA: 52 00    MOV   A,[X+0]
74AC: 2A B6    OR    A,[__r0]
74AE: 54 00    MOV   [X+0],A
(0069) //  Copyright © 2010 Melchor Varela - EA4FRB.  All rights reserved.
74B0: 52 00    MOV   A,[X+0]
74B2: 62 D0 02 MOV   REG[208],2
74B5: 38 FF    ADD   SP,255
74B7: 20       POP   X
74B8: 7F       RET   
(0070) //  Melchor Varela, Madrid, Spain.
(0071) //  melchor.varela@gmail.com
(0072) //
_Boot_UART_cGetChar:
  bRxStatus            --> X+0
74B9: 10       PUSH  X
74BA: 4F       MOV   X,SP
74BB: 38 01    ADD   SP,1
(0073) //  "SARK100 SWR Analyzer firmware" is free software: you can redistribute it
(0074) //  and/or modify it under the terms of the GNU General Public License as
74BD: 10       PUSH  X
74BE: 7C 7C BC LCALL 0x7CBC
74C1: 62 D0 02 MOV   REG[208],2
74C4: 20       POP   X
74C5: 53 B6    MOV   [__r0],A
74C7: 26 B6 08 AND   [__r0],8
74CA: 51 B6    MOV   A,[__r0]
74CC: 54 00    MOV   [X+0],A
74CE: 3C B6 00 CMP   [__r0],0
74D1: AF EB    JZ    0x74BD
(0075) //  published by the Free Software Foundation, either version 3 of the License,
74D3: 10       PUSH  X
74D4: 7C 7C B9 LCALL 0x7CB9
74D7: 62 D0 02 MOV   REG[208],2
74DA: 20       POP   X
74DB: 38 FF    ADD   SP,255
74DD: 20       POP   X
74DE: 7F       RET   
(0076) //  or (at your option) any later version.
(0077) //
(0078) //  "SARK100 SWR Analyzer firmware" is distributed in the hope that it will be
_Boot_UART_PutChar:
  TxData               --> X-4
74DF: 10       PUSH  X
74E0: 4F       MOV   X,SP
(0079) //  useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of
74E1: 10       PUSH  X
74E2: 7C 7C C7 LCALL 0x7CC7
74E5: 62 D0 02 MOV   REG[208],2
74E8: 20       POP   X
74E9: 53 B6    MOV   [__r0],A
74EB: 47 B6 10 TST   [__r0],16
74EE: AF F2    JZ    0x74E1
(0080) //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
74F0: 10       PUSH  X
74F1: 52 FC    MOV   A,[X-4]
74F3: 7C 7C C4 LCALL 0x7CC4
74F6: 20       POP   X
74F7: 20       POP   X
74F8: 7F       RET   
(0081) //  GNU General Public License for more details.
(0082) //
(0083) //  You should have received a copy of the GNU General Public License
_Boot_UART_CPutString:
  pstr                 --> X-5
74F9: 10       PUSH  X
74FA: 4F       MOV   X,SP
74FB: 80 18    JMP   0x7514
(0084) //  along with "SARK100 SWR Analyzer firmware".  If not,
(0085) //  see <http://www.gnu.org/licenses/>.
74FD: 62 D0 02 MOV   REG[208],2
7500: 52 FC    MOV   A,[X-4]
7502: 53 B5    MOV   [__r1],A
7504: 52 FB    MOV   A,[X-5]
7506: 60 D4    MOV   REG[212],A
7508: 3E B5    MVI   A,[__r1]
750A: 08       PUSH  A
750B: 9F D2    CALL  _Boot_UART_PutChar
750D: 38 FF    ADD   SP,255
(0086) //*****************************************************************************/
750F: 77 FC    INC   [X-4]
7511: 0F FB 00 ADC   [X-5],0
7514: 62 D0 02 MOV   REG[208],2
7517: 52 FC    MOV   A,[X-4]
7519: 53 B5    MOV   [__r1],A
751B: 52 FB    MOV   A,[X-5]
751D: 60 D4    MOV   REG[212],A
751F: 3E B5    MVI   A,[__r1]
7521: 39 00    CMP   A,0
7523: BF D9    JNZ   0x74FD
7525: 20       POP   X
7526: 7F       RET   
(0087) //*****************************************************************************/
(0088) //
(0089) //	PROJECT:	SARK100 SWR Analyzer
(0090) // 	FILE NAME: 	BOOTLOADER.C
_Boot_PerformWrite:
  BlockID              --> X+88
  led                  --> X+87
  frStruct             --> X+81
  j                    --> X+79
  fwStruct             --> X+71
  data                 --> X+3
  cl                   --> X+2
  i                    --> X+1
  ch                   --> X+0
7527: 10       PUSH  X
7528: 4F       MOV   X,SP
7529: 38 5A    ADD   SP,90
(0091) // 	AUTHOR:		EA4FRB - Melchor Varela
(0092) //
(0093) // 	DESCRIPTION
(0094) //
(0095) //	Bootloader main logic
(0096) //
752B: 56 57 00 MOV   [X+87],0
752E: 81 93    JMP   0x76C2
(0097) // 	HISTORY
(0098) //
(0099) //	NAME   	DATE		REMARKS
(0100) //
7530: 52 57    MOV   A,[X+87]
7532: 73       CPL   A
7533: 54 57    MOV   [X+87],A
(0101) //	MVM	   	DEC 2009	Creation
7535: 9F 82    CALL  _Boot_UART_cGetChar
7537: 62 D0 02 MOV   REG[208],2
753A: 54 00    MOV   [X+0],A
753C: 39 53    CMP   A,83
753E: BF F6    JNZ   0x7535
(0102) //
7540: 9F 77    CALL  _Boot_UART_cGetChar
7542: 62 D0 02 MOV   REG[208],2
7545: 54 00    MOV   [X+0],A
7547: 39 53    CMP   A,83
7549: B0 03    JNZ   0x754D
754B: 81 78    JMP   0x76C4
(0103) //*****************************************************************************/
(0104) #include <m8c.h>        	// part specific constants and macros
754D: 9F 6A    CALL  _Boot_UART_cGetChar
754F: 62 D0 02 MOV   REG[208],2
7552: 54 02    MOV   [X+2],A
(0105) #include "bootloader.h"    	// API definitions for all BootLoader Modules
7554: 52 00    MOV   A,[X+0]
7556: 08       PUSH  A
7557: 52 02    MOV   A,[X+2]
7559: 08       PUSH  A
755A: 9F 00    CALL  _Boot_ASCIItoBYTE
755C: 38 FE    ADD   SP,254
755E: 62 D0 02 MOV   REG[208],2
7561: 54 03    MOV   [X+3],A
(0106) #include "psocgpioint.h"
(0107) #include <FlashBlock.h>
7563: 56 01 01 MOV   [X+1],1
7566: 80 38    JMP   0x759F
(0108) 
7568: 9F 4F    CALL  _Boot_UART_cGetChar
756A: 62 D0 02 MOV   REG[208],2
756D: 54 00    MOV   [X+0],A
(0109) #define LAST_BLOCK_TO_CHECK	0		// Minimum = 1; Maximum = 455; if 0 then don't calculate CS
756F: 9F 48    CALL  _Boot_UART_cGetChar
7571: 62 D0 02 MOV   REG[208],2
7574: 54 02    MOV   [X+2],A
(0110) #define ENABLE_CONNECT_BY_PSOC	1	// 0-disable 	1-enable
7576: 52 00    MOV   A,[X+0]
7578: 08       PUSH  A
7579: 52 02    MOV   A,[X+2]
757B: 08       PUSH  A
757C: 9E DE    CALL  _Boot_ASCIItoBYTE
757E: 38 FE    ADD   SP,254
7580: 62 D0 02 MOV   REG[208],2
7583: 53 B6    MOV   [__r0],A
7585: 55 B4 07 MOV   [__r2],7
7588: 5A B3    MOV   [__r3],X
758A: 06 B3 03 ADD   [__r3],3
758D: 52 01    MOV   A,[X+1]
758F: 02 B3    ADD   A,[__r3]
7591: 53 B3    MOV   [__r3],A
7593: 50 00    MOV   A,0
7595: 0A B4    ADC   A,[__r2]
7597: 60 D5    MOV   REG[213],A
7599: 51 B6    MOV   A,[__r0]
759B: 3F B3    MVI   [__r3],A
759D: 77 01    INC   [X+1]
759F: 3D 01 44 CMP   [X+1],68
75A2: CF C5    JC    0x7568
(0111) 
(0112) #pragma text:BootCheckSum
(0113) #pragma abs_address:0x7200
(0114) const char BootCheckSumBlock[];
75A4: 9F 13    CALL  _Boot_UART_cGetChar
75A6: 62 D0 02 MOV   REG[208],2
75A9: 54 00    MOV   [X+0],A
75AB: 39 46    CMP   A,70
75AD: A0 01    JZ    0x75AF
(0115) #pragma abs_address:0x73FE
(0116) const int LastBlock_To_Check = LAST_BLOCK_TO_CHECK;
(0117) #pragma end_abs_address
75AF: 62 D0 02 MOV   REG[208],2
75B2: 52 05    MOV   A,[X+5]
75B4: 53 B5    MOV   [__r1],A
75B6: 55 B6 00 MOV   [__r0],0
75B9: 68 B6    ASR   [__r0]
75BB: 6E B5    RRC   [__r1]
75BD: 68 B6    ASR   [__r0]
75BF: 6E B5    RRC   [__r1]
75C1: 68 B6    ASR   [__r0]
75C3: 6E B5    RRC   [__r1]
75C5: 68 B6    ASR   [__r0]
75C7: 6E B5    RRC   [__r1]
75C9: 68 B6    ASR   [__r0]
75CB: 6E B5    RRC   [__r1]
75CD: 68 B6    ASR   [__r0]
75CF: 6E B5    RRC   [__r1]
75D1: 52 04    MOV   A,[X+4]
75D3: 53 B3    MOV   [__r3],A
75D5: 55 B4 00 MOV   [__r2],0
75D8: 65 B3    ASL   [__r3]
75DA: 6B B4    RLC   [__r2]
75DC: 65 B3    ASL   [__r3]
75DE: 6B B4    RLC   [__r2]
75E0: 51 B3    MOV   A,[__r3]
75E2: 02 B5    ADD   A,[__r1]
75E4: 53 B5    MOV   [__r1],A
75E6: 51 B4    MOV   A,[__r2]
75E8: 0A B6    ADC   A,[__r0]
75EA: 53 B6    MOV   [__r0],A
75EC: 51 B5    MOV   A,[__r1]
75EE: 54 48    MOV   [X+72],A
75F0: 51 B6    MOV   A,[__r0]
75F2: 54 47    MOV   [X+71],A
(0118) 
75F4: 5A B5    MOV   [__r1],X
75F6: 06 B5 07 ADD   [__r1],7
75F9: 51 B5    MOV   A,[__r1]
75FB: 54 4A    MOV   [X+74],A
75FD: 56 49 07 MOV   [X+73],7
(0119) #pragma text:BootLoaderArea
7600: 56 4B 19 MOV   [X+75],25
(0120) 
7603: 5A B5    MOV   [__r1],X
7605: 06 B5 47 ADD   [__r1],71
7608: 10       PUSH  X
7609: 50 07    MOV   A,7
760B: 08       PUSH  A
760C: 51 B5    MOV   A,[__r1]
760E: 5C       MOV   X,A
760F: 18       POP   A
7610: 7C 7D 8B LCALL 0x7D8B
7613: 62 D0 02 MOV   REG[208],2
7616: 20       POP   X
(0121) //#define SETBUTTON()	PRT0DR|=0x20	// pull up for button on P0[5] pin
(0122) //#define GETBUTTON() (PRT0DR&0x20)		// get value on button pin
(0123) //#define BOOTLOADER_MODE_LED_ON() PRT1DR|=0x80
7617: 52 48    MOV   A,[X+72]
7619: 54 52    MOV   [X+82],A
761B: 52 47    MOV   A,[X+71]
761D: 54 51    MOV   [X+81],A
(0124) //#define BOOTLOADER_MODE_LED_OFF() PRT1DR&=0x7F
761F: 5A B5    MOV   [__r1],X
7621: 06 B5 07 ADD   [__r1],7
7624: 51 B5    MOV   A,[__r1]
7626: 54 54    MOV   [X+84],A
7628: 56 53 07 MOV   [X+83],7
(0125) 
762B: 56 56 40 MOV   [X+86],64
762E: 56 55 00 MOV   [X+85],0
(0126) //extern void Boot_LoadConfigInit(void);
7631: 5A B5    MOV   [__r1],X
7633: 06 B5 51 ADD   [__r1],81
7636: 10       PUSH  X
7637: 50 07    MOV   A,7
7639: 08       PUSH  A
763A: 51 B5    MOV   A,[__r1]
763C: 5C       MOV   X,A
763D: 18       POP   A
763E: 7C 7F 15 LCALL 0x7F15
7641: 20       POP   X
(0127) extern char FlashCheckSum(int);
(0128) extern char Boot_Is_Program_Good(void);
(0129) 
7642: 50 53    MOV   A,83
7644: 08       PUSH  A
7645: 9E 98    CALL  _Boot_UART_PutChar
7647: 38 FF    ADD   SP,255
(0130) char Boot_ASCIItoBYTE(char Low,char High){
7649: 56 01 00 MOV   [X+1],0
764C: 80 69    JMP   0x76B6
(0131)     char byte;
764E: 62 D0 02 MOV   REG[208],2
7651: 55 B6 07 MOV   [__r0],7
7654: 5A B5    MOV   [__r1],X
7656: 06 B5 03 ADD   [__r1],3
7659: 52 01    MOV   A,[X+1]
765B: 02 B5    ADD   A,[__r1]
765D: 53 B5    MOV   [__r1],A
765F: 50 00    MOV   A,0
7661: 0A B6    ADC   A,[__r0]
7663: 60 D4    MOV   REG[212],A
7665: 3E B5    MVI   A,[__r1]
7667: 67       ASR   A
7668: 67       ASR   A
7669: 67       ASR   A
766A: 67       ASR   A
766B: 21 0F    AND   A,15
766D: 54 00    MOV   [X+0],A
(0132) 	if (High>='a') byte=(High-'a'+10)<<4; else byte=(High-'0')<<4;
766F: 3D 00 0A CMP   [X+0],10
7672: C0 06    JC    0x7679
7674: 07 00 57 ADD   [X+0],87
7677: 80 04    JMP   0x767C
7679: 07 00 30 ADD   [X+0],48
(0133) 	if (Low>='a') byte|=(Low-'a'+10); else byte|=(Low-'0');
767C: 52 00    MOV   A,[X+0]
767E: 08       PUSH  A
767F: 9E 5E    CALL  _Boot_UART_PutChar
7681: 38 FF    ADD   SP,255
(0134) 	return byte;
7683: 62 D0 02 MOV   REG[208],2
7686: 55 B6 07 MOV   [__r0],7
7689: 5A B5    MOV   [__r1],X
768B: 06 B5 03 ADD   [__r1],3
768E: 52 01    MOV   A,[X+1]
7690: 02 B5    ADD   A,[__r1]
7692: 53 B5    MOV   [__r1],A
7694: 50 00    MOV   A,0
7696: 0A B6    ADC   A,[__r0]
7698: 60 D4    MOV   REG[212],A
769A: 3E B5    MVI   A,[__r1]
769C: 21 0F    AND   A,15
769E: 54 02    MOV   [X+2],A
(0135) }
76A0: 3D 02 0A CMP   [X+2],10
76A3: C0 06    JC    0x76AA
76A5: 07 02 57 ADD   [X+2],87
76A8: 80 04    JMP   0x76AD
76AA: 07 02 30 ADD   [X+2],48
(0136) 
76AD: 52 02    MOV   A,[X+2]
76AF: 08       PUSH  A
76B0: 9E 2D    CALL  _Boot_UART_PutChar
76B2: 38 FF    ADD   SP,255
76B4: 77 01    INC   [X+1]
76B6: 3D 01 44 CMP   [X+1],68
76B9: CF 94    JC    0x764E
(0137) BYTE Boot_UART_cGetChar(void){
(0138) 	BYTE bRxStatus;
76BB: 50 46    MOV   A,70
76BD: 08       PUSH  A
76BE: 9E 1F    CALL  _Boot_UART_PutChar
76C0: 38 FF    ADD   SP,255
76C2: 8E 6D    JMP   0x7530
(0139) 	while (!(bRxStatus=Boot_RxD_bReadRxStatus() & RX8_RX_COMPLETE));
(0140)     return Boot_RxD_bReadRxData();
(0141) }
76C4: 62 D0 02 MOV   REG[208],2
76C7: 50 73    MOV   A,115
76C9: 10       PUSH  X
76CA: 08       PUSH  A
76CB: 57 FE    MOV   X,254
76CD: 28       ROMX  
76CE: 53 B6    MOV   [__r0],A
76D0: 18       POP   A
76D1: 75       INC   X
76D2: 09 00    ADC   A,0
76D4: 28       ROMX  
76D5: 20       POP   X
76D6: 3C B6 00 CMP   [__r0],0
76D9: B0 07    JNZ   0x76E1
76DB: 39 00    CMP   A,0
76DD: B0 03    JNZ   0x76E1
76DF: 81 58    JMP   0x7838
(0142) 
76E1: 56 59 C8 MOV   [X+89],200
76E4: 56 58 01 MOV   [X+88],1
(0143) void Boot_UART_PutChar(char TxData){
(0144) 	while (!(Boot_TxD_bReadTxStatus() & TX8_TX_BUFFER_EMPTY));
76E7: 56 50 01 MOV   [X+80],1
76EA: 56 4F 00 MOV   [X+79],0
76ED: 80 83    JMP   0x7771
(0145) 	Boot_TxD_SendData(TxData);
76EF: 62 D0 02 MOV   REG[208],2
76F2: 52 50    MOV   A,[X+80]
76F4: 21 3F    AND   A,63
76F6: 53 B5    MOV   [__r1],A
76F8: 52 4F    MOV   A,[X+79]
76FA: 21 00    AND   A,0
76FC: 39 00    CMP   A,0
76FE: B0 39    JNZ   0x7738
7700: 3C B5 00 CMP   [__r1],0
7703: B0 34    JNZ   0x7738
(0146) }
7705: 52 59    MOV   A,[X+89]
7707: 54 48    MOV   [X+72],A
7709: 52 58    MOV   A,[X+88]
770B: 54 47    MOV   [X+71],A
(0147) 
770D: 62 D0 02 MOV   REG[208],2
7710: 5A B5    MOV   [__r1],X
7712: 06 B5 03 ADD   [__r1],3
7715: 51 B5    MOV   A,[__r1]
7717: 54 4A    MOV   [X+74],A
7719: 56 49 07 MOV   [X+73],7
(0148) void Boot_UART_CPutString(char* pstr){
771C: 56 4B 19 MOV   [X+75],25
(0149) 	while (*pstr != 0){
771F: 5A B5    MOV   [__r1],X
7721: 06 B5 47 ADD   [__r1],71
7724: 10       PUSH  X
7725: 50 07    MOV   A,7
7727: 08       PUSH  A
7728: 51 B5    MOV   A,[__r1]
772A: 5C       MOV   X,A
772B: 18       POP   A
772C: 7C 7D 8B LCALL 0x7D8B
772F: 62 D0 02 MOV   REG[208],2
7732: 20       POP   X
(0150) 	   Boot_UART_PutChar(*pstr);
7733: 77 59    INC   [X+89]
7735: 0F 58 00 ADC   [X+88],0
(0151) 	   pstr++;
(0152) 	}
7738: 52 4F    MOV   A,[X+79]
773A: 08       PUSH  A
773B: 52 50    MOV   A,[X+80]
773D: 08       PUSH  A
773E: 7C 7D 43 LCALL 0x7D43
7741: 38 FE    ADD   SP,254
7743: 62 D0 02 MOV   REG[208],2
7746: 53 B6    MOV   [__r0],A
7748: 55 B4 07 MOV   [__r2],7
774B: 5A B3    MOV   [__r3],X
774D: 06 B3 03 ADD   [__r3],3
7750: 52 50    MOV   A,[X+80]
7752: 21 3F    AND   A,63
7754: 53 B1    MOV   [__r5],A
7756: 52 4F    MOV   A,[X+79]
7758: 21 00    AND   A,0
775A: 53 B2    MOV   [__r4],A
775C: 51 B1    MOV   A,[__r5]
775E: 02 B3    ADD   A,[__r3]
7760: 53 B3    MOV   [__r3],A
7762: 51 B2    MOV   A,[__r4]
7764: 0A B4    ADC   A,[__r2]
7766: 60 D5    MOV   REG[213],A
7768: 51 B6    MOV   A,[__r0]
776A: 3F B3    MVI   [__r3],A
776C: 77 50    INC   [X+80]
776E: 0F 4F 00 ADC   [X+79],0
7771: 62 D0 02 MOV   REG[208],2
7774: 50 73    MOV   A,115
7776: 10       PUSH  X
7777: 08       PUSH  A
7778: 57 FE    MOV   X,254
777A: 28       ROMX  
777B: 53 B6    MOV   [__r0],A
777D: 18       POP   A
777E: 75       INC   X
777F: 09 00    ADC   A,0
7781: 28       ROMX  
7782: 20       POP   X
7783: 13 50    SUB   A,[X+80]
7785: 52 4F    MOV   A,[X+79]
7787: 31 80    XOR   A,128
7789: 53 AC    MOV   [__rX],A
778B: 51 B6    MOV   A,[__r0]
778D: 31 80    XOR   A,128
778F: 1A AC    SBB   A,[__rX]
7791: DF 5D    JNC   0x76EF
(0153) }
(0154) 
(0155) void Boot_PerformWrite(){
7793: 52 59    MOV   A,[X+89]
7795: 54 48    MOV   [X+72],A
7797: 52 58    MOV   A,[X+88]
7799: 54 47    MOV   [X+71],A
(0156) 	char data[68];
779B: 62 D0 02 MOV   REG[208],2
779E: 5A B5    MOV   [__r1],X
77A0: 06 B5 03 ADD   [__r1],3
77A3: 51 B5    MOV   A,[__r1]
77A5: 54 4A    MOV   [X+74],A
77A7: 56 49 07 MOV   [X+73],7
(0157) 	char i,ch,cl;
77AA: 56 4B 19 MOV   [X+75],25
(0158) 	int BlockID,j;
(0159) 	FLASH_WRITE_STRUCT fwStruct;
77AD: 3D 58 01 CMP   [X+88],1
77B0: B0 06    JNZ   0x77B7
77B2: 3D 59 CF CMP   [X+89],207
77B5: A0 1E    JZ    0x77D4
(0160) 	FLASH_READ_STRUCT frStruct;
77B7: 62 D0 02 MOV   REG[208],2
77BA: 5A B5    MOV   [__r1],X
77BC: 06 B5 47 ADD   [__r1],71
77BF: 10       PUSH  X
77C0: 50 07    MOV   A,7
77C2: 08       PUSH  A
77C3: 51 B5    MOV   A,[__r1]
77C5: 5C       MOV   X,A
77C6: 18       POP   A
77C7: 7C 7D 8B LCALL 0x7D8B
77CA: 62 D0 02 MOV   REG[208],2
77CD: 20       POP   X
(0161) 	char led=0x00;	//LED off
77CE: 56 59 CF MOV   [X+89],207
77D1: 56 58 01 MOV   [X+88],1
(0162) 
(0163)     while(1){
(0164) //       if (led) BOOTLOADER_MODE_LED_OFF(); else BOOTLOADER_MODE_LED_ON();
77D4: 62 D0 02 MOV   REG[208],2
77D7: 50 73    MOV   A,115
77D9: 10       PUSH  X
77DA: 08       PUSH  A
77DB: 57 FE    MOV   X,254
77DD: 28       ROMX  
77DE: 53 B6    MOV   [__r0],A
77E0: 18       POP   A
77E1: 75       INC   X
77E2: 09 00    ADC   A,0
77E4: 28       ROMX  
77E5: 20       POP   X
77E6: 51 B6    MOV   A,[__r0]
77E8: 53 B5    MOV   [__r1],A
77EA: 47 B5 80 TST   [__r1],128
77ED: B0 06    JNZ   0x77F4
77EF: 55 B6 00 MOV   [__r0],0
77F2: 80 04    JMP   0x77F7
77F4: 62 D0 02 MOV   REG[208],2
77F7: 62 D0 02 MOV   REG[208],2
77FA: 51 B5    MOV   A,[__r1]
77FC: 54 41    MOV   [X+65],A
(0165)        led=~led;
77FE: 50 73    MOV   A,115
7800: 10       PUSH  X
7801: 08       PUSH  A
7802: 57 FE    MOV   X,254
7804: 28       ROMX  
7805: 18       POP   A
7806: 75       INC   X
7807: 09 00    ADC   A,0
7809: 28       ROMX  
780A: 20       POP   X
780B: 54 42    MOV   [X+66],A
(0166)        while ((ch=Boot_UART_cGetChar())!='S'); // waiting for start symbol 'S'
(0167) 	   if ((ch = Boot_UART_cGetChar())=='S') break; // All blocks are sent ?
780D: 52 59    MOV   A,[X+89]
780F: 54 48    MOV   [X+72],A
7811: 52 58    MOV   A,[X+88]
7813: 54 47    MOV   [X+71],A
(0168) 	      else {
7815: 5A B5    MOV   [__r1],X
7817: 06 B5 03 ADD   [__r1],3
781A: 51 B5    MOV   A,[__r1]
781C: 54 4A    MOV   [X+74],A
781E: 56 49 07 MOV   [X+73],7
(0169) 		    cl=Boot_UART_cGetChar();
7821: 56 4B 19 MOV   [X+75],25
(0170) 	        data[0]=Boot_ASCIItoBYTE(cl,ch);
7824: 5A B5    MOV   [__r1],X
7826: 06 B5 47 ADD   [__r1],71
7829: 10       PUSH  X
782A: 50 07    MOV   A,7
782C: 08       PUSH  A
782D: 51 B5    MOV   A,[__r1]
782F: 5C       MOV   X,A
7830: 18       POP   A
7831: 7C 7D 8B LCALL 0x7D8B
7834: 62 D0 02 MOV   REG[208],2
7837: 20       POP   X
7838: 38 A6    ADD   SP,166
783A: 20       POP   X
783B: 7F       RET   
(0171) 	      }
(0172) 	   for (i=1; i<68; i++) {
(0173) 	      ch=Boot_UART_cGetChar();  // Read high nibble
_BootLoader:
  CheckSum             --> X+27
  k                    --> X+26
  j                    --> X+24
  strConnect           --> X+16
  strAnswer            --> X+12
  Error                --> X+11
  buffer               --> X+1
  i                    --> X+0
783C: 10       PUSH  X
783D: 4F       MOV   X,SP
783E: 38 1C    ADD   SP,28
(0174) 	      cl=Boot_UART_cGetChar();  // Read low nibble
(0175) 	      data[i]=Boot_ASCIItoBYTE(cl,ch);  // Write transformed byte in buffer
(0176) 	   }
(0177) 
(0178) 	   // Read Last Block Symbol 'F'
(0179) 	   if ((ch=Boot_UART_cGetChar())!='F') ; // Error Info!
(0180) 
(0181) 	   // Write Block to Flash
(0182) 	   fwStruct.wARG_BlockId = (((int)data[1])<<2) + (data[2]>>6); // Form Block ID form Block Address
(0183) 	   fwStruct.pARG_FlashBuffer = data+4;	// Data start Address
(0184) 	   fwStruct.cARG_Temperature = 25;		// Temperature in Celsius
(0185) 	   bFlashWriteBlock(&fwStruct);			// Write Block
7840: 56 10 43 MOV   [X+16],67
7843: 56 11 4F MOV   [X+17],79
7846: 56 12 4E MOV   [X+18],78
7849: 56 13 4E MOV   [X+19],78
784C: 56 14 45 MOV   [X+20],69
(0186) 
784F: 56 15 43 MOV   [X+21],67
7852: 56 16 54 MOV   [X+22],84
7855: 56 17 00 MOV   [X+23],0
(0187) 	   // Read back Block
7858: 56 0C 4F MOV   [X+12],79
785B: 56 0D 4B MOV   [X+13],75
785E: 56 0E 21 MOV   [X+14],33
7861: 56 0F 00 MOV   [X+15],0
(0188) 	   frStruct.wARG_BlockId = fwStruct.wARG_BlockId;	// Read back the same block
(0189) 	   frStruct.pARG_FlashBuffer = data+4;  // Buffer Address
(0190) 	   frStruct.wARG_ReadCount = 64;		// Read 64 bytes
7864: 10       PUSH  X
7865: 50 00    MOV   A,0
7867: 7C 7C B0 LCALL 0x7CB0
786A: 20       POP   X
(0191) 	   FlashReadBlock(&frStruct);			// Read Block
786B: 10       PUSH  X
786C: 50 00    MOV   A,0
786E: 7C 7C BF LCALL 0x7CBF
7871: 20       POP   X
(0192) 
(0193) 	   // Sending Back Written Block for Analyzing
(0194) 	   Boot_UART_PutChar('S');	   // Start frame Symbol
(0195) 	   for (i=0;i<68;i++){
(0196) 	      ch = data[i]>>4;
(0197) 	      if (ch>=0x0A) ch+=('a'-10); else ch+='0';
7872: 5D FF    MOV   A,REG[255]
7874: 62 D0 02 MOV   REG[208],2
7877: 53 B6    MOV   [__r0],A
7879: 47 B6 10 TST   [__r0],16
787C: A0 CA    JZ    0x7947
(0198) 	      Boot_UART_PutChar(ch);		// Send High Nibble
787E: 5A B5    MOV   [__r1],X
7880: 06 B5 10 ADD   [__r1],16
7883: 50 07    MOV   A,7
7885: 08       PUSH  A
7886: 51 B5    MOV   A,[__r1]
7888: 08       PUSH  A
7889: 9C 6E    CALL  _Boot_UART_CPutString
788B: 38 FE    ADD   SP,254
(0199) 	      cl = data[i]&0x0F;
788D: 10       PUSH  X
788E: 7C 7C CA LCALL 0x7CCA
7891: 20       POP   X
(0200) 	      if (cl>=0x0A) cl+=('a'-10); else cl+='0';
7892: 10       PUSH  X
7893: 57 1F    MOV   X,31
7895: 50 FF    MOV   A,255
7897: 7C 7C D2 LCALL 0x7CD2
789A: 20       POP   X
(0201) 	      Boot_UART_PutChar(cl);		// Send Low Nibble
789B: 10       PUSH  X
789C: 57 0F    MOV   X,15
789E: 50 FE    MOV   A,254
78A0: 7C 7C D8 LCALL 0x7CD8
(0202) 	   }
78A3: 7C 7C CE LCALL 0x7CCE
78A6: 20       POP   X
(0203) 	   Boot_UART_PutChar('F');	   // Last frame Symbol
78A7: 56 1A 00 MOV   [X+26],0
78AA: 80 84    JMP   0x792F
(0204) 	}
(0205) 
78AC: 10       PUSH  X
78AD: 7C 7C BC LCALL 0x7CBC
78B0: 62 D0 02 MOV   REG[208],2
78B3: 20       POP   X
78B4: 53 B6    MOV   [__r0],A
78B6: 47 B6 08 TST   [__r0],8
78B9: A0 59    JZ    0x7913
(0206) 	if (LastBlock_To_Check==0) return;	// Don't calculate a checksum
78BB: 10       PUSH  X
78BC: 7C 7C B9 LCALL 0x7CB9
78BF: 62 D0 02 MOV   REG[208],2
78C2: 20       POP   X
78C3: 53 B6    MOV   [__r0],A
78C5: 55 B4 07 MOV   [__r2],7
78C8: 5A B3    MOV   [__r3],X
78CA: 06 B3 01 ADD   [__r3],1
78CD: 52 1A    MOV   A,[X+26]
78CF: 02 B3    ADD   A,[__r3]
78D1: 53 B3    MOV   [__r3],A
78D3: 50 00    MOV   A,0
78D5: 0A B4    ADC   A,[__r2]
78D7: 60 D5    MOV   REG[213],A
78D9: 51 B6    MOV   A,[__r0]
78DB: 3F B3    MVI   [__r3],A
(0207) 	BlockID = 456;	// first block where checksum is saved (blocks of CheckSum Area:456,457,458,459,460,461,462,463)
78DD: 55 B6 07 MOV   [__r0],7
78E0: 5A B5    MOV   [__r1],X
78E2: 06 B5 0C ADD   [__r1],12
78E5: 52 1A    MOV   A,[X+26]
78E7: 02 B5    ADD   A,[__r1]
78E9: 53 B5    MOV   [__r1],A
78EB: 50 00    MOV   A,0
78ED: 0A B6    ADC   A,[__r0]
78EF: 60 D4    MOV   REG[212],A
78F1: 3E B5    MVI   A,[__r1]
78F3: 53 B6    MOV   [__r0],A
78F5: 5A B3    MOV   [__r3],X
78F7: 06 B3 01 ADD   [__r3],1
78FA: 52 1A    MOV   A,[X+26]
78FC: 02 B3    ADD   A,[__r3]
78FE: 53 B3    MOV   [__r3],A
7900: 50 00    MOV   A,0
7902: 0A B4    ADC   A,[__r2]
7904: 60 D4    MOV   REG[212],A
7906: 3E B3    MVI   A,[__r3]
7908: 3A B6    CMP   A,[__r0]
790A: B0 05    JNZ   0x7910
790C: 77 1A    INC   [X+26]
790E: 80 04    JMP   0x7913
(0208) 	// Calculate CheckSum and Write It In Flash
7910: 56 1A 00 MOV   [X+26],0
(0209) 	for (j=1;j<=LastBlock_To_Check;j++){
(0210) 		if ((j&0x3F)==0) {
7913: 3D 1A 03 CMP   [X+26],3
7916: B0 18    JNZ   0x792F
(0211)  		  fwStruct.wARG_BlockId = BlockID;       // Block ID
7918: 62 D0 02 MOV   REG[208],2
791B: 5A B5    MOV   [__r1],X
791D: 06 B5 0C ADD   [__r1],12
7920: 50 07    MOV   A,7
7922: 08       PUSH  A
7923: 51 B5    MOV   A,[__r1]
7925: 08       PUSH  A
7926: 9B D1    CALL  _Boot_UART_CPutString
7928: 38 FE    ADD   SP,254
(0212) 	      fwStruct.pARG_FlashBuffer = data;  	// Data start Address
792A: 9B FB    CALL  _Boot_PerformWrite
(0213) 	      fwStruct.cARG_Temperature = 25;		// Temperature in Celsius
792C: 50 00    MOV   A,0
792E: 00       SWI   
792F: 10       PUSH  X
7930: 7C 7C DE LCALL 0x7CDE
7933: 62 D0 02 MOV   REG[208],2
7936: 5A B6    MOV   [__r0],X
7938: 20       POP   X
7939: 3C B6 00 CMP   [__r0],0
793C: BF 6F    JNZ   0x78AC
793E: 39 00    CMP   A,0
7940: BF 6B    JNZ   0x78AC
(0214) 	      bFlashWriteBlock(&fwStruct);			// Write Block
(0215)  		  BlockID++;							// Increment Block ID
(0216) 		}
7942: 10       PUSH  X
7943: 7C 7C B5 LCALL 0x7CB5
7946: 20       POP   X
(0217) 		data[j&0x3F] = FlashCheckSum(j);		// data[i%64] <- CheckSum of i-th block
(0218)     }
(0219) 
(0220)     fwStruct.wARG_BlockId = BlockID;         // Block ID
(0221)     fwStruct.pARG_FlashBuffer = data;  	// Data start Address
7947: 56 0B 00 MOV   [X+11],0
(0222)     fwStruct.cARG_Temperature = 25;		// Temperature in Celsius
794A: 7C 7D 1C LCALL 0x7D1C
794D: 62 D0 02 MOV   REG[208],2
7950: 39 00    CMP   A,0
7952: B0 04    JNZ   0x7957
7954: 56 0B 01 MOV   [X+11],1
(0223) 
(0224)     if (BlockID!=463){
7957: 62 D0 02 MOV   REG[208],2
795A: 50 73    MOV   A,115
795C: 10       PUSH  X
795D: 08       PUSH  A
795E: 57 FE    MOV   X,254
7960: 28       ROMX  
7961: 53 B6    MOV   [__r0],A
7963: 18       POP   A
7964: 75       INC   X
7965: 09 00    ADC   A,0
7967: 28       ROMX  
7968: 20       POP   X
7969: 3C B6 00 CMP   [__r0],0
796C: B0 05    JNZ   0x7972
796E: 39 00    CMP   A,0
7970: A0 5D    JZ    0x79CE
(0225)        bFlashWriteBlock(&fwStruct);		// Write Block
7972: 56 19 01 MOV   [X+25],1
7975: 56 18 00 MOV   [X+24],0
7978: 80 33    JMP   0x79AC
(0226)        BlockID=463;
797A: 62 D0 02 MOV   REG[208],2
797D: 52 19    MOV   A,[X+25]
797F: 01 00    ADD   A,0
7981: 53 B5    MOV   [__r1],A
7983: 52 18    MOV   A,[X+24]
7985: 09 72    ADC   A,114
7987: 10       PUSH  X
7988: 58 B5    MOV   X,[__r1]
798A: 28       ROMX  
798B: 20       POP   X
798C: 54 1B    MOV   [X+27],A
(0227)     };
798E: 52 18    MOV   A,[X+24]
7990: 08       PUSH  A
7991: 52 19    MOV   A,[X+25]
7993: 08       PUSH  A
7994: 7C 7D 43 LCALL 0x7D43
7997: 38 FE    ADD   SP,254
7999: 62 D0 02 MOV   REG[208],2
799C: 53 B6    MOV   [__r0],A
799E: 52 1B    MOV   A,[X+27]
79A0: 3A B6    CMP   A,[__r0]
79A2: A0 04    JZ    0x79A7
79A4: 56 0B 01 MOV   [X+11],1
79A7: 77 19    INC   [X+25]
79A9: 0F 18 00 ADC   [X+24],0
79AC: 62 D0 02 MOV   REG[208],2
79AF: 50 73    MOV   A,115
79B1: 10       PUSH  X
79B2: 08       PUSH  A
79B3: 57 FE    MOV   X,254
79B5: 28       ROMX  
79B6: 53 B6    MOV   [__r0],A
79B8: 18       POP   A
79B9: 75       INC   X
79BA: 09 00    ADC   A,0
79BC: 28       ROMX  
79BD: 20       POP   X
79BE: 13 19    SUB   A,[X+25]
79C0: 52 18    MOV   A,[X+24]
79C2: 31 80    XOR   A,128
79C4: 53 AC    MOV   [__rX],A
79C6: 51 B6    MOV   A,[__r0]
79C8: 31 80    XOR   A,128
79CA: 1A AC    SBB   A,[__rX]
79CC: DF AD    JNC   0x797A
(0228) 
(0229)     data[62]=(char)(LastBlock_To_Check>>8);	// Save last block to check (MSB)
(0230)     data[63]=(char)LastBlock_To_Check;		// Save last block to check (LSB)
79CE: 3D 0B 00 CMP   [X+11],0
79D1: B0 04    JNZ   0x79D6
79D3: 7D 00 A6 LJMP  0x00A6
(0231) 
(0232)     fwStruct.wARG_BlockId = BlockID;         // Block ID
(0233)     fwStruct.pARG_FlashBuffer = data;  	// Data start Address
(0234)     fwStruct.cARG_Temperature = 25;		// Temperature in Celsius
79D6: 56 0B 01 MOV   [X+11],1
79D9: 80 DB    JMP   0x7AB5
(0235)     bFlashWriteBlock(&fwStruct);		// Write Block
(0236) }
(0237) 
79DB: 56 0B 00 MOV   [X+11],0
(0238) void BootLoader(){
79DE: 56 00 00 MOV   [X+0],0
79E1: 80 56    JMP   0x7A38
(0239) //    long int x;
79E3: 9A D4    CALL  _Boot_UART_cGetChar
79E5: 62 D0 02 MOV   REG[208],2
79E8: 53 B6    MOV   [__r0],A
79EA: 55 B4 07 MOV   [__r2],7
79ED: 5A B3    MOV   [__r3],X
79EF: 06 B3 01 ADD   [__r3],1
79F2: 52 00    MOV   A,[X+0]
79F4: 02 B3    ADD   A,[__r3]
79F6: 53 B3    MOV   [__r3],A
79F8: 50 00    MOV   A,0
79FA: 0A B4    ADC   A,[__r2]
79FC: 60 D5    MOV   REG[213],A
79FE: 51 B6    MOV   A,[__r0]
7A00: 3F B3    MVI   [__r3],A
(0240) //    char z;
7A02: 55 B6 07 MOV   [__r0],7
7A05: 5A B5    MOV   [__r1],X
7A07: 06 B5 10 ADD   [__r1],16
7A0A: 52 00    MOV   A,[X+0]
7A0C: 02 B5    ADD   A,[__r1]
7A0E: 53 B5    MOV   [__r1],A
7A10: 50 00    MOV   A,0
7A12: 0A B6    ADC   A,[__r0]
7A14: 60 D4    MOV   REG[212],A
7A16: 3E B5    MVI   A,[__r1]
7A18: 53 B6    MOV   [__r0],A
7A1A: 5A B3    MOV   [__r3],X
7A1C: 06 B3 01 ADD   [__r3],1
7A1F: 52 00    MOV   A,[X+0]
7A21: 02 B3    ADD   A,[__r3]
7A23: 53 B3    MOV   [__r3],A
7A25: 50 00    MOV   A,0
7A27: 0A B4    ADC   A,[__r2]
7A29: 60 D4    MOV   REG[212],A
7A2B: 3E B3    MVI   A,[__r3]
7A2D: 3A B6    CMP   A,[__r0]
7A2F: A0 06    JZ    0x7A36
(0241) 	int j;
7A31: 56 0B 01 MOV   [X+11],1
(0242) 	char buffer[10];
7A34: 80 08    JMP   0x7A3D
7A36: 77 00    INC   [X+0]
7A38: 3D 00 07 CMP   [X+0],7
7A3B: CF A7    JC    0x79E3
(0243) 	char Error,i,k;
(0244) 	char CheckSum;
(0245)     char strConnect[8];//={'C','O','N','N','E','C','T','\0'};
7A3D: 3D 0B 00 CMP   [X+11],0
7A40: A0 03    JZ    0x7A44
7A42: 80 72    JMP   0x7AB5
(0246)     char strAnswer[4];//={'O','K','!','\0'};
(0247) 	// Initiate communications Strings:
(0248)     // strConnect[]="CONNECT", // Initiate string form PC
7A44: 62 D0 02 MOV   REG[208],2
7A47: 5A B5    MOV   [__r1],X
7A49: 06 B5 0C ADD   [__r1],12
7A4C: 50 07    MOV   A,7
7A4E: 08       PUSH  A
7A4F: 51 B5    MOV   A,[__r1]
7A51: 08       PUSH  A
7A52: 9A A5    CALL  _Boot_UART_CPutString
7A54: 38 FE    ADD   SP,254
(0249)     // strAnswer[]="OK!";      // Answer to PC
(0250) 	strConnect[0]='C';strConnect[1]='O';strConnect[2]='N';strConnect[3]='N';strConnect[4]='E';
7A56: 56 00 00 MOV   [X+0],0
7A59: 80 56    JMP   0x7AB0
(0251)     strConnect[5]='C';strConnect[6]='T';strConnect[7]=0;
7A5B: 9A 5C    CALL  _Boot_UART_cGetChar
7A5D: 62 D0 02 MOV   REG[208],2
7A60: 53 B6    MOV   [__r0],A
7A62: 55 B4 07 MOV   [__r2],7
7A65: 5A B3    MOV   [__r3],X
7A67: 06 B3 01 ADD   [__r3],1
7A6A: 52 00    MOV   A,[X+0]
7A6C: 02 B3    ADD   A,[__r3]
7A6E: 53 B3    MOV   [__r3],A
7A70: 50 00    MOV   A,0
7A72: 0A B4    ADC   A,[__r2]
7A74: 60 D5    MOV   REG[213],A
7A76: 51 B6    MOV   A,[__r0]
7A78: 3F B3    MVI   [__r3],A
(0252) 	strAnswer[0]='O';strAnswer[1]='K';strAnswer[2]='!';strAnswer[3]=0;
7A7A: 55 B6 07 MOV   [__r0],7
7A7D: 5A B5    MOV   [__r1],X
7A7F: 06 B5 0C ADD   [__r1],12
7A82: 52 00    MOV   A,[X+0]
7A84: 02 B5    ADD   A,[__r1]
7A86: 53 B5    MOV   [__r1],A
7A88: 50 00    MOV   A,0
7A8A: 0A B6    ADC   A,[__r0]
7A8C: 60 D4    MOV   REG[212],A
7A8E: 3E B5    MVI   A,[__r1]
7A90: 53 B6    MOV   [__r0],A
7A92: 5A B3    MOV   [__r3],X
7A94: 06 B3 01 ADD   [__r3],1
7A97: 52 00    MOV   A,[X+0]
7A99: 02 B3    ADD   A,[__r3]
7A9B: 53 B3    MOV   [__r3],A
7A9D: 50 00    MOV   A,0
7A9F: 0A B4    ADC   A,[__r2]
7AA1: 60 D4    MOV   REG[212],A
7AA3: 3E B3    MVI   A,[__r3]
7AA5: 3A B6    CMP   A,[__r0]
7AA7: A0 06    JZ    0x7AAE
(0253) 
7AA9: 56 0B 01 MOV   [X+11],1
(0254)  	// Initiate UART Module
7AAC: 80 08    JMP   0x7AB5
7AAE: 77 00    INC   [X+0]
7AB0: 3D 00 03 CMP   [X+0],3
7AB3: CF A7    JC    0x7A5B
7AB5: 3D 0B 00 CMP   [X+11],0
7AB8: BF 22    JNZ   0x79DB
(0255) 	Boot_RxD_Start(RX8_PARITY_NONE);
(0256) 	Boot_TxD_Start(TX8_PARITY_NONE);
(0257) 
(0258) #if ENABLE_CONNECT_BY_PSOC
(0259) 	// Check conditions for remote programming only through UART
(0260) 	// if was Power On Reset then check this
7ABA: 9A 6B    CALL  _Boot_PerformWrite
(0261) 	//
(0262) 	if (CPU_SCR0 & CPU_SCR0_PORS_MASK){
7AC3: 7C 7B 23 LCALL 0x7B23

FILE: .\bootloaderconfig.asm
7AC6: 7C 7A CA LCALL 0x7ACA        (0078) include "m8c.inc"
                                   (0079) include "memory.inc"
                                   (0080) include "bootloader.inc"
7AC9: 7F       RET                 (0081) 
                                   (0082) Area BootLoaderArea(ROM,REL)
                                   (0083) 
                                   (0084) ;-----------------------------------------------
                                   (0085) ;  Global Symbols
                                   (0086) ;-----------------------------------------------
                                   (0087) export   Boot_RxD_Start
                                   (0088) export  _Boot_RxD_Start
                                   (0089) export   Boot_RxD_bReadRxData
                                   (0090) export  _Boot_RxD_bReadRxData
                                   (0091) export   Boot_RxD_bReadRxStatus
                                   (0092) export  _Boot_RxD_bReadRxStatus
                                   (0093) 
                                   (0094) export   Boot_TxD_Start
                                   (0095) export  _Boot_TxD_Start
                                   (0096) export   Boot_TxD_SendData
                                   (0097) export  _Boot_TxD_SendData
                                   (0098) export   Boot_TxD_bReadTxStatus
                                   (0099) export  _Boot_TxD_bReadTxStatus
                                   (0100) 
                                   (0101) export  Boot_Counter_DisableInt
                                   (0102) export _Boot_Counter_DisableInt
                                   (0103) export  Boot_Counter_Start
                                   (0104) export _Boot_Counter_Start
                                   (0105) export  Boot_Counter_Stop
7ACA: 10       PUSH  X             (0106) export _Boot_Counter_Stop
7ACB: 70 EF    AND   F,239         (0107) export  Boot_Counter_WritePeriod
7ACD: 50 00    MOV   A,0           (0108) export _Boot_Counter_WritePeriod
7ACF: 67       ASR   A             (0109) export  Boot_Counter_WriteCompareValue
                                   (0110) export _Boot_Counter_WriteCompareValue
7AD0: 50 7C    MOV   A,124         (0111) export  Boot_Counter_wReadCounter
7AD2: 57 0C    MOV   X,12          (0112) export _Boot_Counter_wReadCounter
7AD4: 7C 7A E3 LCALL 0x7AE3        (0113) 
                                   (0114) 
7AD7: 50 01    MOV   A,1           (0115) 
7AD9: 67       ASR   A             (0116) 
                                   (0117) //---------------------------------------------------------------------------------
7ADA: 50 7C    MOV   A,124         (0118) // Configuration
7ADC: 57 73    MOV   X,115         (0119) //---------------------------------------------------------------------------------
7ADE: 7C 7A E3 LCALL 0x7AE3        (0120) 
                                   (0121) export Boot_LoadConfigInit
7AE1: 20       POP   X             (0122) export _Boot_LoadConfigInit
                                   (0123) 
                                   (0124) //export NO_SHADOW
7AE2: 7F       RET                 (0125) //export _NO_SHADOW
                                   (0126) 
                                   (0127) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                   (0128) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0129) 
                                   (0130) Area BootLoaderArea(ROM,REL)
                                   (0131) 
                                   (0132) ;---------------------------------------------------------------------------
                                   (0133) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                   (0134) ;                  parameters handled by boot code, like CPU speed). This
                                   (0135) ;                  function can be called from user code, but typically it
                                   (0136) ;                  is only called from boot.
                                   (0137) ;
                                   (0138) ;       INPUTS: None.
                                   (0139) ;      RETURNS: Nothing.
                                   (0140) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                   (0141) ;               In the large memory model currently only the page
                                   (0142) ;               pointer registers listed below are modified.  This does
                                   (0143) ;               not guarantee that in future implementations of this
                                   (0144) ;               function other page pointer registers will not be
                                   (0145) ;               modified.
                                   (0146) ;          
7AE3: 38 02    ADD   SP,2          (0147) ;               Page Pointer Registers Modified: 
7AE5: 10       PUSH  X             (0148) ;               CUR_PP
7AE6: 08       PUSH  A             (0149) ;
7AE7: 4F       MOV   X,SP          (0150) _Boot_LoadConfigInit:
7AE8: 56 FC 00 MOV   [X-4],0       (0151)  Boot_LoadConfigInit:
7AEB: D0 04    JNC   0x7AF0        (0152)     RAM_PROLOGUE RAM_USE_CLASS_4
7AED: 56 FC 01 MOV   [X-4],1       (0153)     
                                   (0154) 	lcall	LoadConfigTBL_bootloader_cy8c29_Ordered
7AF0: 18       POP   A             (0155) 	lcall	LoadConfig_bootloader_cy8c29
7AF1: 20       POP   X             (0156) 
                                   (0157)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0158)     ret
7AF2: 70 EF    AND   F,239         (0159) 
7AF4: 62 E3 00 MOV   REG[227],0    (0160) ;---------------------------------------------------------------------------
7AF7: 10       PUSH  X             (0161) ; Load Configuration bootloader_cy8c29
7AF8: 08       PUSH  A             (0162) ;
7AF9: 28       ROMX                (0163) ;    Load configuration registers for bootloader_cy8c29.
7AFA: 39 FF    CMP   A,255         (0164) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
7AFC: A0 1F    JZ    0x7B1C        (0165) ;
7AFE: 4F       MOV   X,SP          (0166) ;       INPUTS: None.
7AFF: 48 FC 01 TST   [X-4],1       (0167) ;      RETURNS: Nothing.
7B02: A0 03    JZ    0x7B06        (0168) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
7B04: 71 10    OR    F,16          (0169) ;               modified as may the Page Pointer registers!
                                   (0170) ;               In the large memory model currently only the page
7B06: 54 FD    MOV   [X-3],A       (0171) ;               pointer registers listed below are modified.  This does
7B08: 18       POP   A             (0172) ;               not guarantee that in future implementations of this
7B09: 20       POP   X             (0173) ;               function other page pointer registers will not be
7B0A: 75       INC   X             (0174) ;               modified.
7B0B: 09 00    ADC   A,0           (0175) ;          
7B0D: 10       PUSH  X             (0176) ;               Page Pointer Registers Modified: 
7B0E: 08       PUSH  A             (0177) ;               CUR_PP
7B0F: 28       ROMX                (0178) ;
7B10: 4F       MOV   X,SP          (0179) _LoadConfig_bootloader_cy8c29:
7B11: 59 FD    MOV   X,[X-3]       (0180)  LoadConfig_bootloader_cy8c29:
7B13: 61 00    MOV   REG[X+0],A    (0181)     RAM_PROLOGUE RAM_USE_CLASS_4
7B15: 18       POP   A             (0182) 
7B16: 20       POP   X             (0183) 	push	x
7B17: 75       INC   X             (0184)     M8C_SetBank0                    ; Force bank 0
7B18: 09 00    ADC   A,0           (0185)     mov     a, 0                    ; Specify bank 0
7B1A: 8F D7    JMP   0x7AF2        (0186)     asr     a                       ; Store in carry flag
                                   (0187)                                     ; Load bank 0 table:
7B1C: 38 FC    ADD   SP,252        (0188)     mov     A, >LoadConfigTBL_bootloader_cy8c29_Bank0
7B1E: 70 3F    AND   F,63
7B20: 71 C0    OR    F,192         (0189)     mov     X, <LoadConfigTBL_bootloader_cy8c29_Bank0
7B22: 7F       RET                 (0190)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0191) 
                                   (0192)     mov     a, 1                    ; Specify bank 1
                                   (0193)     asr     a                       ; Store in carry flag
7B23: 71 10    OR    F,16          (0194)                                     ; Load bank 1 table:
7B25: 62 00 10 MOV   REG[0],16     (0195)     mov     A, >LoadConfigTBL_bootloader_cy8c29_Bank1
7B28: 62 01 EF MOV   REG[1],239    (0196)     mov     X, <LoadConfigTBL_bootloader_cy8c29_Bank1
7B2B: 70 EF    AND   F,239         (0197)     lcall   LoadConfig              ; Load the bank 1 values
7B2D: 62 03 EF MOV   REG[3],239    (0198) 
7B30: 62 02 10 MOV   REG[2],16     (0199) 	pop		x
7B33: 71 10    OR    F,16          (0200) 
7B35: 62 02 00 MOV   REG[2],0      (0201)     RAM_EPILOGUE RAM_USE_CLASS_4
7B38: 62 03 00 MOV   REG[3],0      (0202)     ret
7B3B: 70 EF    AND   F,239         (0203) 
7B3D: 62 01 00 MOV   REG[1],0      (0204) 
7B40: 71 10    OR    F,16          (0205) 
7B42: 62 04 00 MOV   REG[4],0      (0206) 
7B45: 62 05 FF MOV   REG[5],255    (0207) ;---------------------------------------------------------------------------
7B48: 70 EF    AND   F,239         (0208) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
7B4A: 62 07 F7 MOV   REG[7],247    (0209) ;              pairs. Terminate on address=0xFF.
7B4D: 62 06 08 MOV   REG[6],8      (0210) ;
7B50: 71 10    OR    F,16          (0211) ;  INPUTS:  [A,X] points to the table to be loaded
7B52: 62 06 00 MOV   REG[6],0      (0212) ;           Flag Register Carry bit encodes the Register Bank
7B55: 62 07 00 MOV   REG[7],0      (0213) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
7B58: 70 EF    AND   F,239         (0214) ;
7B5A: 62 05 00 MOV   REG[5],0      (0215) ;  RETURNS: nothing.
7B5D: 71 10    OR    F,16          (0216) ;
7B5F: 62 08 00 MOV   REG[8],0      (0217) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
7B62: 62 09 FF MOV   REG[9],255    (0218) ;                X-3 Temporary store for register address
7B65: 70 EF    AND   F,239         (0219) ;                X-2 LSB of config table address
7B67: 62 0B FF MOV   REG[11],255   (0220) ;                X-1 MSB of config table address
7B6A: 62 0A 00 MOV   REG[10],0     (0221) ;
7B6D: 71 10    OR    F,16          (0222) LoadConfig:
7B6F: 62 0A 00 MOV   REG[10],0     (0223)     RAM_PROLOGUE RAM_USE_CLASS_2
7B72: 62 0B 00 MOV   REG[11],0     (0224)     add     SP, 2                   ; Set up local vars
7B75: 70 EF    AND   F,239         (0225)     push    X                       ; Save config table address on stack
7B77: 62 09 00 MOV   REG[9],0      (0226)     push    A
7B7A: 71 10    OR    F,16          (0227)     mov     X, SP
7B7C: 62 0C 00 MOV   REG[12],0     (0228)     mov     [X-4], 0                ; Set default Destination to Bank 0
7B7F: 62 0D 00 MOV   REG[13],0     (0229)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
7B82: 70 EF    AND   F,239         (0230)     mov     [X-4], 1                ; No Carry: default to Bank 1
7B84: 62 0F 00 MOV   REG[15],0     (0231) .BankSelectSaved:
7B87: 62 0E 00 MOV   REG[14],0     (0232)     pop     A
7B8A: 71 10    OR    F,16          (0233)     pop     X
7B8C: 62 0E 00 MOV   REG[14],0     (0234) 
7B8F: 62 0F 00 MOV   REG[15],0     (0235) LoadConfigLp:
7B92: 70 EF    AND   F,239         (0236)     M8C_SetBank0                    ; Switch to bank 0
7B94: 62 0D 00 MOV   REG[13],0     (0237)     M8C_ClearWDT                    ; Clear the watchdog for long inits
7B97: 71 10    OR    F,16          (0238)     push    X                       ; Preserve the config table address
7B99: 62 10 00 MOV   REG[16],0     (0239)     push    A
7B9C: 62 11 00 MOV   REG[17],0     (0240)     romx                            ; Load register address from table
7B9F: 70 EF    AND   F,239         (0241)     cmp     A, END_CONFIG_TABLE     ; End of table?
7BA1: 62 13 00 MOV   REG[19],0     (0242)     jz      EndLoadConfig           ;   Yes, go wrap it up
7BA4: 62 12 00 MOV   REG[18],0     (0243)     mov     X, SP                   ;
7BA7: 71 10    OR    F,16          (0244)     tst     [X-4], 1                ; Loading IO Bank 1?
7BA9: 62 12 00 MOV   REG[18],0     (0245)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
7BAC: 62 13 00 MOV   REG[19],0     (0246)     M8C_SetBank1                    ;   Yes, switch to Bank 1
7BAF: 70 EF    AND   F,239         (0247) .IOBankNowSet:
7BB1: 62 11 00 MOV   REG[17],0     (0248)     mov     [X-3], A                ; Stash the register address
7BB4: 71 10    OR    F,16          (0249)     pop     A                       ; Retrieve the table address
7BB6: 62 14 00 MOV   REG[20],0     (0250)     pop     X
7BB9: 62 15 00 MOV   REG[21],0     (0251)     inc     X                       ; Advance to the data byte
7BBC: 70 EF    AND   F,239         (0252)     adc     A, 0
7BBE: 62 17 00 MOV   REG[23],0     (0253)     push    X                       ; Save the config table address again
7BC1: 62 16 00 MOV   REG[22],0     (0254)     push    A
7BC4: 71 10    OR    F,16          (0255)     romx                            ; load config data from the table
7BC6: 62 16 00 MOV   REG[22],0     (0256)     mov     X, SP                   ; retrieve the register address
7BC9: 62 17 00 MOV   REG[23],0     (0257)     mov     X, [X-3]
7BCC: 70 EF    AND   F,239         (0258)     mov     reg[X], A               ; Configure the register
7BCE: 62 15 00 MOV   REG[21],0     (0259)     pop     A                       ; retrieve the table address
7BD1: 71 10    OR    F,16          (0260)     pop     X
7BD3: 62 18 00 MOV   REG[24],0     (0261)     inc     X                       ; advance to next table entry
7BD6: 62 19 00 MOV   REG[25],0     (0262)     adc     A, 0
7BD9: 70 EF    AND   F,239         (0263)     jmp     LoadConfigLp            ; loop to configure another register
7BDB: 62 1B 00 MOV   REG[27],0     (0264) EndLoadConfig:
7BDE: 62 1A 00 MOV   REG[26],0     (0265)     add     SP, -4
7BE1: 71 10    OR    F,16          (0266)     RAM_EPILOGUE RAM_USE_CLASS_2
7BE3: 62 1A 00 MOV   REG[26],0     (0267)     ret
7BE6: 62 1B 00 MOV   REG[27],0     (0268) 
7BE9: 70 EF    AND   F,239         (0269) LoadConfigTBL_bootloader_cy8c29_Ordered:
7BEB: 62 19 00 MOV   REG[25],0     (0270) ;  Ordered Global Register values
7BEE: 71 10    OR    F,16          (0271) 	M8C_SetBank1
7BF0: 62 1C 00 MOV   REG[28],0     (0272) 	mov	reg[00h], 10h		; Port_0_DriveMode_0 register (PRT0DM0)
7BF3: 62 1D 00 MOV   REG[29],0     (0273) 	mov	reg[01h], efh		; Port_0_DriveMode_1 register (PRT0DM1)
7BF6: 70 EF    AND   F,239         (0274) 	M8C_SetBank0
7BF8: 62 1F 00 MOV   REG[31],0     (0275) 	mov	reg[03h], efh		; Port_0_DriveMode_2 register (PRT0DM2)
7BFB: 62 1E 00 MOV   REG[30],0     (0276) 	mov	reg[02h], 10h		; Port_0_GlobalSelect register (PRT0GS)
7BFE: 71 10    OR    F,16          (0277) 	M8C_SetBank1
7C00: 62 1E 00 MOV   REG[30],0     (0278) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
7C03: 62 1F 00 MOV   REG[31],0     (0279) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
7C06: 70 EF    AND   F,239         (0280) 	M8C_SetBank0
7C08: 62 1D 00 MOV   REG[29],0     (0281) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
7C0B: 7F       RET                 (0282) 	M8C_SetBank1
7C0C: 23 00    AND   A,[X+0]
7C0E: 21 00    AND   A,0
7C10: 22 00    AND   A,[xCalVr]
7C12: 27 00 25 AND   [X+0],37
7C15: 80 26    JMP   0x7C3C
7C17: 40       NOP   
7C18: 2F 00 2D OR    [X+0],45
7C1B: 00       SWI   
7C1C: 2E 00 2B OR    [xCalVr],43
7C1F: 00       SWI   
7C20: 29 00    OR    A,0
7C22: 2A 00    OR    A,[0]
7C24: 60 28    MOV   REG[40],A
7C26: 66 00    ASL   [X+0]
7C28: 63 05 65 MOV   REG[X+5],101
7C2B: 00       SWI   
7C2C: E6 00    JACC  0x822D
7C2E: E7 00    JACC  0x832F
7C30: D6 00    JNC   0x8231
7C32: B0 90    JNZ   0x7CC3
7C34: B1 00    JNZ   0x7D35
7C36: B2 00    JNZ   0x7E37
7C38: B3 33    JNZ   0x7F6C
7C3A: B4 33    JNZ   0x806E
7C3C: B5 02    JNZ   0x813F
7C3E: B6 00    JNZ   0x823F
7C40: B8 55    JNZ   0x7496
7C42: B9 00    JNZ   0x7543
7C44: BA 10    JNZ   0x7655
7C46: BB 33    JNZ   0x777A
7C48: BC 33    JNZ   0x787C
7C4A: BD 00    JNZ   0x794B
7C4C: BE 00    JNZ   0x7A4D
7C4E: C0 00    JC    0x7C4F
7C50: C1 00    JC    0x7D51
7C52: C2 20    JC    0x7E73
7C54: C3 33    JC    0x7F88
7C56: C4 33    JC    0x808A
7C58: C5 00    JC    0x8159
7C5A: C6 00    JC    0x825B
7C5C: C8 55    JC    0x74B2
7C5E: C9 00    JC    0x755F
7C60: CA 30    JC    0x7691
7C62: CB 33    JC    0x7796
7C64: CC 33    JC    0x7898
7C66: CD 00    JC    0x7967
7C68: CE 00    JC    0x7A69
7C6A: 6C 00    RLC   [X+0]
7C6C: 6D       RRC   A
7C6D: 00       SWI   
7C6E: 6E 00    RRC   [xCalVr]
7C70: 6F 00    RRC   [X+0]
7C72: FF 20    INDEX 0x7B94
7C74: 11 21    SUB   A,33
7C76: 17 22 40 SUB   [X+34],64
7C79: 24 31    AND   [49],A
7C7B: 25 37    AND   [X+55],A
7C7D: 26 40 2C AND   [64],44
7C80: 05 2D    ADD   [X+45],A
7C82: F1 2E    INDEX 0x7DB2
7C84: 40       NOP   
7C85: 28       ROMX  
7C86: 1D 29    SBB   [X+41],A
7C88: 01 2A    ADD   A,42
7C8A: 44 61 00 OR    REG[X+97],0
7C8D: 69 00    ASR   [X+0]
7C8F: 60 00    MOV   REG[0],A
7C91: 62 00 67 MOV   REG[0],103
7C94: 33 68    XOR   A,[X+104]
7C96: 33 63    XOR   A,[X+99]
7C98: 00       SWI   
7C99: 66 00    ASL   [X+0]
7C9B: D1 00    JNC   0x7D9C
7C9D: D3 00    JNC   0x7F9E
7C9F: D0 00    JNC   0x7CA0
7CA1: D2 00    JNC   0x7EA2
7CA3: E1 00    JACC  0x7DA4
7CA5: E2 00    JACC  0x7EA6
7CA7: DF 19    JNC   0x7BC1
7CA9: DE 00    JNC   0x7AAA
7CAB: DD 00    JNC   0x79AC
7CAD: E7 00    JACC  0x83AE
7CAF: FF 29    INDEX 0x7BDA
                                   (0283) 	mov	reg[04h], 00h		; Port_1_DriveMode_0 register (PRT1DM0)
                                   (0284) 	mov	reg[05h], ffh		; Port_1_DriveMode_1 register (PRT1DM1)
                                   (0285) 	M8C_SetBank0
                                   (0286) 	mov	reg[07h], f7h		; Port_1_DriveMode_2 register (PRT1DM2)
                                   (0287) 	mov	reg[06h], 08h		; Port_1_GlobalSelect register (PRT1GS)
                                   (0288) 	M8C_SetBank1
                                   (0289) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
                                   (0290) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
                                   (0291) 	M8C_SetBank0
                                   (0292) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
                                   (0293) 	M8C_SetBank1
                                   (0294) 	mov	reg[08h], 00h		; Port_2_DriveMode_0 register (PRT2DM0)
                                   (0295) 	mov	reg[09h], ffh		; Port_2_DriveMode_1 register (PRT2DM1)
                                   (0296) 	M8C_SetBank0
                                   (0297) 	mov	reg[0bh], ffh		; Port_2_DriveMode_2 register (PRT2DM2)
                                   (0298) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
                                   (0299) 	M8C_SetBank1
                                   (0300) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
                                   (0301) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
                                   (0302) 	M8C_SetBank0
                                   (0303) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
                                   (0304) 	M8C_SetBank1
                                   (0305) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
                                   (0306) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
                                   (0307) 	M8C_SetBank0
                                   (0308) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
                                   (0309) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
                                   (0310) 	M8C_SetBank1
                                   (0311) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
                                   (0312) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
                                   (0313) 	M8C_SetBank0
                                   (0314) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
                                   (0315) 	M8C_SetBank1
                                   (0316) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
                                   (0317) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
                                   (0318) 	M8C_SetBank0
                                   (0319) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
                                   (0320) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
                                   (0321) 	M8C_SetBank1
                                   (0322) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
                                   (0323) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
                                   (0324) 	M8C_SetBank0
                                   (0325) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
                                   (0326) 	M8C_SetBank1
                                   (0327) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
                                   (0328) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
                                   (0329) 	M8C_SetBank0
                                   (0330) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
                                   (0331) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
                                   (0332) 	M8C_SetBank1
                                   (0333) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
                                   (0334) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
                                   (0335) 	M8C_SetBank0
                                   (0336) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
                                   (0337) 	M8C_SetBank1
                                   (0338) 	mov	reg[18h], 00h		; Port_6_DriveMode_0 register (PRT6DM0)
                                   (0339) 	mov	reg[19h], 00h		; Port_6_DriveMode_1 register (PRT6DM1)
                                   (0340) 	M8C_SetBank0
                                   (0341) 	mov	reg[1bh], 00h		; Port_6_DriveMode_2 register (PRT6DM2)
                                   (0342) 	mov	reg[1ah], 00h		; Port_6_GlobalSelect register (PRT6GS)
                                   (0343) 	M8C_SetBank1
                                   (0344) 	mov	reg[1ah], 00h		; Port_6_IntCtrl_0 register (PRT6IC0)
                                   (0345) 	mov	reg[1bh], 00h		; Port_6_IntCtrl_1 register (PRT6IC1)
                                   (0346) 	M8C_SetBank0
                                   (0347) 	mov	reg[19h], 00h		; Port_6_IntEn register (PRT6IE)
                                   (0348) 	M8C_SetBank1
                                   (0349) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
                                   (0350) 	mov	reg[1dh], 00h		; Port_7_DriveMode_1 register (PRT7DM1)
                                   (0351) 	M8C_SetBank0
                                   (0352) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
                                   (0353) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
                                   (0354) 	M8C_SetBank1
                                   (0355) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
                                   (0356) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
                                   (0357) 	M8C_SetBank0
                                   (0358) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
                                   (0359) 	ret
                                   (0360) LoadConfigTBL_bootloader_cy8c29_Bank0:
                                   (0361) ;  Instance name Boot_Counter, User Module Counter16
                                   (0362) ;       Instance name Boot_Counter, Block Name CNTR16_LSB(DBB00)
                                   (0363) 	db		23h, 00h		;Boot_Counter_CONTROL_LSB_REG(DBB00CR0)
                                   (0364) 	db		21h, 00h		;Boot_Counter_PERIOD_LSB_REG(DBB00DR1)
                                   (0365) 	db		22h, 00h		;Boot_Counter_COMPARE_LSB_REG(DBB00DR2)
                                   (0366) ;       Instance name Boot_Counter, Block Name CNTR16_MSB(DBB01)
                                   (0367) 	db		27h, 00h		;Boot_Counter_CONTROL_MSB_REG(DBB01CR0)
                                   (0368) 	db		25h, 80h		;Boot_Counter_PERIOD_MSB_REG(DBB01DR1)
                                   (0369) 	db		26h, 40h		;Boot_Counter_COMPARE_MSB_REG(DBB01DR2)
                                   (0370) ;  Instance name Boot_RxD, User Module RX8
                                   (0371) ;       Instance name Boot_RxD, Block Name RX8(DCB03)
                                   (0372) 	db		2fh, 00h		;Boot_RxD_CONTROL_REG  (DCB03CR0)
                                   (0373) 	db		2dh, 00h		;Boot_RxD_(DCB03DR1)
                                   (0374) 	db		2eh, 00h		;Boot_RxD_RX_BUFFER_REG(DCB03DR2)
                                   (0375) ;  Instance name Boot_TxD, User Module TX8
                                   (0376) ;       Instance name Boot_TxD, Block Name TX8(DCB02)
                                   (0377) 	db		2bh, 00h		;Boot_TxD_CONTROL_REG  (DCB02CR0)
                                   (0378) 	db		29h, 00h		;Boot_TxD_TX_BUFFER_REG(DCB02DR1)
                                   (0379) 	db		2ah, 00h		;Boot_TxD_(DCB02DR2)
                                   (0380) ;  Global Register values Bank 0
                                   (0381) 	db		60h, 28h		; AnalogColumnInputSelect register (AMX_IN)
                                   (0382) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                   (0383) 	db		63h, 05h		; AnalogReferenceControl register (ARF_CR)
                                   (0384) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
                                   (0385) 	db		e6h, 00h		; DecimatorControl_0 register (DEC_CR0)
                                   (0386) 	db		e7h, 00h		; DecimatorControl_1 register (DEC_CR1)
                                   (0387) 	db		d6h, 00h		; I2CConfig register (I2C_CFG)
                                   (0388) 	db		b0h, 90h		; Row_0_InputMux register (RDI0RI)
                                   (0389) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
                                   (0390) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                   (0391) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                   (0392) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                   (0393) 	db		b5h, 02h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                   (0394) 	db		b6h, 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                   (0395) 	db		b8h, 55h		; Row_1_InputMux register (RDI1RI)
                                   (0396) 	db		b9h, 00h		; Row_1_InputSync register (RDI1SYN)
                                   (0397) 	db		bah, 10h		; Row_1_LogicInputAMux register (RDI1IS)
                                   (0398) 	db		bbh, 33h		; Row_1_LogicSelect_0 register (RDI1LT0)
                                   (0399) 	db		bch, 33h		; Row_1_LogicSelect_1 register (RDI1LT1)
                                   (0400) 	db		bdh, 00h		; Row_1_OutputDrive_0 register (RDI1SRO0)
                                   (0401) 	db		beh, 00h		; Row_1_OutputDrive_1 register (RDI1SRO1)
                                   (0402) 	db		c0h, 00h		; Row_2_InputMux register (RDI2RI)
                                   (0403) 	db		c1h, 00h		; Row_2_InputSync register (RDI2SYN)
                                   (0404) 	db		c2h, 20h		; Row_2_LogicInputAMux register (RDI2IS)
                                   (0405) 	db		c3h, 33h		; Row_2_LogicSelect_0 register (RDI2LT0)
                                   (0406) 	db		c4h, 33h		; Row_2_LogicSelect_1 register (RDI3LT1)
                                   (0407) 	db		c5h, 00h		; Row_2_OutputDrive_0 register (RDI2SRO0)
                                   (0408) 	db		c6h, 00h		; Row_2_OutputDrive_1 register (RDI2SRO1)
                                   (0409) 	db		c8h, 55h		; Row_3_InputMux register (RDI3RI)
                                   (0410) 	db		c9h, 00h		; Row_3_InputSync register (RDI3SYN)
                                   (0411) 	db		cah, 30h		; Row_3_LogicInputAMux register (RDI3IS)
                                   (0412) 	db		cbh, 33h		; Row_3_LogicSelect_0 register (RDI3LT0)
                                   (0413) 	db		cch, 33h		; Row_3_LogicSelect_1 register (RDI3LT1)
                                   (0414) 	db		cdh, 00h		; Row_3_OutputDrive_0 register (RDI3SRO0)
                                   (0415) 	db		ceh, 00h		; Row_3_OutputDrive_1 register (RDI3SRO1)
                                   (0416) 	db		6ch, 00h		; TMP_DR0 register (TMP_DR0)
                                   (0417) 	db		6dh, 00h		; TMP_DR1 register (TMP_DR1)
                                   (0418) 	db		6eh, 00h		; TMP_DR2 register (TMP_DR2)
                                   (0419) 	db		6fh, 00h		; TMP_DR3 register (TMP_DR3)
                                   (0420) 	db		ffh
                                   (0421) 
                                   (0422) LoadConfigTBL_bootloader_cy8c29_Bank1:
                                   (0423) ;  Instance name Boot_Counter, User Module Counter16
                                   (0424) ;       Instance name Boot_Counter, Block Name CNTR16_LSB(DBB00)
                                   (0425) 	db		20h, 11h		;Boot_Counter_FUNC_LSB_REG(DBB00FN)
                                   (0426) 	db		21h, 17h		;Boot_Counter_INPUT_LSB_REG(DBB00IN)
7CB1: 01 60    ADD   A,96          (0427) 	db		22h, 40h		;Boot_Counter_OUTPUT_LSB_REG(DBB00OU)
7CB3: 2F 7F 41 OR    [X+127],65    (0428) ;       Instance name Boot_Counter, Block Name CNTR16_MSB(DBB01)
                                   (0429) 	db		24h, 31h		;Boot_Counter_FUNC_MSB_REG(DBB01FN)
7CB6: 23 FE    AND   A,[X-2]       (0430) 	db		25h, 37h		;Boot_Counter_INPUT_MSB_REG(DBB01IN)
                                   (0431) 	db		26h, 40h		;Boot_Counter_OUTPUT_MSB_REG(DBB01OU)
                                   (0432) ;  Instance name Boot_RxD, User Module RX8
                                   (0433) ;       Instance name Boot_RxD, Block Name RX8(DCB03)
                                   (0434) 	db		2ch, 05h		;Boot_RxD_FUNC_REG     (DCB03FN)
                                   (0435) 	db		2dh, f1h		;Boot_RxD_INPUT_REG    (DCB03IN)
                                   (0436) 	db		2eh, 40h		;Boot_RxD_OUTPUT_REG   (DCB03OU)
                                   (0437) ;  Instance name Boot_TxD, User Module TX8
                                   (0438) ;       Instance name Boot_TxD, Block Name TX8(DCB02)
                                   (0439) 	db		28h, 1dh		;Boot_TxD_FUNC_REG     (DCB02FN)
                                   (0440) 	db		29h, 01h		;Boot_TxD_INPUT_REG    (DCB02IN)
                                   (0441) 	db		2ah, 44h		;Boot_TxD_OUTPUT_REG   (DCB02OU)
                                   (0442) ;  Global Register values Bank 1
                                   (0443) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                   (0444) 	db		69h, 00h		; AnalogClockSelect2 register (CLK_CR2)
                                   (0445) 	db		60h, 00h		; AnalogColumnClockSelect register (CLK_CR0)
                                   (0446) 	db		62h, 00h		; AnalogIOControl_0 register (ABF_CR0)
                                   (0447) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                   (0448) 	db		68h, 33h		; AnalogLUTControl1 register (ALT_CR1)
                                   (0449) 	db		63h, 00h		; AnalogModulatorControl_0 register (AMD_CR0)
                                   (0450) 	db		66h, 00h		; AnalogModulatorControl_1 register (AMD_CR1)
                                   (0451) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                   (0452) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                   (0453) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                   (0454) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                   (0455) 	db		e1h, 00h		; OscillatorControl_1 register (OSC_CR1)
7CB8: 7F       RET                 (0456) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                   (0457) 	db		dfh, 19h		; OscillatorControl_3 register (OSC_CR3)
                                   (0458) 	db		deh, 00h		; OscillatorControl_4 register (OSC_CR4)
                                   (0459) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                   (0460) 	db		e7h, 00h		; Type2Decimator_Control register (DEC_CR2)
                                   (0461) 	db		ffh
                                   (0462) 
                                   (0463) ; PSoC Configuration file trailer PsocConfig.asm
                                   (0464) 
                                   (0465) 
                                   (0466) 
                                   (0467) 
                                   (0468) 
                                   (0469) 
                                   (0470) 
                                   (0471) 
                                   (0472) ;-----------------------------------------------
                                   (0473) ;  EQUATES
                                   (0474) ;-----------------------------------------------
                                   (0475) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0476) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0477) INPUT_REG_NULL:                equ 0x00    ; Clear the input register		
                                   (0478) 
                                   (0479) .SECTION
                                   (0480) ;-----------------------------------------------------------------------------
                                   (0481) ;  FUNCTION NAME: Boot_RxD_Start(BYTE bParity)
                                   (0482) ;
                                   (0483) ;  DESCRIPTION:
                                   (0484) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0485) ;
                                   (0486) ;-----------------------------------------------------------------------------
                                   (0487) ;
                                   (0488) ;  ARGUMENTS:
7CB9: 5D 2E    MOV   A,REG[46]     (0489) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0490) ;    passed in A register.
7CBB: 7F       RET                 (0491) ;
                                   (0492) ;  RETURNS: none
                                   (0493) ;
                                   (0494) ;  SIDE EFFECTS:
                                   (0495) ;    The A and X registers may be modified by this or future implementations
                                   (0496) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0497) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0498) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0499) ;    functions.
                                   (0500) ;
                                   (0501)  Boot_RxD_Start:
                                   (0502) _Boot_RxD_Start:
                                   (0503)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0504)    or    A, bfCONTROL_REG_START_BIT
                                   (0505)    mov   REG[Boot_RxD_CONTROL_REG], A
                                   (0506)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0507)    ret
                                   (0508) .ENDSECTION
                                   (0509) 
                                   (0510) .SECTION
                                   (0511) ;-----------------------------------------------------------------------------
                                   (0512) ;  FUNCTION NAME: Boot_Counter_Stop
                                   (0513) ;
                                   (0514) ;  DESCRIPTION:
                                   (0515) ;     Disables counter operation by clearing the start bit in the Control
                                   (0516) ;     register of the LSB block.
                                   (0517) ;-----------------------------------------------------------------------------
                                   (0518) ;
                                   (0519) ;  ARGUMENTS:    None
                                   (0520) ;  RETURNS:      Nothing
7CBC: 5D 2F    MOV   A,REG[47]     (0521) ;  SIDE EFFECTS: 
                                   (0522) ;    The A and X registers may be modified by this or future implementations
7CBE: 7F       RET                 (0523) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0524) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0525) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0526) ;    functions.
                                   (0527) ;
                                   (0528)  Boot_Counter_Stop:
                                   (0529) _Boot_Counter_Stop:
                                   (0530)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0531)    Boot_Counter_Stop_M
                                   (0532)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0533)    ret
                                   (0534) 
                                   (0535) 
                                   (0536) .ENDSECTION
                                   (0537) 
                                   (0538) 
                                   (0539) .SECTION
                                   (0540) ;-----------------------------------------------------------------------------
                                   (0541) ;  FUNCTION NAME: Boot_RxD_bReadRxData
                                   (0542) ;
                                   (0543) ;  DESCRIPTION:
                                   (0544) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0545) ;     sure data is valid.
                                   (0546) ;
                                   (0547) ;-----------------------------------------------------------------------------
                                   (0548) ;
                                   (0549) ;  ARGUMENTS:  none
                                   (0550) ;
                                   (0551) ;  RETURNS:
7CBF: 29 01    OR    A,1           (0552) ;    bRxData - returned in A.
7CC1: 60 2B    MOV   REG[43],A     (0553) ;
                                   (0554) ;  SIDE EFFECTS:
7CC3: 7F       RET                 (0555) ;    The A and X registers may be modified by this or future implementations
                                   (0556) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0557) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0558) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0559) ;    functions.
                                   (0560) ;
                                   (0561)  Boot_RxD_bReadRxData:
                                   (0562) _Boot_RxD_bReadRxData:
                                   (0563)  bBoot_RxD_ReadRxData:
                                   (0564) _bBoot_RxD_ReadRxData:
                                   (0565)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0566)    mov A, REG[Boot_RxD_RX_BUFFER_REG]
                                   (0567)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0568)    ret
                                   (0569) .ENDSECTION
                                   (0570) 
                                   (0571) .SECTION
                                   (0572) ;-----------------------------------------------------------------------------
                                   (0573) ;  FUNCTION NAME: Boot_RxD_bReadRxStatus
                                   (0574) ;
                                   (0575) ;  DESCRIPTION:
                                   (0576) ;    Reads the RX Status bits in the Control/Status register.
                                   (0577) ;
                                   (0578) ;-----------------------------------------------------------------------------
                                   (0579) ;
                                   (0580) ;  ARGUMENTS:  none
                                   (0581) ;
7CC4: 60 29    MOV   REG[41],A     (0582) ;  RETURNS:
                                   (0583) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
7CC6: 7F       RET                 (0584) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0585) ;
                                   (0586) ;  SIDE EFFECTS:
                                   (0587) ;    The A and X registers may be modified by this or future implementations
                                   (0588) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0589) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0590) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0591) ;    functions.
                                   (0592) ;
                                   (0593)  Boot_RxD_bReadRxStatus:
                                   (0594) _Boot_RxD_bReadRxStatus:
                                   (0595)  bBoot_RxD_ReadRxStatus:
                                   (0596) _bBoot_RxD_ReadRxStatus:
                                   (0597)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0598)    mov A,  REG[Boot_RxD_CONTROL_REG]
                                   (0599)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0600)    ret
                                   (0601) .ENDSECTION
                                   (0602) 
                                   (0603) .SECTION
                                   (0604) ;-----------------------------------------------------------------------------
                                   (0605) ;  FUNCTION NAME: Boot_TxD_Start(BYTE bParity)
                                   (0606) ;
                                   (0607) ;  DESCRIPTION:
                                   (0608) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0609) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0610) ;     transmit buffer.
                                   (0611) ;
                                   (0612) ;-----------------------------------------------------------------------------
                                   (0613) ;
7CC7: 5D 2B    MOV   A,REG[43]     (0614) ;  ARGUMENTS:
                                   (0615) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
7CC9: 7F       RET                 (0616) ;
                                   (0617) ;  RETURNS:  none
                                   (0618) ;
                                   (0619) ;  SIDE EFFECTS:
                                   (0620) ;    The A and X registers may be modified by this or future implementations
                                   (0621) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0622) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0623) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0624) ;    functions.
                                   (0625) ;
                                   (0626)  Boot_TxD_Start:
                                   (0627) _Boot_TxD_Start:
                                   (0628)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0629)    or    A, bfCONTROL_REG_START_BIT
                                   (0630)    mov   REG[Boot_TxD_CONTROL_REG], A
                                   (0631)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0632)    ret
                                   (0633) .ENDSECTION
                                   (0634) 
                                   (0635) .SECTION
                                   (0636) ;-----------------------------------------------------------------------------
                                   (0637) ;  FUNCTION NAME: Boot_TxD_SendData
                                   (0638) ;
                                   (0639) ;  DESCRIPTION:
                                   (0640) ;     Sends one byte through serial port.
                                   (0641) ;
                                   (0642) ;-----------------------------------------------------------------------------
                                   (0643) ;
                                   (0644) ;  ARGUMENTS:
                                   (0645) ;     BYTE  TxData - data to transmit.
                                   (0646) ;
                                   (0647) ;  RETURNS:
                                   (0648) ;
                                   (0649) ;  SIDE EFFECTS:
                                   (0650) ;    The A and X registers may be modified by this or future implementations
7CCA: 41 E1 FD AND   REG[225],253  (0651) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0652) ;    the Large Memory Model.  When necessary, it is the calling function's
7CCD: 7F       RET                 (0653) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0654) ;    functions.
                                   (0655) ;
                                   (0656)  Boot_TxD_SendData:
                                   (0657) _Boot_TxD_SendData:
                                   (0658)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0659)    mov REG[Boot_TxD_TX_BUFFER_REG], A
                                   (0660)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0661)    ret
                                   (0662) .ENDSECTION
                                   (0663) 
                                   (0664) .SECTION
                                   (0665) ;-----------------------------------------------------------------------------
                                   (0666) ;  FUNCTION NAME: Boot_TxD_bReadTxStatus
                                   (0667) ;
                                   (0668) ;  DESCRIPTION:
                                   (0669) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0670) ;
                                   (0671) ;-----------------------------------------------------------------------------
                                   (0672) ;
                                   (0673) ;  ARGUMENTS:
                                   (0674) ;
                                   (0675) ;  RETURNS:
                                   (0676) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0677) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0678) ;
                                   (0679) ;  SIDE EFFECTS:
7CCE: 43 23 01 OR    REG[35],1     (0680) ;    The A and X registers may be modified by this or future implementations
                                   (0681) ;    of this function.  The same is true for all RAM page pointer registers in
7CD1: 7F       RET                 (0682) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0683) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0684) ;    functions.
                                   (0685) ;
                                   (0686)  Boot_TxD_bReadTxStatus:
                                   (0687) _Boot_TxD_bReadTxStatus:
                                   (0688)  bBoot_TxD_ReadTxStatus:
                                   (0689) _bBoot_TxD_ReadTxStatus:
                                   (0690)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0691)    mov A,  REG[Boot_TxD_CONTROL_REG]
                                   (0692)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0693)    ret
                                   (0694) 
                                   (0695) .ENDSECTION
                                   (0696) 
                                   (0697) 
                                   (0698) 
                                   (0699) 
                                   (0700) 
                                   (0701) 
                                   (0702) 
                                   (0703) 
                                   (0704) 
                                   (0705) 
                                   (0706) 
                                   (0707) .SECTION
                                   (0708) ;-----------------------------------------------------------------------------
                                   (0709) ;  FUNCTION NAME: Boot_Counter_DisableInt
7CD2: 60 21    MOV   REG[33],A     (0710) ;
7CD4: 5B       MOV   A,X           (0711) ;  DESCRIPTION:
7CD5: 60 25    MOV   REG[37],A     (0712) ;     Disables this counter's interrupt by clearing the interrupt enable
                                   (0713) ;     mask bit associated with this User Module.
7CD7: 7F       RET                 (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;
                                   (0716) ;  ARGUMENTS:    None
                                   (0717) ;  RETURNS:      Nothing
                                   (0718) ;  SIDE EFFECTS: 
                                   (0719) ;    The A and X registers may be modified by this or future implementations
                                   (0720) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0721) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0722) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0723) ;    functions.
                                   (0724) ;
                                   (0725)  Boot_Counter_DisableInt:
                                   (0726) _Boot_Counter_DisableInt:
                                   (0727)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0728)    Boot_Counter_DisableInt_M
                                   (0729)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0730)    ret
                                   (0731) 
                                   (0732) 
                                   (0733) .ENDSECTION
                                   (0734) 
                                   (0735) .SECTION
                                   (0736) ;-----------------------------------------------------------------------------
                                   (0737) ;  FUNCTION NAME: Boot_Counter_Start
                                   (0738) ;
7CD8: 60 22    MOV   REG[34],A     (0739) ;  DESCRIPTION:
7CDA: 5B       MOV   A,X           (0740) ;     Sets the start bit in the Control register of this user module.  The
7CDB: 60 26    MOV   REG[38],A     (0741) ;     counter will begin counting on the next input clock as soon as the
                                   (0742) ;     enable input is asserted high.
7CDD: 7F       RET                 (0743) ;-----------------------------------------------------------------------------
                                   (0744) ;
                                   (0745) ;  ARGUMENTS:    None
                                   (0746) ;  RETURNS:      Nothing
                                   (0747) ;  SIDE EFFECTS: 
                                   (0748) ;    The A and X registers may be modified by this or future implementations
                                   (0749) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0750) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0751) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0752) ;    functions.
                                   (0753) ;
                                   (0754)  Boot_Counter_Start:
                                   (0755) _Boot_Counter_Start:
                                   (0756)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0757)    Boot_Counter_Start_M
                                   (0758)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0759)    ret
                                   (0760) 
                                   (0761) 
                                   (0762) .ENDSECTION
                                   (0763) 
                                   (0764) .SECTION
                                   (0765) ;-----------------------------------------------------------------------------
                                   (0766) ;  FUNCTION NAME: Boot_Counter_WritePeriod
                                   (0767) ;
                                   (0768) ;  DESCRIPTION:
                                   (0769) ;     Write the 16-bit period value into the Period register (DR1).
                                   (0770) ;-----------------------------------------------------------------------------
                                   (0771) ;
                                   (0772) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0773) ;  RETURNS:   Nothing
                                   (0774) ;  SIDE EFFECTS:
                                   (0775) ;    If the counter user module is stopped, then this value will also be
                                   (0776) ;    latched into the Count registers (DR0).
                                   (0777) ;     
                                   (0778) ;    The A and X registers may be modified by this or future implementations
                                   (0779) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0780) ;    the Large Memory Model.  When necessary, it is the calling function's
7CDE: 4F       MOV   X,SP          (0781) ;    responsibility to perserve their values across calls to fastcall16 
7CDF: 5D 26    MOV   A,REG[38]     (0782) ;    functions.
7CE1: 08       PUSH  A             (0783) ;
7CE2: 5D 22    MOV   A,REG[34]     (0784)  Boot_Counter_WritePeriod:
7CE4: 08       PUSH  A             (0785) _Boot_Counter_WritePeriod:
7CE5: 5D 23    MOV   A,REG[35]     (0786)    RAM_PROLOGUE RAM_USE_CLASS_1
7CE7: 08       PUSH  A             (0787)    mov   reg[Boot_Counter_PERIOD_LSB_REG], A
7CE8: 41 23 FE AND   REG[35],254   (0788)    mov   A, X
7CEB: 71 10    OR    F,16          (0789)    mov   reg[Boot_Counter_PERIOD_MSB_REG], A
7CED: 5D 21    MOV   A,REG[33]     (0790)    RAM_EPILOGUE RAM_USE_CLASS_1
7CEF: 08       PUSH  A             (0791)    ret
                                   (0792) 
7CF0: 62 21 00 MOV   REG[33],0     (0793) 
7CF3: 70 EF    AND   F,239         (0794) .ENDSECTION
7CF5: 5D 24    MOV   A,REG[36]     (0795) 
7CF7: 5D 26    MOV   A,REG[38]     (0796) .SECTION
7CF9: 08       PUSH  A             (0797) ;-----------------------------------------------------------------------------
7CFA: 5D 20    MOV   A,REG[32]     (0798) ;  FUNCTION NAME: Boot_Counter_WriteCompareValue
7CFC: 5D 22    MOV   A,REG[34]     (0799) ;
7CFE: 08       PUSH  A             (0800) ;  DESCRIPTION:
7CFF: 52 00    MOV   A,[X+0]       (0801) ;     Writes compare value into the Compare register (DR2).
7D01: 60 26    MOV   REG[38],A     (0802) ;-----------------------------------------------------------------------------
7D03: 52 01    MOV   A,[X+1]       (0803) ;
7D05: 60 22    MOV   REG[34],A     (0804) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
7D07: 71 10    OR    F,16          (0805) ;  RETURNS:      Nothing
7D09: 52 03    MOV   A,[X+3]       (0806) ;  SIDE EFFECTS: 
7D0B: 60 21    MOV   REG[33],A     (0807) ;    The A and X registers may be modified by this or future implementations
7D0D: 70 EF    AND   F,239         (0808) ;    of this function.  The same is true for all RAM page pointer registers in
7D0F: 52 02    MOV   A,[X+2]       (0809) ;    the Large Memory Model.  When necessary, it is the calling function's
7D11: 60 23    MOV   REG[35],A     (0810) ;    responsibility to perserve their values across calls to fastcall16 
7D13: 18       POP   A             (0811) ;    functions.
7D14: 20       POP   X             (0812) ;
7D15: 38 FC    ADD   SP,252        (0813)  Boot_Counter_WriteCompareValue:
7D17: 70 3F    AND   F,63
7D19: 71 C0    OR    F,192         (0814) _Boot_Counter_WriteCompareValue:
7D1C: 10       PUSH  X             (0815)    RAM_PROLOGUE RAM_USE_CLASS_1

FILE: .\flashapi.asm
7D1D: 51 B6    MOV   A,[__r0]      (0137) ;------------------------------------------------------------------------------
7D1F: 08       PUSH  A             (0138) ;   FILENAME:   FlashBlock.asm
                                   (0139) ;    @Version@
7D20: 50 02    MOV   A,2           (0140) ;------------------------------------------------------------------------------
7D22: 57 A0    MOV   X,160         (0141) ;   DESCRIPTION:
7D24: 53 B6    MOV   [182],A       (0142) ;   Routines in this file perform Flash Block Write and Read operations for
                                   (0143) ;   Large Memory Model family members of the Ge family - CY8C27060 and CY8C29xxx
7D26: 50 00    MOV   A,0           (0144) ;------------------------------------------------------------------------------
7D28: 28       ROMX                (0145) ;   Copyright (c) Cypress MicroSystems 2004. All rights reserved.
7D29: 3A B6    CMP   A,[__r0]      (0146) ;------------------------------------------------------------------------------
7D2B: B0 10    JNZ   0x7D3C        (0147) 
7D2D: 76 B6    INC   [__r0]        (0148) export    bFlashWriteBlock
7D2F: 75       INC   X             (0149) export   _bFlashWriteBlock
7D30: 5B       MOV   A,X           (0150) export    FlashReadBlock
7D31: 39 A6    CMP   A,166         (0151) export   _FlashReadBlock
7D33: BF F2    JNZ   0x7D26        (0152) export   FlashCheckSum
                                   (0153) export   _FlashCheckSum
7D35: 18       POP   A             (0154) export   Boot_Is_Program_Good
7D36: 53 B6    MOV   [__r0],A      (0155) export   _Boot_Is_Program_Good
7D38: 20       POP   X             (0156) 
7D39: 50 01    MOV   A,1           (0157) 
7D3B: 7F       RET                 (0158) include "m8c.inc"
                                   (0159) include "memory.inc"
7D3C: 18       POP   A             (0160) include "flashblock.inc"
7D3D: 53 B6    MOV   [182],A       (0161) 
7D3F: 20       POP   X             (0162) 
7D40: 50 00    MOV   A,0           (0163) Area BootLoaderArea(ROM,REL)
7D42: 7F       RET                 (0164) ;--------------------------------------------
                                   (0165) ;  Declare Flash RAM storage at top of RAM
                                   (0166) ;     This data area is reserved for exclusive
                                   (0167) ;     use by Supervisory operations.
                                   (0168) ;--------------------------------------------
                                   (0169)    area SSCParmBlk(RAM,ABS)
                                   (0170)    org  00F8H
                                   (0171) 
                                   (0172) 
                                   (0173) SSCParameterBlk:                   blk      8     ; reserve 8 bytes: F8 - FF for supervisory operation
7D43: 10       PUSH  X             (0174) 
7D44: 4F       MOV   X,SP          (0175) ;--------------------------------
                                   (0176) ; SSC_Action macro command codes
7D45: 51 B6    MOV   A,[__r0]      (0177) ;--------------------------------
7D47: 08       PUSH  A             (0178) FLASH_OPER_KEY:                     equ      3Ah   ; flash operation key
7D48: 51 B5    MOV   A,[__r1]      (0179) FLASH_WRITE:                        equ      2     ; flash write operation supervisory command
7D4A: 08       PUSH  A             (0180) FLASH_ERASE:                        equ      3     ; flash erase operation supervisory command
7D4B: 51 B4    MOV   A,[__r2]      (0181) FLASH_TEMP_TABLE_LOOKUP:            equ      6     ; flash temperature table command
7D4D: 08       PUSH  A             (0182) 
                                   (0183) ;-------------------------------------
7D4E: 52 FB    MOV   A,[X-5]       (0184) ; Flash temperature programming table
7D50: 59 FC    MOV   X,[X-4]       (0185) ;-------------------------------------
                                   (0186) TEMPERATURE_TABLE_ID:               equ      3     ; flash temperature programming table ID
                                   (0187) 
7D52: 5A B6    MOV   [__r0],X      (0188) ;--------------------------------------------------------------
7D54: 65 B6    ASL   [182]         (0189) ; Supervisory Operation Templates:
7D56: 6A       RLC   A             (0190) ;     Each system supervisory call uses the reserved data area
7D57: 65 B6    ASL   [__r0]        (0191) ;     a little different.  Create overlay templates to improve
7D59: 6A       RLC   A             (0192) ;     readability and maintenance.
7D5A: 65 B6    ASL   [182]         (0193) ;--------------------------------------------------------------
7D5C: 6A       RLC   A             (0194) 
7D5D: 65 B6    ASL   [__r0]        (0195) ;Common Supervisory Code Variables
7D5F: 6A       RLC   A             (0196)    bSSC_KEY1:                       equ      F8h   ; supervisory key
7D60: 65 B6    ASL   [182]         (0197)    bTEMP_SPACE:                     equ      F8h   ; temporary storage when not used for KEY1
7D62: 6A       RLC   A             (0198)    bSSC_KEYSP:                      equ      F9h   ; supervisory stack ptr key
7D63: 65 B6    ASL   [__r0]        (0199)    bSSC_ResultCode:                 equ      F8h   ; result code
7D65: 6A       RLC   A             (0200) 
7D66: 58 B6    MOV   X,[182]       (0201) ;SSC Return Codes
                                   (0202)    bSSC_FAIL:                       equ      01h   ; fail return code
7D68: 53 B5    MOV   [__r1],A      (0203)    bSSC_SUCCESS:                    equ      00h   ; success return code
7D6A: 55 B6 40 MOV   [__r0],64     (0204) 
7D6D: 55 B4 00 MOV   [__r2],0      (0205) ;Flash Erase Operation Template
                                   (0206)    bSSC_FLASH_BlockId:              equ      FAh   ; blockId for Erase and Read
7D70: 7A B6    DEC   [__r0]        (0207)    bSSC_FLASH_BlockID_BANK:         equ      FAh   ; block ID page register in bank 1
7D72: 51 B5    MOV   A,[__r1]      (0208)    bSSC_FLASH_PulseWidth:           equ      FCh   ; Erase pulse width
7D74: 28       ROMX                (0209) 
7D75: 04 B4    ADD   [__r2],A      (0210) ;Flash Write Operation Template
7D77: 75       INC   X             (0211)    bSSC_WRITE_BlockId:              equ      FAh   ; block ID
7D78: 2E B6 00 OR    [__r0],0      (0212)    bSSC_WRITE_BlockID_BANK:         equ      FAh   ; block ID page register in bank 1
7D7B: BF F4    JNZ   0x7D70        (0213)    pSSC_WRITE_FlashBuffer:          equ      FBh   ; pointer to data buffer
                                   (0214)    bSSC_WRITE_PulseWidth:           equ      FCh   ; flash write pulse width or ReadCount
7D7D: 51 B4    MOV   A,[__r2]      (0215)    bSSC_WRITE_State:                equ      FDh   ; reserved
                                   (0216)    bSSC_WRITE_Delay:                equ      FEh   ; flash macro sequence delay count
7D7F: 20       POP   X             (0217)    bSSC_WRITE_ResultCode:           equ      FFh   ; temporary result code
7D80: 5A B4    MOV   [180],X       (0218) 
7D82: 20       POP   X             (0219) ;Flash Write Operation Return Code
7D83: 5A B5    MOV   [__r1],X      (0220)    bSSC_WRITE_FAIL:                 equ      00h   ; failure
7D85: 20       POP   X             (0221)    bSSC_WRITE_SUCCESS:              equ      01h   ; pass
7D86: 5A B6    MOV   [__r0],X      (0222) 
                                   (0223) ;Flash Sequence Time Delay
                                   (0224)    bSSC_WRITE_DELAY:                equ      56h   ; 100us delay at 12MHz
                                   (0225) 
                                   (0226) ;Flash Read Operation Template
7D88: 20       POP   X             (0227)    pSSC_READ_FlashBuffer:           equ      FBh   ; pointer to data buffer
7D89: 7F       RET                 (0228)    wSSC_READ_Counter:               equ      FDh   ; byte counter
                                   (0229) 
                                   (0230) ; Table Lookup Template - NOTE that result is a table overlaying reserved area
                                   (0231)    bSSC_TABLE_TableId:              equ      FAh   ; table ID
                                   (0232) 
                                   (0233) ; Temperature Table Template - returned data after performing a
                                   (0234) ;     Table lookup of table #7 - Pulse Width Equation data based on Temperature - y= mt+b
                                   (0235) ;     Composed to two structures - 3 Bytes each - contains slope, y intercept and multiplier
                                   (0236) ;     Structure 1 is for temperatures from [-40,0]C and structure 2 is for temperaturs from [0,40]C.
                                   (0237)    sTEMP_LineEquationBelowZero:     equ      F8h   ; Line Equation data below zero - m,b,Erase->Program multiplier
                                   (0238)    sTEMP_LineEquationAboveZero:     equ      FBh   ; Line Equation data above zero - m,b,Erase->Program multiplier
                                   (0239)    bTEMP_TempTableRevision:         equ      FFh   ; Table Revision number
                                   (0240)    bTEMP_PulseWidthErase:           equ      FEh   ; Temporary storage area after table validation
                                   (0241)    bTEMP_PulseWidthProgram:         equ      FFh   ; Temporary storage area after table validation
                                   (0242)    ;offsets into each substructure
                                   (0243)    cTEMP_SlopeOffset:               equ      0     ; Slope offset in Temp table template
                                   (0244)    cTEMP_InterceptOffset:           equ      1     ; Intercept offset in Temp table template
                                   (0245)    bTEMP_ProgMultOffset:            equ      2     ; Program multiplier
                                   (0246) 
                                   (0247)    VALID_TABLE_REVISION:            equ      1     ; Temp Table revision number
                                   (0248) 
                                   (0249) 
                                   (0250) ; Flash State mode bits - these bits are used to prevent inadvertent jumping into
                                   (0251) ; the flash write API.  If the state does not match then a HALT instruction will
                                   (0252) ; be executed.
                                   (0253) 
                                   (0254)    STATE_SET_CLOCK:                 equ      01h
                                   (0255)    STATE_CALCULATE_PW:              equ      02h
                                   (0256)    STATE_ERASE_BLOCK:               equ      04h
                                   (0257)    STATE_WRITE_BLOCK:               equ      08h
                                   (0258)    STATE_RESTORE_CLOCK:             equ      10h
                                   (0259)    STATE_DONE:                      equ      20h
                                   (0260) 
                                   (0261) ;--------------------------------------------
                                   (0262) ;  Restore area to Code area
                                   (0263) ;--------------------------------------------
                                   (0264) Area BootLoaderArea(ROM,REL)
                                   (0265) // ----------------------------------------------------------------------------------------
                                   (0266) //	Control subroutine which determine whether user program is based on BootLoader Project
                                   (0267) //  Return: 0 - if bad program
                                   (0268) // 	  	    1 - if all right
                                   (0269) // ----------------------------------------------------------------------------------------
                                   (0270) Boot_Is_Program_Good:
                                   (0271) _Boot_Is_Program_Good:
                                   (0272) 	push X
                                   (0273) 	mov A,[__r0]
                                   (0274) 	push A
                                   (0275) 	
                                   (0276) 	mov A,2
                                   (0277) 	mov X,A0h			; init start control sequence address
                                   (0278) 	mov [__r0],A		; initiate counter
                                   (0279) Start_Control:	
                                   (0280) 	mov A,0
                                   (0281) 	romx
                                   (0282) 	cmp A,[__r0]		; does addr 00A0 contain 0x7D (ljump)
                                   (0283) 	jnz Error_Program
                                   (0284) 	inc [__r0]
                                   (0285) 	inc X
                                   (0286) 	mov A,X
                                   (0287) 	cmp A,A6h			; is > than last sequence address?
                                   (0288) 	jnz Start_Control	; goto next sequence address
                                   (0289) 	
                                   (0290) 	pop A	
                                   (0291) 	mov [__r0],A
                                   (0292) 	pop X
                                   (0293) 	mov A,1		; restore register from stack
                                   (0294) 	ret			; if ok then return 1
                                   (0295) Error_Program:
                                   (0296) 	pop A	
7D8A: 30       HALT                (0297) 	mov [__r0],A
                                   (0298) 	pop X		; restore register from stack
                                   (0299) 	mov A,0		; if bad program then return 0
                                   (0300) 	ret	
                                   (0301) 
7D8B: 62 D0 00 MOV   REG[208],0    (0302) // ---------------------------
                                   (0303) // Flash Block CheckSum
7D8E: 53 F8    MOV   [gTickCount+1],A(0304) // Entrance: A - LSB of block ID
7D90: 5D F7    MOV   A,REG[247]    (0305) //           X - MSB of block ID 
7D92: 08       PUSH  A             (0306) // Exit: A - CheckSum
7D93: 51 F8    MOV   A,[gTickCount+1](0307) FlashCheckSum:
                                   (0308) _FlashCheckSum:
                                   (0309) 
                                   (0310) 	push X
7D95: 70 BF    AND   F,191         (0311) 	mov X,SP
7D97: 60 D3    MOV   REG[211],A    (0312) 
                                   (0313) 	mov A,[__r0]
                                   (0314) 	push A
                                   (0315) 	mov A,[__r1]
                                   (0316) 	push A
7D99: 55 FD 01 MOV   [253],1       (0317) 	mov A,[__r2]
                                   (0318) 	push A
                                   (0319) 
                                   (0320)     mov A,[X-5]						; A = MSB of BlockID
7D9C: 3C FD 01 CMP   [253],1       (0321) 	mov X,[X-4]						; X = LSB of BlockID
7D9F: B0 C5    JNZ   0x7E65        (0322) 
                                   (0323) 					// calculate address addr = BlockID<<6 = BlockID*64
                                   (0324) 	mov [__r0],X
7DA1: 71 10    OR    F,16          (0325)     asl [__r0]
7DA3: 5D E0    MOV   A,REG[224]    (0326)     rlc A
7DA5: 08       PUSH  A             (0327)     asl [__r0]
7DA6: 21 F8    AND   A,248         (0328)     rlc A
                                   (0329)     asl [__r0]
                                   (0330)     rlc A
7DA8: 49 FE 10 TST   REG[254],16   (0331) 	asl [__r0]
7DAB: A0 05    JZ    0x7DB1        (0332)     rlc A
                                   (0333)     asl [__r0]
                                   (0334)     rlc A
7DAD: 29 03    OR    A,3           (0335)     asl [__r0]
7DAF: 80 03    JMP   0x7DB3        (0336)     rlc A
                                   (0337)     mov X,[__r0]
7DB1: 29 02    OR    A,2           (0338) 	
                                   (0339) 	mov [__r1],A		; Address MSB
7DB3: 60 E0    MOV   REG[224],A    (0340) 	mov [__r0],64		; Cycle Iterator
7DB5: 70 EF    AND   F,239         (0341) 	mov [__r2],0		; CheckSum
                                   (0342) calc_cs:
                                   (0343) 	dec [__r0]			; decrement Cycle Iterator
                                   (0344) 	mov A,[__r1]
7DB7: 65 FD    ASL   [253]         (0345) 	romx
                                   (0346) 	add [__r2],A
7DB9: 3C FD 02 CMP   [253],2       (0347) 	inc X				; increment X to get next address
7DBC: B0 A8    JNZ   0x7E65        (0348) 	or [__r0],0			; if ([__r0]!=0) goto calc_cs;
                                   (0349) 	jnz calc_cs			; 
                                   (0350) 
7DBE: 90 B0    CALL  0x7E70        (0351) 	mov A,[__r2]		; return CheckSum  
                                   (0352) 	
7DC0: 39 00    CMP   A,0           (0353) 	pop X
7DC2: A0 09    JZ    0x7DCC        (0354) 	mov [__r2],X
                                   (0355) 	pop X
                                   (0356) 	mov [__r1],X
7DC4: 55 FF 00 MOV   [255],0       (0357) 	pop X
7DC7: 55 FD 10 MOV   [253],16      (0358) 	mov [__r0],X
7DCA: 80 85    JMP   0x7E50        (0359) 
                                   (0360) //	mov [bSSC_WRITE_BlockId],A
                                   (0361) //	SSC_Action FLASH_CHECKSUM		// CheckSum return in [KEY2][KEY1]
                                   (0362) //	mov A,[bSSC_KEY1]		
7DCC: 65 FD    ASL   [253]         (0363) 	pop X
                                   (0364) 	ret
                                   (0365) ;-----------------------------------------------------------------------------
7DCE: 52 01    MOV   A,[X+1]       (0366) ;  MACRO NAME: SSC_Action
7DD0: 6A       RLC   A             (0367) ;
7DD1: 52 00    MOV   A,[X+0]       (0368) ;  DESCRIPTION:
7DD3: 6A       RLC   A             (0369) ;     Performs locally defined supervisory operations.
7DD4: 71 10    OR    F,16          (0370) ;
7DD6: 60 FA    MOV   REG[250],A    (0371) ;     !!! DO NOT CHANGE THIS CODE !!!
7DD8: 70 EF    AND   F,239         (0372) ;        This sequence of opcodes provides a
7DDA: 08       PUSH  A             (0373) ;        signature for the debugger and ICE.
7DDB: 52 01    MOV   A,[X+1]       (0374) ;     !!! DO NOT CHANGE THIS CODE !!!
7DDD: 21 7F    AND   A,127         (0375) ;
7DDF: 53 FA    MOV   [gTickCount+3],A(0376) ;  ARGUMENTS:
7DE1: 08       PUSH  A             (0377) ;     BYTE  bOperation   - specified supervisory operation - defined operations
                                   (0378) ;                          are:  FLASH_WRITE, FLASH_ERASE, FLASH_TEMP_TABLE_LOOKUP.
7DE2: 52 05    MOV   A,[X+5]       (0379) ;
7DE4: 53 FC    MOV   [252],A       (0380) ;  RETURNS:
7DE6: 55 FE 56 MOV   [254],86      (0381) ;     none.
                                   (0382) ;
7DE9: 51 FD    MOV   A,[253]       (0383) ;  SIDE EFFECTS:
7DEB: 39 04    CMP   A,4           (0384) ;     A and X registers are destroyed
7DED: B0 77    JNZ   0x7E65        (0385) ;
7DEF: 08       PUSH  A             (0386) ;  PROCEDURE:
7DF0: 10       PUSH  X             (0387) ;     1) specify a 3 byte stack frame.  Save in [KEYSP]
7DF1: 4F       MOV   X,SP
                                   (0388) ;     2) insert the flash Supervisory key in [KEY1]
                                   (0389) ;     3) store flash operation function code in A
                                   (0390) ;     4) call the supervisory code
7DF2: 5B       MOV   A,X           (0391) ;-----------------------------------------------------------------------------
7DF3: 01 03    ADD   A,3
7DF5: 53 F9    MOV   [gTickCount+2],A
7DF7: 55 F8 3A MOV   [gTickCount+1],58
7DFA: 50 03    MOV   A,3
7DFC: 00       SWI   
                                   (0392) macro SSC_Action
                                   (0393)       mov   X, SP                         ; copy SP into X
7DFD: 20       POP   X             (0394)       mov   A, X                          ; mov to A
7DFE: 18       POP   A             (0395)       add   A, 3                          ; create 3 byte stack frame
7DFF: 53 FD    MOV   [253],A       (0396)       mov   [bSSC_KEYSP], A               ; save stack frame for supervisory code
                                   (0397)       mov   [bSSC_KEY1], FLASH_OPER_KEY   ; load the supervisory code for flash operations
7E01: 3C F8 00 CMP   [gTickCount+1],0(0398)       mov   A, @0                         ; load A with specific Flash operation
7E04: A0 0B    JZ    0x7E10        (0399)       SSC                                 ; SSC call the supervisory code
                                   (0400) endm
                                   (0401) 
7E06: 55 FF 00 MOV   [255],0       (0402) ;-----------------------------------------------------------------------------
7E09: 55 FD 10 MOV   [253],16      (0403) ;  FUNCTION NAME: bFlashWriteBlock
7E0C: 38 FE    ADD   SP,254        (0404) ;
7E0E: 80 41    JMP   0x7E50        (0405) ;  DESCRIPTION:
                                   (0406) ;     Writes 64 bytes of data to the flash at the specified blockId.
                                   (0407) ;
                                   (0408) ;     Regardless of the size of the buffer, this routine always writes 64
                                   (0409) ;     bytes of data. If the buffer is less than 64 bytes, then the next
7E10: 65 FD    ASL   [253]         (0410) ;     64-N bytes of data will be written to fill the rest of flash block data.
                                   (0411) ;
                                   (0412) ;  ARGUMENTS:
7E12: 18       POP   A             (0413) ;     X ->  psBlockWriteData  -  a structure that holds the
7E13: 53 FA    MOV   [gTickCount+3],A(0414) ;                                calling arguments and some reserved space
7E15: 18       POP   A             (0415) ;
7E16: 71 10    OR    F,16          (0416) ;  RETURNS:
7E18: 60 FA    MOV   REG[250],A    (0417) ;     BYTE - successful if NON-Zero returned.
7E1A: 70 EF    AND   F,239         (0418) ;
                                   (0419) ;     ASSEMBLER - returned in Accumulator.
7E1C: 52 03    MOV   A,[X+3]       (0420) ;
7E1E: 53 FB    MOV   [251],A       (0421) ;  SIDE EFFECTS:
7E20: 52 02    MOV   A,[X+2]       (0422) ;     1) CPU clock temporarily set to 12MHz.
7E22: 60 D4    MOV   REG[212],A    (0423) ;
                                   (0424) ;  PROCEDURE:
                                   (0425) ;     1) Setup the proper CPU clock - 12 MHz or 6MHz depending on state of SLIMO
7E24: 52 06    MOV   A,[X+6]       (0426) ;     2) Compute the pulsewidths
7E26: 53 FC    MOV   [252],A       (0427) ;     3) Erase the specified block
7E28: 55 FE 56 MOV   [254],86      (0428) ;     4) Program the specified block
                                   (0429) ;     5) restore the original CPU rate
7E2B: 51 FD    MOV   A,[253]       (0430) ;     6) check the result code and return
7E2D: 39 08    CMP   A,8           (0431) ;-----------------------------------------------------------------------------
7E2F: B0 35    JNZ   0x7E65        (0432) ; Place Halt instruction code here to mitigate wondering into this code from the top
7E31: 08       PUSH  A             (0433)    halt
7E32: 10       PUSH  X             (0434) .SECTION
7E33: 4F       MOV   X,SP
                                   (0435)  bFlashWriteBlock:
                                   (0436) _bFlashWriteBlock:
                                   (0437)    ; Preserve the SMM or LMM paging mode
7E34: 5B       MOV   A,X           (0438)    RAM_SETPAGE_CUR 0          ; set paging mode
7E35: 01 03    ADD   A,3
7E37: 53 F9    MOV   [gTickCount+2],A
7E39: 55 F8 3A MOV   [gTickCount+1],58
7E3C: 50 02    MOV   A,2
7E3E: 00       SWI   
                                   (0439) 
                                   (0440)    mov   [bTEMP_SPACE], A     ; temporarily store the MSB of the WriteBlock structure
7E3F: 20       POP   X             (0441)    mov   A, reg[CPU_F]        ; grab the current CPU flag register and save on stack
7E40: 18       POP   A             (0442)    push  A
7E41: 53 FD    MOV   [253],A       (0443)    mov   A, [bTEMP_SPACE]     ; restore the MSB of the WriteBlock structure
                                   (0444) 
7E43: 55 FF 01 MOV   [255],1       (0445)    ; Since the flash SSC operations all reference page 0, save and set the current ptr
7E46: 3C F8 00 CMP   [gTickCount+1],0(0446)    ; to page 0 and the X_ptr to track input data page.
7E49: A0 04    JZ    0x7E4E        (0447)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0448)    RAM_SETPAGE_IDX A
                                   (0449) 
7E4B: 55 FF 00 MOV   [255],0       (0450)    ; Set the intial state variable - if code entered from the top - then state
                                   (0451)    ; variable will not catch this inadvertent entry.  However, any entry from
                                   (0452)    ; made after this statement should be caught!
                                   (0453)    mov   [bSSC_WRITE_State], STATE_SET_CLOCK
7E4E: 65 FD    ASL   [253]         (0454) 
                                   (0455) ; Step 1 - setup the proper CPU clock - 12 MHz if SLIMO NOT enabled, else 6MHz
                                   (0456)    ; Check the state variable - are we supposed to be here?
7E50: 3C FD 10 CMP   [253],16      (0457)    cmp   [bSSC_WRITE_State], STATE_SET_CLOCK
7E53: B0 11    JNZ   0x7E65        (0458)    jnz   bFlashWriteStateError
                                   (0459) 
                                   (0460)    ; State - Set Clock
7E55: 18       POP   A             (0461)    M8C_SetBank1
7E56: 71 10    OR    F,16          (0462)    mov   A, reg[OSC_CR0]                  ; Get the System Oscillator control register
7E58: 60 E0    MOV   REG[224],A    (0463)    push  A                                ;     and save it on the stack
7E5A: 70 EF    AND   F,239         (0464)    and   A, ~OSC_CR0_CPU                  ; Clear the CPU clock selects
7E5C: 65 FD    ASL   [253]         (0465) 
                                   (0466)    ; Check state of SLIMO
                                   (0467)    tst   reg[CPU_SCR1], CPU_SCR1_SLIMO
7E5E: 51 FF    MOV   A,[255]       (0468)    jz    .Set12MHz                        ; if Z=0 then SLIMO NOT enabled - set 12MHz
                                   (0469) 
                                   (0470) .Set6MHz:
                                   (0471)    or    A, OSC_CR0_CPU_24MHz             ; SLIMO enabled - set CPU clock to 6MHz
7E60: 3C FD 20 CMP   [253],32      (0472)    jmp   .SetOSC                          ;  IMO clock max is 6MHz - DIVISOR = 1 ==> 24MHz setting
7E63: A0 04    JZ    0x7E68        (0473) .Set12MHz:
                                   (0474)    or    A, OSC_CR0_CPU_12MHz             ; Set CPU clock to 12 MHz
                                   (0475) .SetOSC:
                                   (0476)    mov   reg[OSC_CR0], A
7E65: 30       HALT                (0477)    M8C_SetBank0
7E66: 8F FE    JMP   0x7E65        (0478) 
7E68: 70 3F    AND   F,63
                                   (0479) ; Step 2 - compute the pulsewidths
                                   (0480) ComputePulseWidths:
7E6A: 71 C0    OR    F,192         (0481)    asl   [bSSC_WRITE_State]               ; update the state variable
                                   (0482)    ; Check the state variable - are we supposed to be here?
                                   (0483)    cmp   [bSSC_WRITE_State], STATE_CALCULATE_PW
7E6C: 7E       RETI                (0484)    jnz   bFlashWriteStateError
                                   (0485) 
                                   (0486)    ; State - Calculate PW
                                   (0487)    call  bComputePulseWidth
                                   (0488)    ; Preset the resturn code to Success
7E6D: 30       HALT                (0489)    cmp   A, bSSC_SUCCESS                  ; Check the return value
7E6E: 30       HALT                (0490)    jz    EraseBlock                       ;     the pulse width was computed OK
7E6F: 30       HALT                (0491)    ; A bad pulse width table was found!
                                   (0492)    ; Need to set the result code, restore the clock, and then exit!
                                   (0493)    mov   [bSSC_WRITE_ResultCode], bSSC_WRITE_FAIL
                                   (0494)    mov   [bSSC_WRITE_State], STATE_RESTORE_CLOCK
                                   (0495)    jmp   RestoreClock
                                   (0496) 
                                   (0497) ; Step 3 - Erase the specified flash block
                                   (0498) EraseBlock:
                                   (0499)    asl   [bSSC_WRITE_State]               ; update the state variable
                                   (0500)    ; State - Erase Block
                                   (0501) 
                                   (0502)    mov   A, [X+wARG_BlockId+1]            ; set block ID to be 128 blocks by N Banks
                                   (0503)    rlc   A
                                   (0504)    mov   A, [X+wARG_BlockId]
                                   (0505)    rlc   A
                                   (0506)    M8C_SetBank1
                                   (0507)    mov   reg[bSSC_FLASH_BlockID_BANK], A  ; set the bank of the blockID
                                   (0508)    M8C_SetBank0
                                   (0509)    push  A
                                   (0510)    mov   A, [X+wARG_BlockId+1]
                                   (0511)    and   A, 0x7F
                                   (0512)    mov   [bSSC_WRITE_BlockId], A          ; set the block-within-Bank-ID
                                   (0513)    push  A
                                   (0514) 
                                   (0515)    mov   A, [X+bDATA_PWErase]             ; set the pulse width
                                   (0516)    mov   [bSSC_WRITE_PulseWidth], A
                                   (0517)    mov   [bSSC_WRITE_Delay], bSSC_WRITE_DELAY   ; load the sequence delay count
                                   (0518)    ; Check the state variable - are we supposed to be here?
                                   (0519)    mov   A, [bSSC_WRITE_State]
                                   (0520)    cmp   A, STATE_ERASE_BLOCK
                                   (0521)    jnz   bFlashWriteStateError
                                   (0522)    push  A                                ; save the State variable
                                   (0523)    push  X
                                   (0524) 
                                   (0525) .Literal
                                   (0526) _FlashBlockLocal1::
                                   (0527)    SSC_Action FLASH_ERASE                 ; Erase the specified block
                                   (0528) .EndLiteral
                                   (0529) 
                                   (0530)    pop   X
                                   (0531)    pop   A                                ; restore the State variable
                                   (0532)    mov   [bSSC_WRITE_State], A
                                   (0533)    ; Check the return code for success
                                   (0534)    cmp   [bSSC_ResultCode], bSSC_SUCCESS
                                   (0535)    jz    WriteBlock
                                   (0536)    ; Erase operation failed!
                                   (0537)    ; Need to set the result code, restore the clock, and then exit!
                                   (0538)    mov   [bSSC_WRITE_ResultCode], bSSC_WRITE_FAIL
                                   (0539)    mov   [bSSC_WRITE_State], STATE_RESTORE_CLOCK
                                   (0540)    add   SP, -2                           ; retire the bank and block #s
                                   (0541)    jmp   RestoreClock
                                   (0542) 
                                   (0543) ; Step 4 - Program the flash
                                   (0544) WriteBlock:
                                   (0545)    ; Update the state variable
                                   (0546)    asl   [bSSC_WRITE_State]
                                   (0547)    ; State - Write Block
                                   (0548) 
                                   (0549)    pop   A                                ; load WRITE opeation parameters
                                   (0550)    mov   [bSSC_WRITE_BlockId], A          ; set the LSB of the blockID
                                   (0551)    pop   A
                                   (0552)    M8C_SetBank1
                                   (0553)    mov   reg[bSSC_FLASH_BlockID_BANK], A  ; set the bank of the blockID
                                   (0554)    M8C_SetBank0
                                   (0555) 
                                   (0556)    mov   A, [X+pARG_FlashBuffer+1]        ; set the LSB of the RAM buffer ptr
7E70: 55 FA 03 MOV   [gTickCount+3],3(0557)    mov   [pSSC_WRITE_FlashBuffer], A
7E73: 62 D5 00 MOV   REG[213],0    (0558)    mov   A, [X+pARG_FlashBuffer]          ; set the MSB of the RAM buffer ptr
7E76: 71 10    OR    F,16          (0559)    mov   reg[MVR_PP], A
7E78: 62 FA 00 MOV   REG[250],0    (0560) 
7E7B: 70 EF    AND   F,239         (0561) 
                                   (0562)    mov   A, [X+bDATA_PWProgram]
                                   (0563)    mov   [bSSC_WRITE_PulseWidth], A
7E7D: 51 FD    MOV   A,[253]       (0564)    mov   [bSSC_WRITE_Delay], bSSC_WRITE_DELAY   ; load the sequence delay count
7E7F: 39 02    CMP   A,2           (0565)    ; Check the state variable - are we supposed to be here?
7E81: BF E3    JNZ   0x7E65        (0566)    mov   A, [bSSC_WRITE_State]
7E83: 08       PUSH  A             (0567)    cmp   A, STATE_WRITE_BLOCK
7E84: 10       PUSH  X             (0568)    jnz   bFlashWriteStateError
7E85: 4F       MOV   X,SP
                                   (0569)    push  A                                ; save the State variable
                                   (0570)    push  X
                                   (0571) 
7E86: 5B       MOV   A,X           (0572) .Literal
7E87: 01 03    ADD   A,3
7E89: 53 F9    MOV   [gTickCount+2],A
7E8B: 55 F8 3A MOV   [gTickCount+1],58
7E8E: 50 06    MOV   A,6
7E90: 00       SWI   
                                   (0573) _FlashBlockLocal2::
                                   (0574)    SSC_Action FLASH_WRITE                 ; Program the flash
7E91: 20       POP   X             (0575) .EndLiteral
                                   (0576) 
                                   (0577)    pop   X
7E92: 3C FF 01 CMP   [255],1       (0578)    pop   A                                ; restore the state variable
7E95: B0 75    JNZ   0x7F0B        (0579)    mov   [bSSC_WRITE_State], A
                                   (0580)    ; Set the return code
                                   (0581)    mov   [bSSC_WRITE_ResultCode], bSSC_WRITE_SUCCESS
7E97: 10       PUSH  X             (0582)    cmp   [bSSC_ResultCode], bSSC_SUCCESS
7E98: 5D D3    MOV   A,REG[211]
7E9A: 08       PUSH  A             (0583)    jz    NextState
                                   (0584)    ; Write operation failed!
7E9B: 52 04    MOV   A,[X+4]       (0585)    ; Need to set the result code, restore the clock, and then exit!
7E9D: 60 E8    MOV   REG[232],A    (0586)    mov   [bSSC_WRITE_ResultCode], bSSC_WRITE_FAIL
7E9F: 21 80    AND   A,128         (0587) 
7EA1: B0 09    JNZ   0x7EAB        (0588) ; Step 5 - restore the original CPU rate
                                   (0589) NextState:
                                   (0590)    asl   [bSSC_WRITE_State]               ; update the state variable
7EA3: 51 FD    MOV   A,[253]       (0591)    ; Check the state variable - are we supposed to be here?
7EA5: 54 07    MOV   [X+7],A       (0592) RestoreClock:
7EA7: 57 FB    MOV   X,251         (0593)    cmp   [bSSC_WRITE_State], STATE_RESTORE_CLOCK
7EA9: 80 07    JMP   0x7EB1        (0594)    jnz   bFlashWriteStateError
                                   (0595) 
                                   (0596)    ; State - Restore Clock
7EAB: 51 FA    MOV   A,[gTickCount+3](0597)    pop   A
7EAD: 54 07    MOV   [X+7],A       (0598)    M8C_SetBank1
7EAF: 57 F8    MOV   X,248         (0599)    mov   reg[OSC_CR0], A                  ; Restore org CPU rate
                                   (0600)    M8C_SetBank0                           ; Switch back to Bank 0
                                   (0601)    asl   [bSSC_WRITE_State]               ; update the state variable
                                   (0602) 
7EB1: 62 D3 00 MOV   REG[211],0    (0603) ; Step 6 - Compute the return result code
                                   (0604)    mov   A, [bSSC_WRITE_ResultCode]
7EB4: 52 00    MOV   A,[X+0]       (0605) 
7EB6: 60 E9    MOV   REG[233],A    (0606) bFlashWriteBlockEnd:
7EB8: 5D EB    MOV   A,REG[235]    (0607) ; check the state variable for proper exit -
7EBA: 64       ASL   A             (0608)    cmp   [bSSC_WRITE_State], STATE_DONE
7EBB: 5D EA    MOV   A,REG[234]    (0609)    jz    bFlashWriteExit
7EBD: 6A       RLC   A             (0610) 
7EBE: 73       CPL   A             (0611) ; if we arrived here, it means that the flashWrite API was randomly entered!!!
7EBF: 74       INC   A             (0612) bFlashWriteStateError:
7EC0: 03 01    ADD   A,[X+1]       (0613)    halt
7EC2: 53 FE    MOV   [254],A       (0614)    jmp   bFlashWriteStateError
                                   (0615) 
                                   (0616) bFlashWriteExit:
7EC4: 21 7F    AND   A,127         (0617)    RAM_EPILOGUE RAM_USE_CLASS_3
7EC6: 60 E8    MOV   REG[232],A    (0618) 
7EC8: 52 02    MOV   A,[X+2]       (0619) ; return with a RETI to preserve the last paging mode - SMM or LMM
7ECA: 67       ASR   A             (0620)    reti
7ECB: 21 7F    AND   A,127         (0621) 
7ECD: 60 E9    MOV   REG[233],A    (0622) 
                                   (0623) 
7ECF: 5D EA    MOV   A,REG[234]    (0624) ; Put halt here in case we jump inadvertently
7ED1: 53 FF    MOV   [255],A       (0625)    halt
7ED3: 5D EB    MOV   A,REG[235]    (0626)    halt
7ED5: 64       ASL   A             (0627)    halt
7ED6: 6B FF    RLC   [255]         (0628) 
                                   (0629) ;-----------------------------------------------------------------------------
7ED8: 48 02 01 TST   [X+2],1       (0630) ;  FUNCTION NAME:    ComputePulseWidth
7EDB: A0 06    JZ    0x7EE2        (0631) ;
7EDD: 02 FE    ADD   A,[254]       (0632) ;  DESCRIPTION:
7EDF: 0E FF 00 ADC   [255],0       (0633) ;     Computes the Block Erase and Block Program pulse width counts for the
                                   (0634) ;     Flash Erase and Flash Program supervisory calls.
7EE2: 64       ASL   A             (0635) ;
7EE3: 6B FF    RLC   [255]         (0636) ;     This routine gets its data from the FlashWriteBlock data structure
7EE5: 64       ASL   A             (0637) ;     and saves the return data in the same structure.
7EE6: 6B FF    RLC   [255]         (0638) ;
7EE8: 18       POP   A
                                   (0639) ;     First, the Temperature data table is accessed via the Table Read SSC
                                   (0640) ;     function.  Then the Erase  and Program pulse width counts are computed.
                                   (0641) ;
7EE9: 60 D3    MOV   REG[211],A    (0642) ;     Temperature table gives the slope, Y intercept, and Erase to Program pulse
7EEB: 51 FF    MOV   A,[255]       (0643) ;     width converion.  Two equations are given - temperatures below 0 and
7EED: 20       POP   X             (0644) ;     temperatures above 0. Data is scaled to fit within specified byte range.
7EEE: 54 06    MOV   [X+6],A       (0645) ;
7EF0: 51 FE    MOV   A,[254]       (0646) ;        PW(erase) = B - M*T*2/256 and PW(program)= PW(erase)*Multiplier/64
7EF2: 54 05    MOV   [X+5],A       (0647) ;
                                   (0648) ;     ADJUSTMENT FOR SLIMO:
                                   (0649) ;     --------------------
                                   (0650) ;     After calculation of both the PW(erase) and PW(Program), the SLIMO bit
7EF4: 49 FE 10 TST   REG[254],16   (0651) ;     is detected. If the SLIMO bit is enabled then both programming pulses are
7EF7: A0 09    JZ    0x7F01        (0652) ;     divided by TWO and incremented by one for roundoff.  This is due to the fact
                                   (0653) ;     that the CPU clock will be set for 6MHz instead of 12MHz which means that the
                                   (0654) ;     SSC EraseBlk and WriteBlk operation will take twice as long.
7EF9: 69 06    ASR   [X+6]         (0655) ;
7EFB: 77 06    INC   [X+6]         (0656) ;  ARGUMENTS:
7EFD: 69 05    ASR   [X+5]         (0657) ;     X points to bFlashWriteBlock calling structure.
7EFF: 77 05    INC   [X+5]         (0658) ;
                                   (0659) ;  RETURNS:
                                   (0660) ;     BYTE  bResult - return in Accumulator
7F01: 18       POP   A             (0661) ;           0 = valid
7F02: 39 02    CMP   A,2           (0662) ;           1 = invalid revision
7F04: BF 60    JNZ   0x7E65        (0663) ;
7F06: 53 FD    MOV   [253],A       (0664) ;     Erase and Program pulse widths are returned in bFlashWriteBlock calling
7F08: 50 00    MOV   A,0           (0665) ;     structure.
7F0A: 7F       RET                 (0666) ;
                                   (0667) ;  SIDE EFFECTS:
                                   (0668) ;     none.
7F0B: 18       POP   A             (0669) ;
7F0C: 39 02    CMP   A,2           (0670) ;  REQUIREMENTS:
7F0E: BF 56    JNZ   0x7E65        (0671) ;
7F10: 53 FD    MOV   [253],A       (0672) ;     1) The calculated erase pulse width is always < 128 (does not overflow 7 bits)
7F12: 50 01    MOV   A,1           (0673) ;     2) The calculated write pulse width is always < 256 (does not overflow 8 bits)
7F14: 7F       RET                 (0674) ;     3) If SLIMO is enabled, then this algorithm assumes the CPU clock will be set
                                   (0675) ;        for 6MHz and NOT 12MHz!
                                   (0676) ;
                                   (0677) ;     These requirements MUST be guaranteed during device calibration.
                                   (0678) ;     They are not checked.  If they are not met, the pulse width calculation will fail.
                                   (0679) ;
                                   (0680) ;  PROCEDURE:
                                   (0681) ;     1) Get the flash programming temperature table
                                   (0682) ;     2) Check the table revision number
                                   (0683) ;     3) Select the correct data set, based on temperature
                                   (0684) ;     4) Compute the Erase Pulsewidth count
                                   (0685) ;     5) Compute the Program Pulsewidth count
                                   (0686) ;     6) Save the result data
                                   (0687) ;     7) Adjust for SLIMO
                                   (0688) ;
                                   (0689) ;-----------------------------------------------------------------------------
                                   (0690) bComputePulseWidth:
                                   (0691) 
                                   (0692)    ; 1) Get the flash programming temperature table
                                   (0693)    mov   [bSSC_TABLE_TableId], TEMPERATURE_TABLE_ID
                                   (0694)    RAM_SETPAGE_MVW 0                      ; set table WRITE page to 0
                                   (0695)    M8C_SetBank1
                                   (0696)    mov   reg[bSSC_FLASH_BlockID_BANK], 0  ; set the SSC operation page to 0
                                   (0697)    M8C_SetBank0
                                   (0698) 
                                   (0699)    ; Check the State
                                   (0700)    mov   A, [bSSC_WRITE_State]
                                   (0701)    cmp   A, STATE_CALCULATE_PW
                                   (0702)    jnz   bFlashWriteStateError
7F15: 62 D0 00 MOV   REG[208],0    (0703)    push  A                                ; save the State variable
7F18: 53 F8    MOV   [gTickCount+1],A(0704)    push  X
7F1A: 5D F7    MOV   A,REG[247]    (0705) 
7F1C: 08       PUSH  A             (0706) .Literal
7F1D: 51 F8    MOV   A,[gTickCount+1](0707) _FlashBlockLocal3::
                                   (0708)    SSC_Action  FLASH_TEMP_TABLE_LOOKUP
                                   (0709) .EndLiteral
                                   (0710) 
7F1F: 70 BF    AND   F,191         (0711)    pop   X
7F21: 60 D3    MOV   REG[211],A    (0712) 
                                   (0713)    ; 2) Check table revision
                                   (0714)    cmp   [bTEMP_TempTableRevision], VALID_TABLE_REVISION
                                   (0715)    jnz   ComputePulseWidthTableError      ; jump if revision is out of date!
7F23: 52 03    MOV   A,[X+3]       (0716) 
7F25: 53 FB    MOV   [251],A       (0717)    ; 3) Select the correct data set, based on temperature
7F27: 52 02    MOV   A,[X+2]       (0718)    push  X                                ; save the X pointer
7F29: 60 D5    MOV   REG[213],A    (0719)    REG_PRESERVE  IDX_PP                   ; save the X pointer page
7F2B: 52 04    MOV   A,[X+4]       (0720) 
7F2D: 74       INC   A             (0721)    mov   A, [X+cARG_Temperature]          ; load temperature into the MULTIPLIER
7F2E: 53 FD    MOV   [253],A       (0722)    mov   REG[MUL_X], A
7F30: 52 05    MOV   A,[X+5]       (0723)    and   A, 80h                           ; Test for sign of temperature
7F32: 53 FE    MOV   [254],A       (0724)    jnz   BelowZero
                                   (0725) 
                                   (0726) AboveZero:                                ; Positive temperature
                                   (0727)    mov   A, [sTEMP_LineEquationAboveZero + bTEMP_ProgMultOffset]
7F34: 52 01    MOV   A,[X+1]       (0728)    mov   [X+bDATA_PWMultiplier], A        ; Save the multiplier for later use
7F36: 64       ASL   A             (0729)    mov   X, sTEMP_LineEquationAboveZero   ; X pts to Temp table above zero
7F37: 6C 00    RLC   [X+0]         (0730)    jmp   ComputeData
7F39: 64       ASL   A             (0731) 
7F3A: 6C 00    RLC   [X+0]         (0732) BelowZero:                                ; Negative temperature
7F3C: 64       ASL   A             (0733)    mov   A, [sTEMP_LineEquationBelowZero + bTEMP_ProgMultOffset]
7F3D: 6C 00    RLC   [X+0]         (0734)    mov   [X+bDATA_PWMultiplier], A        ; Save the multiplier for later use
7F3F: 64       ASL   A             (0735)    mov   X, sTEMP_LineEquationBelowZero   ; X pts to Temp table data below zero
7F40: 6C 00    RLC   [X+0]         (0736) 
7F42: 64       ASL   A             (0737)    ; 4) Compute the Erase PulseWidth count => PW(e) = B - M*T*2/256
7F43: 6C 00    RLC   [X+0]         (0738) ComputeData:
7F45: 64       ASL   A             (0739)    RAM_SETPAGE_IDX  0                     ; set the X pointer page to pt to zero page
7F46: 6C 00    RLC   [X+0]         (0740)                                           ; where the temp table data is located.
                                   (0741)    mov   A, [X+cTEMP_SlopeOffset]         ; compute M*T
7F48: 08       PUSH  A             (0742)    mov   REG[MUL_Y], A
7F49: 52 00    MOV   A,[X+0]       (0743)    mov   A, REG[MUL_DL]                   ; compute M*T*2
7F4B: 20       POP   X             (0744)    asl   A
                                   (0745)    mov   A, REG[MUL_DH]
                                   (0746)    rlc   A                                ; A = M*T*2/256
                                   (0747)    cpl   A                                ; 2's complement the data - complement and then increment
7F4C: 08       PUSH  A             (0748)    inc   A                                ; A = -(M*T*2/256)
7F4D: 28       ROMX                (0749)    add   A, [X+cTEMP_InterceptOffset]     ; Add it to B to compute PW(e) => B - (M*T*2/256) => ERASE PulseWidth
7F4E: 3F FB    MVI   [251],A       (0750)    mov   [bTEMP_PulseWidthErase], A       ; Save the Erase Pulse width in temp area
7F50: 18       POP   A             (0751) 
7F51: 75       INC   X             (0752)    ; 5) Compute the Program PulseWidth      PW(program) = PW(erase) * ProgramMultiplier / 64
7F52: B0 02    JNZ   0x7F55        (0753)    and   A, 7Fh                           ; Mac is signed - Erase pulse width MUST always be < 128
7F54: 74       INC   A             (0754)    mov   REG[MUL_X], A                    ; compute PW(e) * ProgMult
                                   (0755)    mov   A, [X+bTEMP_ProgMultOffset]      ; Mac is signed - First multiply by high 7 bits of ProgMult
7F55: 7A FE    DEC   [254]         (0756)    asr   A                                ; shift high 7 bits down to low 7 bits (divide by 2)
7F57: B0 05    JNZ   0x7F5D        (0757)    and   A, 0x7f                          ; zero out high bit to make it an unsigned divide by 2
7F59: 7A FD    DEC   [253]         (0758)    mov   REG[MUL_Y], A                    ; Do the 7 bit x 7 bit hardware multiply
7F5B: A0 0F    JZ    0x7F6B        (0759) .mult7x7done:
                                   (0760)    mov   A, REG[MUL_DH]                   ; Load 16 bit result into (PulseWidthProg, A)
                                   (0761)    mov   [bTEMP_PulseWidthProgram], A
7F5D: 3C FB 00 CMP   [251],0       (0762)    mov   A, REG[MUL_DL]
7F60: BF EB    JNZ   0x7F4C        (0763)    asl   A                                ; Shift left to compensate for divide by 2 above
7F62: 08       PUSH  A             (0764)    rlc   [bTEMP_PulseWidthProgram]
7F63: 5D D5    MOV   A,REG[213]    (0765) .shift7x7done:
7F65: 74       INC   A             (0766)    tst   [X+bTEMP_ProgMultOffset], 0x01   ; If low bit of ProgMult was set (lost during divide by 2),
7F66: 60 D5    MOV   REG[213],A    (0767)    jz    .mult7x8done                     ; add 1 * PulseWidthErase to product
7F68: 18       POP   A             (0768)    add   A, [bTEMP_PulseWidthErase]
7F69: 8F E2    JMP   0x7F4C        (0769)    adc   [bTEMP_PulseWidthProgram], 0
7F6B: 70 3F    AND   F,63
                                   (0770) .mult7x8done:                             ; PW(e) * ProgMult is in (PulseWidthProg, A)
                                   (0771)    asl   A                                ; shift left twice to get
                                   (0772)    rlc   [bTEMP_PulseWidthProgram]        ; 4 * PW(e) * ProgMult in (PulseWidthProg, A)
7F6D: 71 C0    OR    F,192         (0773)    asl   A                                ; or 4*PW(e)*ProgMult/256 == PW(e)*ProgMult/64 in PulseWidthProg
                                   (0774)    rlc   [bTEMP_PulseWidthProgram]        ; The product MUST be < 2**14 for this to work.
                                   (0775)                                           ; PW(p) = PW(e) * ProgMult / 64
                                   (0776)    ; 6) Save the result data

FILE: <library>
--------------------------------------------------------------------------------


PSoC Designer Version: 5.0.972.0

Copyright (C) 1994 - 2009 ImageCraft Creations Inc.
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Release version 7.01
